# 第三章：分布式系统（30题）

## 3.1 分布式理论（6题）

### 66. CAP理论是什么？如何取舍？

```
┌─────────────────────────────────────────────────────────────────┐
│                        CAP 理论                                  │
├─────────────────────────────────────────────────────────────────┤
│                                                                  │
│                      Consistency                                 │
│                      (一致性)                                    │
│                         /\                                       │
│                        /  \                                      │
│                       /    \                                     │
│                      / CP   \  CA                                │
│                     /        \                                   │
│                    /    ✗     \                                  │
│                   /____________\                                 │
│     Availability               Partition Tolerance               │
│       (可用性)        AP          (分区容错性)                   │
│                                                                  │
│  三者只能同时满足两个，不能三者兼得                              │
│  在分布式系统中，P 是必须的，所以通常在 CP 和 AP 之间选择        │
└─────────────────────────────────────────────────────────────────┘

┌─────────────────────────────────────────────────────────────────┐
│                    三个特性详解                                  │
├─────────────┬───────────────────────────────────────────────────┤
│ Consistency │ 所有节点在同一时刻看到的数据是一致的              │
│   (一致性)  │ 写操作后的读操作一定能读到最新值                  │
├─────────────┼───────────────────────────────────────────────────┤
│Availability │ 系统在正常时间内返回合理响应                      │
│  (可用性)   │ 不是错误或超时响应                                │
├─────────────┼───────────────────────────────────────────────────┤
│ Partition   │ 分布式系统在网络分区故障时                        │
│ Tolerance   │ 仍能继续运行                                      │
│(分区容错性) │                                                   │
└─────────────┴───────────────────────────────────────────────────┘
```

**常见系统的CAP选择：**

| 系统类型 | 选择 | 典型代表 | 特点 |
|---------|------|---------|------|
| CP系统 | 一致性+分区容错 | ZooKeeper、Etcd、HBase | 发生分区时，牺牲可用性保证一致性 |
| AP系统 | 可用性+分区容错 | Eureka、Cassandra、DynamoDB | 发生分区时，牺牲一致性保证可用性 |
| CA系统 | 一致性+可用性 | 单机MySQL | 无法处理网络分区，不适合分布式 |

---

### 67. BASE理论是什么？

```
┌─────────────────────────────────────────────────────────────────┐
│                        BASE 理论                                 │
│              (CAP 中 AP 方案的延伸)                              │
├─────────────────────────────────────────────────────────────────┤
│                                                                  │
│  ┌─────────────────┐                                            │
│  │ Basically       │  基本可用                                   │
│  │ Available       │  - 响应时间可以适当延长                     │
│  │                 │  - 功能可以适当降级                         │
│  └─────────────────┘                                            │
│           │                                                      │
│           ▼                                                      │
│  ┌─────────────────┐                                            │
│  │ Soft State      │  软状态                                     │
│  │                 │  - 允许系统中的数据存在中间状态             │
│  │                 │  - 该状态不影响系统整体可用性               │
│  └─────────────────┘                                            │
│           │                                                      │
│           ▼                                                      │
│  ┌─────────────────┐                                            │
│  │ Eventually      │  最终一致性                                 │
│  │ Consistent      │  - 经过一段时间后，数据最终达到一致         │
│  │                 │  - 不需要实时保证强一致性                   │
│  └─────────────────┘                                            │
│                                                                  │
└─────────────────────────────────────────────────────────────────┘

┌─────────────────────────────────────────────────────────────────┐
│                    ACID vs BASE                                  │
├─────────────────┬───────────────────────────────────────────────┤
│      ACID       │                  BASE                          │
├─────────────────┼───────────────────────────────────────────────┤
│ 强一致性        │ 弱一致性（最终一致性）                         │
│ 隔离性          │ 可用性优先                                     │
│ 注重安全性      │ 注重性能                                       │
│ 悲观锁          │ 乐观锁                                         │
│ 适合金融系统    │ 适合互联网应用                                 │
└─────────────────┴───────────────────────────────────────────────┘
```

---

### 68. 分布式一致性级别有哪些？

```
┌─────────────────────────────────────────────────────────────────┐
│                    分布式一致性级别（由强到弱）                   │
├─────────────────────────────────────────────────────────────────┤
│                                                                  │
│  ┌─────────────────────────────────────────────────────────┐    │
│  │ 1. 强一致性 (Strong Consistency)                        │    │
│  │    - 写入后立即对所有节点可见                           │    │
│  │    - 代价：性能和可用性下降                             │    │
│  │    - 例：ZooKeeper、Etcd                                │    │
│  └─────────────────────────────────────────────────────────┘    │
│                          ▼                                       │
│  ┌─────────────────────────────────────────────────────────┐    │
│  │ 2. 线性一致性 (Linearizability)                         │    │
│  │    - 操作在调用和返回之间的某一时刻原子生效             │    │
│  │    - 所有操作存在全局顺序                               │    │
│  └─────────────────────────────────────────────────────────┘    │
│                          ▼                                       │
│  ┌─────────────────────────────────────────────────────────┐    │
│  │ 3. 顺序一致性 (Sequential Consistency)                  │    │
│  │    - 所有进程看到的操作顺序一致                         │    │
│  │    - 单进程内操作顺序保持                               │    │
│  └─────────────────────────────────────────────────────────┘    │
│                          ▼                                       │
│  ┌─────────────────────────────────────────────────────────┐    │
│  │ 4. 因果一致性 (Causal Consistency)                      │    │
│  │    - 有因果关系的操作按顺序执行                         │    │
│  │    - 无因果关系的操作可并发                             │    │
│  └─────────────────────────────────────────────────────────┘    │
│                          ▼                                       │
│  ┌─────────────────────────────────────────────────────────┐    │
│  │ 5. 最终一致性 (Eventual Consistency)                    │    │
│  │    - 在没有新更新的情况下，最终所有访问都返回最新值     │    │
│  │    - 例：DNS、Cassandra                                 │    │
│  └─────────────────────────────────────────────────────────┘    │
│                                                                  │
└─────────────────────────────────────────────────────────────────┘
```

**最终一致性的变体：**

| 变体 | 说明 |
|-----|------|
| 读己之写 | 进程读取自己写入的值时，总能读到最新值 |
| 单调读 | 如果进程读到某个值，后续读取不会读到更旧的值 |
| 单调写 | 同一进程的写操作按顺序执行 |
| 会话一致性 | 同一会话内保证读己之写 |

---

### 69. Paxos算法的原理？

```
┌─────────────────────────────────────────────────────────────────┐
│                      Paxos 算法角色                              │
├─────────────────────────────────────────────────────────────────┤
│                                                                  │
│  ┌──────────────┐    ┌──────────────┐    ┌──────────────┐       │
│  │  Proposer    │    │  Acceptor    │    │   Learner    │       │
│  │   提案者     │    │   接受者     │    │   学习者     │       │
│  │              │    │              │    │              │       │
│  │ 提出提案     │    │ 接受/拒绝    │    │ 学习被选定   │       │
│  │ (提案号+值)  │    │ 提案         │    │ 的提案       │       │
│  └──────────────┘    └──────────────┘    └──────────────┘       │
│                                                                  │
└─────────────────────────────────────────────────────────────────┘

┌─────────────────────────────────────────────────────────────────┐
│                   Basic Paxos 两阶段流程                         │
├─────────────────────────────────────────────────────────────────┤
│                                                                  │
│  阶段一：Prepare 准备阶段                                        │
│  ═══════════════════════════════════════════════                │
│                                                                  │
│  Proposer                     Acceptor                          │
│      │                           │                               │
│      │    Prepare(n)             │  n = 提案编号                 │
│      │──────────────────────────>│                               │
│      │                           │                               │
│      │    Promise(n, v_accepted) │  如果 n > 已承诺的编号        │
│      │<──────────────────────────│  返回已接受的最大提案         │
│      │                           │                               │
│                                                                  │
│  阶段二：Accept 接受阶段                                         │
│  ═══════════════════════════════════════════════                │
│                                                                  │
│  Proposer                     Acceptor                          │
│      │                           │                               │
│      │    Accept(n, v)           │  v = 阶段一返回的值或新值     │
│      │──────────────────────────>│                               │
│      │                           │                               │
│      │    Accepted(n, v)         │  如果 n >= 已承诺的编号       │
│      │<──────────────────────────│  接受提案                     │
│      │                           │                               │
│                                                                  │
└─────────────────────────────────────────────────────────────────┘

┌─────────────────────────────────────────────────────────────────┐
│                    Paxos 完整流程示例                            │
├─────────────────────────────────────────────────────────────────┤
│                                                                  │
│  Proposer         Acceptor1    Acceptor2    Acceptor3           │
│      │                │            │            │                │
│      │  Prepare(1)    │            │            │                │
│      │───────────────>│            │            │                │
│      │───────────────────────────>│            │                │
│      │─────────────────────────────────────────>│                │
│      │                │            │            │                │
│      │  Promise(1,∅)  │            │            │                │
│      │<───────────────│            │            │                │
│      │<───────────────────────────│            │                │
│      │<─────────────────────────────────────────│                │
│      │                │            │            │                │
│      │  Accept(1,"X") │            │            │  收到多数派    │
│      │───────────────>│            │            │  Promise后     │
│      │───────────────────────────>│            │  发送Accept    │
│      │─────────────────────────────────────────>│                │
│      │                │            │            │                │
│      │  Accepted(1)   │            │            │                │
│      │<───────────────│            │            │                │
│      │<───────────────────────────│            │                │
│      │<─────────────────────────────────────────│  多数派接受    │
│      │                │            │            │  提案通过!     │
│                                                                  │
└─────────────────────────────────────────────────────────────────┘
```

**Paxos的特点：**
- 保证在任何情况下只会选定一个值
- 活锁问题：多个Proposer竞争可能导致无法达成一致
- Multi-Paxos优化：选举Leader减少竞争

---

### 70. Raft算法的原理？

```
┌─────────────────────────────────────────────────────────────────┐
│                      Raft 节点状态                               │
├─────────────────────────────────────────────────────────────────┤
│                                                                  │
│           超时              获得多数投票                         │
│  ┌────────────────┐    ┌────────────────┐                       │
│  │                ▼    │                ▼                       │
│  │   ┌──────────────────────────────────────┐                   │
│  │   │            Candidate                 │                   │
│  │   │              候选人                  │                   │
│  │   └──────────────────────────────────────┘                   │
│  │        ▲                        │                            │
│  │        │ 选举超时               │ 成为Leader                 │
│  │        │                        ▼                            │
│  │   ┌──────────┐            ┌──────────┐                       │
│  │   │ Follower │◄───────────│  Leader  │                       │
│  │   │  追随者  │  发现新任期 │   领导者 │                       │
│  └───│          │  或更高     │          │                       │
│      └──────────┘             └──────────┘                       │
│           ▲                        │                            │
│           │      心跳/日志复制     │                            │
│           └────────────────────────┘                            │
│                                                                  │
└─────────────────────────────────────────────────────────────────┘

┌─────────────────────────────────────────────────────────────────┐
│                     Raft 核心机制                                │
├─────────────────────────────────────────────────────────────────┤
│                                                                  │
│  1. Leader选举                                                   │
│  ┌─────────────────────────────────────────────────────────┐    │
│  │                                                         │    │
│  │  Node1(Follower)    Node2(Follower)    Node3(Follower) │    │
│  │       │                  │                   │          │    │
│  │       │  选举超时        │                   │          │    │
│  │       ▼                  │                   │          │    │
│  │  Node1(Candidate)        │                   │          │    │
│  │       │                  │                   │          │    │
│  │       │ RequestVote(term=1)                  │          │    │
│  │       │─────────────────>│                   │          │    │
│  │       │──────────────────────────────────────>│          │    │
│  │       │                  │                   │          │    │
│  │       │   VoteGranted    │                   │          │    │
│  │       │<─────────────────│                   │          │    │
│  │       │<──────────────────────────────────────│          │    │
│  │       ▼                                      │          │    │
│  │  Node1(Leader)  获得多数票，成为Leader       │          │    │
│  │                                                         │    │
│  └─────────────────────────────────────────────────────────┘    │
│                                                                  │
│  2. 日志复制                                                     │
│  ┌─────────────────────────────────────────────────────────┐    │
│  │                                                         │    │
│  │  Client ──> Leader                                      │    │
│  │               │                                         │    │
│  │               │ AppendEntries (日志条目)                │    │
│  │               │──────────────>│ Follower1              │    │
│  │               │──────────────────────────>│ Follower2  │    │
│  │               │                           │             │    │
│  │               │        多数派确认         │             │    │
│  │               │<──────────────│           │             │    │
│  │               │<──────────────────────────│             │    │
│  │               │                                         │    │
│  │               │ 提交日志，应用到状态机                  │    │
│  │               │ 返回结果给Client                        │    │
│  │                                                         │    │
│  └─────────────────────────────────────────────────────────┘    │
│                                                                  │
└─────────────────────────────────────────────────────────────────┘
```

**Raft vs Paxos：**

| 对比项 | Raft | Paxos |
|-------|------|-------|
| 可理解性 | 容易理解 | 复杂难懂 |
| Leader | 强Leader | 无固定Leader |
| 日志 | 连续日志复制 | 可以乱序 |
| 实现难度 | 相对简单 | 复杂 |
| 应用 | Etcd、Consul | ZooKeeper |

---

### 71. 拜占庭将军问题是什么？

```
┌─────────────────────────────────────────────────────────────────┐
│                     拜占庭将军问题                               │
├─────────────────────────────────────────────────────────────────┤
│                                                                  │
│  场景描述：多位将军需要通过信使传递消息达成一致行动              │
│           但其中可能存在叛徒（恶意节点）                         │
│                                                                  │
│          ┌───────────┐                                          │
│          │  将军A    │  (忠诚)                                  │
│          │  进攻!    │                                          │
│          └─────┬─────┘                                          │
│                │                                                 │
│      ┌─────────┼─────────┐                                      │
│      │         │         │                                      │
│      ▼         ▼         ▼                                      │
│  ┌───────┐ ┌───────┐ ┌───────┐                                  │
│  │将军B  │ │将军C  │ │将军D  │                                  │
│  │(忠诚) │ │(叛徒) │ │(忠诚) │                                  │
│  │       │ │       │ │       │                                  │
│  │收到:  │ │发送:  │ │收到:  │                                  │
│  │进攻   │ │进攻给B│ │进攻   │                                  │
│  │       │ │撤退给D│ │       │                                  │
│  └───────┘ └───────┘ └───────┘                                  │
│                                                                  │
│  问题：如何让忠诚的将军达成一致决策？                            │
│                                                                  │
└─────────────────────────────────────────────────────────────────┘

┌─────────────────────────────────────────────────────────────────┐
│                   拜占庭容错 vs 非拜占庭容错                     │
├─────────────────────────────────────────────────────────────────┤
│                                                                  │
│  ┌─────────────────────────────────────────────────────────┐    │
│  │              非拜占庭容错 (CFT)                          │    │
│  │                                                         │    │
│  │  故障类型：节点宕机、网络分区（诚实故障）               │    │
│  │  容错能力：n ≥ 2f + 1 (n个节点容忍f个故障)             │    │
│  │  代表算法：Paxos、Raft                                  │    │
│  │  应用场景：私有/联盟环境，如数据库复制                  │    │
│  │                                                         │    │
│  └─────────────────────────────────────────────────────────┘    │
│                                                                  │
│  ┌─────────────────────────────────────────────────────────┐    │
│  │              拜占庭容错 (BFT)                            │    │
│  │                                                         │    │
│  │  故障类型：节点恶意行为、发送虚假信息                   │    │
│  │  容错能力：n ≥ 3f + 1 (n个节点容忍f个恶意节点)         │    │
│  │  代表算法：PBFT、PoW                                    │    │
│  │  应用场景：公开环境，如区块链                           │    │
│  │                                                         │    │
│  └─────────────────────────────────────────────────────────┘    │
│                                                                  │
└─────────────────────────────────────────────────────────────────┘
```

---

## 3.2 分布式事务（8题）

### 72. 分布式事务的解决方案有哪些？

```
┌─────────────────────────────────────────────────────────────────┐
│                    分布式事务解决方案全景图                       │
├─────────────────────────────────────────────────────────────────┤
│                                                                  │
│  ┌───────────────────────────────────────────────────────────┐  │
│  │                    强一致性方案                            │  │
│  │  ┌─────────────┐  ┌─────────────┐  ┌─────────────┐        │  │
│  │  │    2PC      │  │    3PC      │  │    XA       │        │  │
│  │  │  两阶段提交 │  │  三阶段提交 │  │  分布式事务 │        │  │
│  │  │             │  │             │  │  协议       │        │  │
│  │  └─────────────┘  └─────────────┘  └─────────────┘        │  │
│  └───────────────────────────────────────────────────────────┘  │
│                                                                  │
│  ┌───────────────────────────────────────────────────────────┐  │
│  │                    最终一致性方案                          │  │
│  │  ┌─────────────┐  ┌─────────────┐  ┌─────────────┐        │  │
│  │  │    TCC      │  │   Saga      │  │  本地消息表 │        │  │
│  │  │ Try-Confirm │  │   长事务    │  │             │        │  │
│  │  │ -Cancel     │  │             │  │             │        │  │
│  │  └─────────────┘  └─────────────┘  └─────────────┘        │  │
│  │                                                           │  │
│  │  ┌─────────────┐  ┌─────────────┐  ┌─────────────┐        │  │
│  │  │  可靠消息   │  │ 最大努力    │  │   Seata     │        │  │
│  │  │  最终一致   │  │ 通知        │  │   AT模式    │        │  │
│  │  └─────────────┘  └─────────────┘  └─────────────┘        │  │
│  └───────────────────────────────────────────────────────────┘  │
│                                                                  │
└─────────────────────────────────────────────────────────────────┘

┌─────────────────────────────────────────────────────────────────┐
│                      方案对比                                    │
├───────────┬─────────┬─────────┬─────────┬───────────────────────┤
│   方案    │ 一致性  │  性能   │ 复杂度  │      适用场景         │
├───────────┼─────────┼─────────┼─────────┼───────────────────────┤
│   2PC     │   强    │   低    │   低    │ 数据库层面            │
├───────────┼─────────┼─────────┼─────────┼───────────────────────┤
│   TCC     │   最终  │   中    │   高    │ 金融、高一致性要求    │
├───────────┼─────────┼─────────┼─────────┼───────────────────────┤
│   Saga    │   最终  │   高    │   中    │ 长事务、微服务        │
├───────────┼─────────┼─────────┼─────────┼───────────────────────┤
│ 本地消息表│   最终  │   高    │   中    │ 跨系统调用            │
├───────────┼─────────┼─────────┼─────────┼───────────────────────┤
│ Seata AT  │   最终  │   中    │   低    │ 简单业务场景          │
└───────────┴─────────┴─────────┴─────────┴───────────────────────┘
```

---

### 73. 2PC和3PC的区别？

```
┌─────────────────────────────────────────────────────────────────┐
│                   2PC 两阶段提交                                 │
├─────────────────────────────────────────────────────────────────┤
│                                                                  │
│   协调者                  参与者A              参与者B           │
│     │                        │                    │              │
│     │  ════ 阶段1: 准备 ════ │                    │              │
│     │                        │                    │              │
│     │   Prepare             │                    │              │
│     │───────────────────────>│                    │              │
│     │─────────────────────────────────────────────>│              │
│     │                        │                    │              │
│     │   Vote Yes/No         │                    │              │
│     │<───────────────────────│                    │              │
│     │<─────────────────────────────────────────────│              │
│     │                        │                    │              │
│     │  ════ 阶段2: 提交 ════ │                    │              │
│     │                        │                    │              │
│     │   Commit/Rollback     │                    │              │
│     │───────────────────────>│                    │              │
│     │─────────────────────────────────────────────>│              │
│     │                        │                    │              │
│     │   ACK                  │                    │              │
│     │<───────────────────────│                    │              │
│     │<─────────────────────────────────────────────│              │
│                                                                  │
│  问题：                                                          │
│  1. 同步阻塞：准备后参与者阻塞等待                               │
│  2. 单点故障：协调者故障导致参与者永久阻塞                       │
│  3. 数据不一致：部分Commit成功部分失败                           │
│                                                                  │
└─────────────────────────────────────────────────────────────────┘

┌─────────────────────────────────────────────────────────────────┐
│                   3PC 三阶段提交                                 │
├─────────────────────────────────────────────────────────────────┤
│                                                                  │
│   协调者                  参与者A              参与者B           │
│     │                        │                    │              │
│     │  ════ 阶段1: CanCommit ════                 │              │
│     │                        │                    │              │
│     │   CanCommit?          │                    │              │
│     │───────────────────────>│                    │              │
│     │─────────────────────────────────────────────>│              │
│     │                        │                    │              │
│     │   Yes/No              │                    │              │
│     │<───────────────────────│                    │              │
│     │<─────────────────────────────────────────────│              │
│     │                        │                    │              │
│     │  ════ 阶段2: PreCommit ════                 │              │
│     │                        │                    │              │
│     │   PreCommit           │                    │              │
│     │───────────────────────>│                    │              │
│     │─────────────────────────────────────────────>│              │
│     │                        │                    │              │
│     │   ACK                  │                    │  锁定资源    │
│     │<───────────────────────│                    │              │
│     │<─────────────────────────────────────────────│              │
│     │                        │                    │              │
│     │  ════ 阶段3: DoCommit ════                  │              │
│     │                        │                    │              │
│     │   DoCommit            │                    │              │
│     │───────────────────────>│                    │              │
│     │─────────────────────────────────────────────>│              │
│     │                        │                    │              │
│                                                                  │
└─────────────────────────────────────────────────────────────────┘
```

**2PC vs 3PC对比：**

| 对比项 | 2PC | 3PC |
|-------|-----|-----|
| 阶段数 | 2个 | 3个 |
| 超时机制 | 仅协调者 | 协调者和参与者都有 |
| 阻塞问题 | 严重 | 减轻 |
| 数据一致性 | 可能不一致 | 降低不一致概率 |
| 网络分区 | 处理差 | 处理稍好 |
| 复杂度 | 简单 | 复杂 |

---

### 74. TCC的原理和实现？

```
┌─────────────────────────────────────────────────────────────────┐
│                    TCC 模式原理                                  │
├─────────────────────────────────────────────────────────────────┤
│                                                                  │
│     TCC = Try + Confirm + Cancel                                 │
│                                                                  │
│  ┌─────────────────────────────────────────────────────────┐    │
│  │  Try (尝试)                                             │    │
│  │  - 完成业务检查                                         │    │
│  │  - 预留业务资源（冻结库存、冻结金额）                   │    │
│  └─────────────────────────────────────────────────────────┘    │
│                          │                                       │
│              ┌───────────┴───────────┐                          │
│              │                       │                          │
│              ▼                       ▼                          │
│  ┌─────────────────────┐  ┌─────────────────────┐               │
│  │  Confirm (确认)     │  │  Cancel (取消)      │               │
│  │  - 确认执行业务     │  │  - 取消执行业务     │               │
│  │  - 使用预留资源     │  │  - 释放预留资源     │               │
│  │  - 不做业务检查     │  │                     │               │
│  │  - 需要幂等         │  │  - 需要幂等         │               │
│  └─────────────────────┘  └─────────────────────┘               │
│                                                                  │
└─────────────────────────────────────────────────────────────────┘

┌─────────────────────────────────────────────────────────────────┐
│                  TCC 转账示例                                    │
├─────────────────────────────────────────────────────────────────┤
│                                                                  │
│  场景：A向B转账100元                                            │
│                                                                  │
│  ┌─────────────────────────────────────────────────────────┐    │
│  │  Try阶段                                                │    │
│  │                                                         │    │
│  │  账户A：                          账户B：               │    │
│  │  ┌─────────────┐                  ┌─────────────┐       │    │
│  │  │ 余额: 1000  │                  │ 余额: 500   │       │    │
│  │  │ 冻结: 100   │  ←── 预留资源    │ 冻结: 0     │       │    │
│  │  │ 可用: 900   │                  │ 可用: 500   │       │    │
│  │  └─────────────┘                  └─────────────┘       │    │
│  │                                                         │    │
│  └─────────────────────────────────────────────────────────┘    │
│                                                                  │
│  ┌─────────────────────────────────────────────────────────┐    │
│  │  Confirm阶段 (所有Try成功)                              │    │
│  │                                                         │    │
│  │  账户A：                          账户B：               │    │
│  │  ┌─────────────┐                  ┌─────────────┐       │    │
│  │  │ 余额: 900   │  扣减冻结金额    │ 余额: 600   │       │    │
│  │  │ 冻结: 0     │ ═══════════════> │ 冻结: 0     │       │    │
│  │  │ 可用: 900   │                  │ 可用: 600   │       │    │
│  │  └─────────────┘                  └─────────────┘       │    │
│  │                                                         │    │
│  └─────────────────────────────────────────────────────────┘    │
│                                                                  │
│  ┌─────────────────────────────────────────────────────────┐    │
│  │  Cancel阶段 (任一Try失败)                               │    │
│  │                                                         │    │
│  │  账户A：                          账户B：               │    │
│  │  ┌─────────────┐                  ┌─────────────┐       │    │
│  │  │ 余额: 1000  │  释放冻结金额    │ 余额: 500   │       │    │
│  │  │ 冻结: 0     │                  │ 冻结: 0     │       │    │
│  │  │ 可用: 1000  │                  │ 可用: 500   │       │    │
│  │  └─────────────┘                  └─────────────┘       │    │
│  │                                                         │    │
│  └─────────────────────────────────────────────────────────┘    │
│                                                                  │
└─────────────────────────────────────────────────────────────────┘
```

**TCC需要解决的问题：**

| 问题 | 解决方案 |
|-----|---------|
| 空回滚 | Cancel时判断Try是否执行过 |
| 悬挂 | Try执行前检查Cancel是否已执行 |
| 幂等 | 记录事务状态，重复请求直接返回 |

---

### 75. 本地消息表方案是怎样的？

```
┌─────────────────────────────────────────────────────────────────┐
│                     本地消息表方案                               │
├─────────────────────────────────────────────────────────────────┤
│                                                                  │
│  服务A (订单服务)                    服务B (库存服务)            │
│  ┌─────────────────────┐            ┌─────────────────────┐     │
│  │                     │            │                     │     │
│  │  ┌───────────────┐  │            │  ┌───────────────┐  │     │
│  │  │  订单表       │  │            │  │  库存表       │  │     │
│  │  │  orders       │  │            │  │  inventory    │  │     │
│  │  └───────────────┘  │            │  └───────────────┘  │     │
│  │         │           │            │                     │     │
│  │         │ 同一事务   │            │                     │     │
│  │         │           │            │                     │     │
│  │  ┌───────────────┐  │            │  ┌───────────────┐  │     │
│  │  │ 本地消息表    │  │            │  │ 消息消费记录  │  │     │
│  │  │ local_msg     │  │            │  │ consume_log   │  │     │
│  │  │               │  │            │  │               │  │     │
│  │  │ - msg_id      │  │            │  │ - msg_id      │  │     │
│  │  │ - content     │  │            │  │ - status      │  │     │
│  │  │ - status      │  │   MQ       │  │ - create_time │  │     │
│  │  │ - retry_count │──┼─────────────>│               │  │     │
│  │  └───────────────┘  │            │  └───────────────┘  │     │
│  │                     │            │                     │     │
│  └─────────────────────┘            └─────────────────────┘     │
│                                                                  │
└─────────────────────────────────────────────────────────────────┘

┌─────────────────────────────────────────────────────────────────┐
│                      执行流程                                    │
├─────────────────────────────────────────────────────────────────┤
│                                                                  │
│  1. 创建订单（同一本地事务）                                    │
│  ┌─────────────────────────────────────────────────────────┐    │
│  │  BEGIN TRANSACTION                                      │    │
│  │    INSERT INTO orders (...)                             │    │
│  │    INSERT INTO local_msg (msg_id, content, status='NEW')│    │
│  │  COMMIT                                                 │    │
│  └─────────────────────────────────────────────────────────┘    │
│                          │                                       │
│                          ▼                                       │
│  2. 后台定时任务扫描消息表                                       │
│  ┌─────────────────────────────────────────────────────────┐    │
│  │  SELECT * FROM local_msg WHERE status='NEW'             │    │
│  │  发送到MQ                                               │    │
│  │  UPDATE local_msg SET status='SENT'                     │    │
│  └─────────────────────────────────────────────────────────┘    │
│                          │                                       │
│                          ▼                                       │
│  3. 服务B消费消息                                                │
│  ┌─────────────────────────────────────────────────────────┐    │
│  │  消费消息                                               │    │
│  │  执行扣减库存                                           │    │
│  │  记录消费日志（幂等）                                   │    │
│  │  ACK确认                                                │    │
│  └─────────────────────────────────────────────────────────┘    │
│                          │                                       │
│                          ▼                                       │
│  4. 服务A更新消息状态                                            │
│  ┌─────────────────────────────────────────────────────────┐    │
│  │  UPDATE local_msg SET status='DONE'                     │    │
│  └─────────────────────────────────────────────────────────┘    │
│                                                                  │
└─────────────────────────────────────────────────────────────────┘
```

---

### 76. 最大努力通知方案？

```
┌─────────────────────────────────────────────────────────────────┐
│                    最大努力通知方案                              │
├─────────────────────────────────────────────────────────────────┤
│                                                                  │
│  典型场景：支付回调通知                                         │
│                                                                  │
│  ┌──────────┐         ┌──────────┐         ┌──────────┐        │
│  │  商户    │         │ 支付平台 │         │ 通知服务 │        │
│  │  系统    │         │          │         │          │        │
│  └────┬─────┘         └────┬─────┘         └────┬─────┘        │
│       │                    │                    │               │
│       │  1.发起支付        │                    │               │
│       │───────────────────>│                    │               │
│       │                    │                    │               │
│       │  2.支付成功        │                    │               │
│       │                    │  3.记录通知任务    │               │
│       │                    │───────────────────>│               │
│       │                    │                    │               │
│       │          4.首次通知                     │               │
│       │<────────────────────────────────────────│               │
│       │                    │                    │               │
│       │  5.通知失败        │                    │               │
│       │           ✗        │                    │               │
│       │                    │                    │               │
│       │          6.间隔1min再次通知             │               │
│       │<────────────────────────────────────────│               │
│       │           ✗        │                    │               │
│       │                    │                    │               │
│       │          7.间隔5min再次通知             │               │
│       │<────────────────────────────────────────│               │
│       │           ✗        │                    │               │
│       │                    │                    │               │
│       │          8.间隔30min再次通知            │               │
│       │<────────────────────────────────────────│               │
│       │           ✓        │                    │               │
│       │                    │                    │               │
│       │   9.主动查询接口（兜底）                │               │
│       │───────────────────>│                    │               │
│       │<───────────────────│                    │               │
│       │                    │                    │               │
│                                                                  │
└─────────────────────────────────────────────────────────────────┘

┌─────────────────────────────────────────────────────────────────┐
│                      通知策略                                    │
├─────────────────────────────────────────────────────────────────┤
│                                                                  │
│  通知间隔：1min, 5min, 10min, 30min, 1h, 2h, 6h, 24h            │
│                                                                  │
│  最大通知次数：8次（可配置）                                     │
│                                                                  │
│  超过最大次数后：停止通知，等待商户主动查询                      │
│                                                                  │
│  特点：                                                          │
│  - 不保证消息一定送达                                           │
│  - 提供主动查询接口作为兜底                                     │
│  - 接收方需要实现幂等                                           │
│                                                                  │
└─────────────────────────────────────────────────────────────────┘
```

---

### 77. Seata的AT模式原理？

```
┌─────────────────────────────────────────────────────────────────┐
│                    Seata AT模式架构                              │
├─────────────────────────────────────────────────────────────────┤
│                                                                  │
│                     ┌──────────────────┐                        │
│                     │   TC (事务协调器) │                        │
│                     │ Transaction      │                        │
│                     │ Coordinator      │                        │
│                     └────────┬─────────┘                        │
│                              │                                   │
│            ┌─────────────────┼─────────────────┐                │
│            │                 │                 │                │
│            ▼                 ▼                 ▼                │
│  ┌──────────────┐  ┌──────────────┐  ┌──────────────┐          │
│  │  TM          │  │  RM          │  │  RM          │          │
│  │ Transaction  │  │ Resource     │  │ Resource     │          │
│  │ Manager      │  │ Manager      │  │ Manager      │          │
│  │ (事务管理器)  │  │ (资源管理器) │  │ (资源管理器) │          │
│  │              │  │              │  │              │          │
│  │ 业务服务A    │  │ 业务服务B    │  │ 业务服务C    │          │
│  └──────────────┘  └──────────────┘  └──────────────┘          │
│                                                                  │
└─────────────────────────────────────────────────────────────────┘

┌─────────────────────────────────────────────────────────────────┐
│                    AT模式执行流程                                │
├─────────────────────────────────────────────────────────────────┤
│                                                                  │
│  一阶段：业务SQL执行                                            │
│  ┌─────────────────────────────────────────────────────────┐    │
│  │                                                         │    │
│  │  1. 解析SQL，获取表名、条件等                           │    │
│  │                    │                                    │    │
│  │                    ▼                                    │    │
│  │  2. 查询前镜像 (Before Image)                           │    │
│  │     SELECT * FROM table WHERE condition                 │    │
│  │                    │                                    │    │
│  │                    ▼                                    │    │
│  │  3. 执行业务SQL                                         │    │
│  │     UPDATE table SET ... WHERE condition                │    │
│  │                    │                                    │    │
│  │                    ▼                                    │    │
│  │  4. 查询后镜像 (After Image)                            │    │
│  │     SELECT * FROM table WHERE condition                 │    │
│  │                    │                                    │    │
│  │                    ▼                                    │    │
│  │  5. 插入undo_log                                        │    │
│  │     保存前后镜像数据                                    │    │
│  │                    │                                    │    │
│  │                    ▼                                    │    │
│  │  6. 本地事务提交，向TC注册分支                          │    │
│  │                                                         │    │
│  └─────────────────────────────────────────────────────────┘    │
│                                                                  │
│  二阶段-提交：                                                   │
│  ┌─────────────────────────────────────────────────────────┐    │
│  │  异步删除undo_log（非常快）                             │    │
│  └─────────────────────────────────────────────────────────┘    │
│                                                                  │
│  二阶段-回滚：                                                   │
│  ┌─────────────────────────────────────────────────────────┐    │
│  │  1. 根据undo_log的前镜像生成反向SQL                     │    │
│  │  2. 执行反向SQL恢复数据                                 │    │
│  │  3. 删除undo_log                                        │    │
│  └─────────────────────────────────────────────────────────┘    │
│                                                                  │
└─────────────────────────────────────────────────────────────────┘

┌─────────────────────────────────────────────────────────────────┐
│                    undo_log 表结构                               │
├─────────────────────────────────────────────────────────────────┤
│                                                                  │
│  CREATE TABLE undo_log (                                        │
│    id BIGINT PRIMARY KEY,                                       │
│    branch_id BIGINT,           -- 分支事务ID                    │
│    xid VARCHAR(100),           -- 全局事务ID                    │
│    context VARCHAR(128),       -- 上下文                        │
│    rollback_info LONGBLOB,     -- 回滚信息（前后镜像）          │
│    log_status INT,             -- 状态                          │
│    log_created DATETIME,                                        │
│    log_modified DATETIME                                        │
│  );                                                             │
│                                                                  │
└─────────────────────────────────────────────────────────────────┘
```

---

### 78. Saga模式是什么？

```
┌─────────────────────────────────────────────────────────────────┐
│                      Saga 模式                                   │
├─────────────────────────────────────────────────────────────────┤
│                                                                  │
│  定义：将长事务拆分为多个本地短事务，每个事务有对应的补偿操作    │
│                                                                  │
│  正向执行：T1 → T2 → T3 → T4 → T5                               │
│                                                                  │
│  补偿执行：C1 ← C2 ← C3 ← C4 ← C5                               │
│                                                                  │
└─────────────────────────────────────────────────────────────────┘

┌─────────────────────────────────────────────────────────────────┐
│                    Saga 执行流程示例                             │
├─────────────────────────────────────────────────────────────────┤
│                                                                  │
│  场景：订单流程 = 创建订单 + 扣库存 + 扣款 + 发货                │
│                                                                  │
│  正常流程：                                                      │
│  ┌─────────┐  ┌─────────┐  ┌─────────┐  ┌─────────┐            │
│  │ T1:创建 │─>│ T2:扣库 │─>│ T3:扣款 │─>│ T4:发货 │  成功!     │
│  │ 订单    │  │ 存      │  │         │  │         │            │
│  └─────────┘  └─────────┘  └─────────┘  └─────────┘            │
│                                                                  │
│  异常流程（T3失败）：                                            │
│  ┌─────────┐  ┌─────────┐  ┌─────────┐                         │
│  │ T1:创建 │─>│ T2:扣库 │─>│ T3:扣款 │ ✗ 失败                  │
│  │ 订单    │  │ 存      │  │         │                         │
│  └─────────┘  └─────────┘  └────┬────┘                         │
│       ▲            ▲            │                               │
│       │            │            │ 触发补偿                      │
│       │            │            ▼                               │
│  ┌─────────┐  ┌─────────┐                                       │
│  │ C1:取消 │<─│ C2:恢复 │<─────────────┘                        │
│  │ 订单    │  │ 库存    │                                       │
│  └─────────┘  └─────────┘                                       │
│                                                                  │
└─────────────────────────────────────────────────────────────────┘

┌─────────────────────────────────────────────────────────────────┐
│                   Saga 两种实现模式                              │
├─────────────────────────────────────────────────────────────────┤
│                                                                  │
│  1. 编排式 (Choreography)                                       │
│  ┌─────────────────────────────────────────────────────────┐    │
│  │                                                         │    │
│  │   服务A ──事件──> 服务B ──事件──> 服务C                 │    │
│  │     │               │               │                   │    │
│  │     │               │               │                   │    │
│  │     └──────── 事件总线 ─────────────┘                   │    │
│  │                                                         │    │
│  │   特点：去中心化，服务间通过事件通信                    │    │
│  │   缺点：流程分散，难以追踪                              │    │
│  │                                                         │    │
│  └─────────────────────────────────────────────────────────┘    │
│                                                                  │
│  2. 编制式 (Orchestration) - 推荐                               │
│  ┌─────────────────────────────────────────────────────────┐    │
│  │                                                         │    │
│  │              ┌─────────────────┐                        │    │
│  │              │  Saga编排器     │                        │    │
│  │              │ (中央协调者)    │                        │    │
│  │              └────────┬────────┘                        │    │
│  │                 ┌─────┼─────┐                           │    │
│  │                 │     │     │                           │    │
│  │                 ▼     ▼     ▼                           │    │
│  │              服务A  服务B  服务C                        │    │
│  │                                                         │    │
│  │   特点：中心化控制，流程清晰                            │    │
│  │   优点：易于监控和管理                                  │    │
│  │                                                         │    │
│  └─────────────────────────────────────────────────────────┘    │
│                                                                  │
└─────────────────────────────────────────────────────────────────┘
```

---

### 79. 如何保证消息的最终一致性？

```
┌─────────────────────────────────────────────────────────────────┐
│                 消息最终一致性方案                               │
├─────────────────────────────────────────────────────────────────┤
│                                                                  │
│  方案一：事务消息（RocketMQ）                                    │
│  ┌─────────────────────────────────────────────────────────┐    │
│  │                                                         │    │
│  │  Producer              RocketMQ            Consumer     │    │
│  │     │                     │                    │        │    │
│  │     │ 1.发送半消息        │                    │        │    │
│  │     │────────────────────>│                    │        │    │
│  │     │                     │                    │        │    │
│  │     │ 2.执行本地事务      │                    │        │    │
│  │     │     │               │                    │        │    │
│  │     │     ▼               │                    │        │    │
│  │     │ 3.提交/回滚        │                    │        │    │
│  │     │────────────────────>│                    │        │    │
│  │     │                     │                    │        │    │
│  │     │                     │ 4.投递消息         │        │    │
│  │     │                     │───────────────────>│        │    │
│  │     │                     │                    │        │    │
│  │     │ 5.事务状态回查（异常时）                 │        │    │
│  │     │<────────────────────│                    │        │    │
│  │     │────────────────────>│                    │        │    │
│  │                                                         │    │
│  └─────────────────────────────────────────────────────────┘    │
│                                                                  │
│  方案二：本地消息表 + 定时任务                                   │
│  ┌─────────────────────────────────────────────────────────┐    │
│  │                                                         │    │
│  │   同一事务                                              │    │
│  │  ┌──────────────────┐                                   │    │
│  │  │ 1.业务操作        │                                   │    │
│  │  │ 2.写入消息表      │                                   │    │
│  │  └──────────────────┘                                   │    │
│  │           │                                              │    │
│  │           ▼                                              │    │
│  │  ┌──────────────────┐                                   │    │
│  │  │ 定时任务扫描消息表│                                   │    │
│  │  │ 发送到MQ         │                                   │    │
│  │  └──────────────────┘                                   │    │
│  │                                                         │    │
│  └─────────────────────────────────────────────────────────┘    │
│                                                                  │
└─────────────────────────────────────────────────────────────────┘

┌─────────────────────────────────────────────────────────────────┐
│                   消费端保证                                     │
├─────────────────────────────────────────────────────────────────┤
│                                                                  │
│  1. 幂等消费                                                     │
│     - 利用唯一索引                                              │
│     - 使用去重表                                                │
│     - 利用Redis SETNX                                           │
│                                                                  │
│  2. 消费失败重试                                                │
│     - 重试间隔递增                                              │
│     - 最大重试次数限制                                          │
│     - 死信队列兜底                                              │
│                                                                  │
│  3. 手动ACK                                                     │
│     - 确保业务处理成功后再确认                                  │
│                                                                  │
└─────────────────────────────────────────────────────────────────┘
```

---

## 3.3 分布式锁（6题）

### 80. 分布式锁的实现方案有哪些？

```
┌─────────────────────────────────────────────────────────────────┐
│                    分布式锁实现方案对比                          │
├─────────────────────────────────────────────────────────────────┤
│                                                                  │
│  ┌─────────────────────────────────────────────────────────┐    │
│  │  1. 基于数据库                                          │    │
│  │                                                         │    │
│  │  方式一：唯一索引                                       │    │
│  │  INSERT INTO lock_table(lock_key) VALUES('xxx')         │    │
│  │                                                         │    │
│  │  方式二：for update                                     │    │
│  │  SELECT * FROM lock_table WHERE key='xxx' FOR UPDATE    │    │
│  │                                                         │    │
│  │  优点：实现简单                                         │    │
│  │  缺点：性能差、可靠性低                                 │    │
│  └─────────────────────────────────────────────────────────┘    │
│                                                                  │
│  ┌─────────────────────────────────────────────────────────┐    │
│  │  2. 基于Redis                                           │    │
│  │                                                         │    │
│  │  SET key value NX PX 30000                              │    │
│  │                                                         │    │
│  │  优点：性能高                                           │    │
│  │  缺点：主从异步复制可能导致锁失效                       │    │
│  │  改进：Redlock算法                                      │    │
│  └─────────────────────────────────────────────────────────┘    │
│                                                                  │
│  ┌─────────────────────────────────────────────────────────┐    │
│  │  3. 基于ZooKeeper                                       │    │
│  │                                                         │    │
│  │  创建临时顺序节点                                       │    │
│  │  /locks/lock-0000000001                                 │    │
│  │  /locks/lock-0000000002                                 │    │
│  │                                                         │    │
│  │  优点：可靠性高、自动释放                               │    │
│  │  缺点：性能不如Redis                                    │    │
│  └─────────────────────────────────────────────────────────┘    │
│                                                                  │
│  ┌─────────────────────────────────────────────────────────┐    │
│  │  4. 基于Etcd                                            │    │
│  │                                                         │    │
│  │  利用Lease租约机制                                      │    │
│  │                                                         │    │
│  │  优点：强一致性、可靠性高                               │    │
│  │  缺点：部署复杂                                         │    │
│  └─────────────────────────────────────────────────────────┘    │
│                                                                  │
└─────────────────────────────────────────────────────────────────┘

┌─────────────────────────────────────────────────────────────────┐
│                      方案对比                                    │
├─────────┬─────────┬─────────┬─────────┬─────────────────────────┤
│  方案   │  性能   │ 可靠性  │ 复杂度  │      推荐场景           │
├─────────┼─────────┼─────────┼─────────┼─────────────────────────┤
│ 数据库  │   低    │   低    │   低    │ 并发量小的场景          │
├─────────┼─────────┼─────────┼─────────┼─────────────────────────┤
│ Redis   │   高    │   中    │   中    │ 高并发、允许少量失败    │
├─────────┼─────────┼─────────┼─────────┼─────────────────────────┤
│ ZK      │   中    │   高    │   中    │ 要求高可靠性的场景      │
├─────────┼─────────┼─────────┼─────────┼─────────────────────────┤
│ Etcd    │   中    │   高    │   高    │ 云原生环境              │
└─────────┴─────────┴─────────┴─────────┴─────────────────────────┘
```

---

### 81. Redis分布式锁如何实现？

```
┌─────────────────────────────────────────────────────────────────┐
│                   Redis 分布式锁实现                             │
├─────────────────────────────────────────────────────────────────┤
│                                                                  │
│  加锁：                                                         │
│  ┌─────────────────────────────────────────────────────────┐    │
│  │  SET lock_key $unique_value NX PX 30000                 │    │
│  │                                                         │    │
│  │  NX: 只在key不存在时设置                                │    │
│  │  PX 30000: 设置过期时间30秒（防止死锁）                 │    │
│  │  unique_value: 唯一标识（用于安全释放）                 │    │
│  └─────────────────────────────────────────────────────────┘    │
│                                                                  │
│  解锁（Lua脚本保证原子性）：                                    │
│  ┌─────────────────────────────────────────────────────────┐    │
│  │  if redis.call("get", KEYS[1]) == ARGV[1] then          │    │
│  │      return redis.call("del", KEYS[1])                  │    │
│  │  else                                                   │    │
│  │      return 0                                           │    │
│  │  end                                                    │    │
│  └─────────────────────────────────────────────────────────┘    │
│                                                                  │
└─────────────────────────────────────────────────────────────────┘

┌─────────────────────────────────────────────────────────────────┐
│                  Redis分布式锁问题                               │
├─────────────────────────────────────────────────────────────────┤
│                                                                  │
│  问题1：锁超时释放，业务未执行完                                │
│  ┌─────────────────────────────────────────────────────────┐    │
│  │  线程A获取锁 ───────────────────────────────────────────│    │
│  │       │                                                 │    │
│  │       │ 业务执行时间过长，超过锁过期时间                │    │
│  │       │                                                 │    │
│  │       ▼         锁自动释放                              │    │
│  │  ─────┼────────────[×]─────────────────────────────────│    │
│  │       │                                                 │    │
│  │       │              线程B获取到锁                      │    │
│  │       │              ────────────────────────────────── │    │
│  │       │                                                 │    │
│  │       ▼ A继续执行，但锁已不属于A                        │    │
│  │                                                         │    │
│  │  解决：看门狗机制自动续期                               │    │
│  └─────────────────────────────────────────────────────────┘    │
│                                                                  │
│  问题2：主从切换导致锁丢失                                      │
│  ┌─────────────────────────────────────────────────────────┐    │
│  │                                                         │    │
│  │  Master ────异步复制────> Slave                         │    │
│  │    │                        │                           │    │
│  │    │ 写入锁成功             │ 未收到复制                │    │
│  │    │                        │                           │    │
│  │    ▼ Master宕机             ▼ Slave升为Master           │    │
│  │                             │                           │    │
│  │                             │ 新Master无锁数据          │    │
│  │                             │ 其他客户端可获取锁        │    │
│  │                                                         │    │
│  │  解决：Redlock算法                                      │    │
│  └─────────────────────────────────────────────────────────┘    │
│                                                                  │
└─────────────────────────────────────────────────────────────────┘
```

---

### 82. Redlock算法的原理？

```
┌─────────────────────────────────────────────────────────────────┐
│                    Redlock 算法原理                              │
├─────────────────────────────────────────────────────────────────┤
│                                                                  │
│  前提：N个独立的Redis节点（通常N=5）                            │
│                                                                  │
│  ┌─────────┐  ┌─────────┐  ┌─────────┐  ┌─────────┐  ┌─────────┐│
│  │ Redis1  │  │ Redis2  │  │ Redis3  │  │ Redis4  │  │ Redis5  ││
│  │         │  │         │  │         │  │         │  │         ││
│  └─────────┘  └─────────┘  └─────────┘  └─────────┘  └─────────┘│
│       │            │            │            │            │     │
│       └────────────┴────────────┴────────────┴────────────┘     │
│                              │                                   │
│                           Client                                 │
│                                                                  │
└─────────────────────────────────────────────────────────────────┘

┌─────────────────────────────────────────────────────────────────┐
│                    加锁步骤                                      │
├─────────────────────────────────────────────────────────────────┤
│                                                                  │
│  1. 获取当前时间 T1                                             │
│                                                                  │
│  2. 依次向N个节点请求加锁                                       │
│     - 每个节点设置较短的超时时间（如5-50ms）                    │
│     - 避免某个节点宕机导致长时间等待                            │
│                                                                  │
│  3. 计算加锁消耗时间 = 当前时间 - T1                            │
│                                                                  │
│  4. 判断是否加锁成功：                                          │
│     - 在多数节点（N/2+1）上加锁成功                             │
│     - 加锁消耗时间 < 锁的过期时间                               │
│                                                                  │
│  5. 加锁成功：锁的实际有效时间 = 过期时间 - 加锁消耗时间        │
│                                                                  │
│  6. 加锁失败：向所有节点发送解锁请求                            │
│                                                                  │
└─────────────────────────────────────────────────────────────────┘

┌─────────────────────────────────────────────────────────────────┐
│                    Redlock 示例                                  │
├─────────────────────────────────────────────────────────────────┤
│                                                                  │
│  锁过期时间：10秒                                               │
│  加锁超时：50ms                                                 │
│                                                                  │
│  Client ─────────────────────────────────────────────────────   │
│     │                                                            │
│     │ T1 = 0ms                                                   │
│     │                                                            │
│     ├──> Redis1 ✓ (10ms)                                        │
│     ├──> Redis2 ✓ (15ms)                                        │
│     ├──> Redis3 ✗ (超时)                                        │
│     ├──> Redis4 ✓ (20ms)                                        │
│     └──> Redis5 ✓ (25ms)                                        │
│                                                                  │
│  总耗时：约100ms                                                │
│  成功节点：4个（> 5/2+1 = 3）                                   │
│  加锁成功！                                                      │
│  实际有效时间：10000ms - 100ms = 9900ms                         │
│                                                                  │
└─────────────────────────────────────────────────────────────────┘
```

**Redlock的争议：**
- Martin Kleppmann认为存在时钟跳跃问题
- Redis作者Antirez进行了回应
- 实际使用中需要权衡：对于强一致性要求使用ZK

---

### 83. ZooKeeper分布式锁的原理？

```
┌─────────────────────────────────────────────────────────────────┐
│                 ZooKeeper 分布式锁原理                           │
├─────────────────────────────────────────────────────────────────┤
│                                                                  │
│  利用临时顺序节点 + Watch机制实现                               │
│                                                                  │
│  /locks (持久节点)                                              │
│     │                                                            │
│     ├── lock-0000000001  (临时顺序节点 - Client A)              │
│     ├── lock-0000000002  (临时顺序节点 - Client B)              │
│     └── lock-0000000003  (临时顺序节点 - Client C)              │
│                                                                  │
│  规则：序号最小的节点持有锁                                     │
│                                                                  │
└─────────────────────────────────────────────────────────────────┘

┌─────────────────────────────────────────────────────────────────┐
│                     加锁流程                                     │
├─────────────────────────────────────────────────────────────────┤
│                                                                  │
│  Client A                ZooKeeper              Client B        │
│     │                        │                      │           │
│     │ 1.创建临时顺序节点     │                      │           │
│     │───────────────────────>│                      │           │
│     │  lock-0000000001       │                      │           │
│     │                        │                      │           │
│     │ 2.获取/locks下所有节点 │                      │           │
│     │───────────────────────>│                      │           │
│     │                        │                      │           │
│     │ 3.判断自己是最小节点   │                      │           │
│     │ 获取锁成功！           │                      │           │
│     │                        │                      │           │
│     │                        │   4.创建临时顺序节点 │           │
│     │                        │<─────────────────────│           │
│     │                        │   lock-0000000002    │           │
│     │                        │                      │           │
│     │                        │   5.获取所有节点     │           │
│     │                        │<─────────────────────│           │
│     │                        │                      │           │
│     │                        │   6.不是最小，Watch  │           │
│     │                        │   前一个节点         │           │
│     │                        │<─────────────────────│           │
│     │                        │   watch(lock-01)     │           │
│     │                        │                      │           │
│     │ 7.业务完成，删除节点   │                      │           │
│     │───────────────────────>│                      │           │
│     │                        │                      │           │
│     │                        │   8.收到Watch通知    │           │
│     │                        │──────────────────────>│           │
│     │                        │                      │           │
│     │                        │   9.检查是否最小    │           │
│     │                        │<─────────────────────│           │
│     │                        │                      │           │
│     │                        │   获取锁成功！       │           │
│                                                                  │
└─────────────────────────────────────────────────────────────────┘

┌─────────────────────────────────────────────────────────────────┐
│                    羊群效应避免                                  │
├─────────────────────────────────────────────────────────────────┤
│                                                                  │
│  错误方式（羊群效应）：                                         │
│  ┌─────────────────────────────────────────────────────────┐    │
│  │  所有客户端都Watch父节点变化                            │    │
│  │  一个锁释放，所有客户端都被唤醒                         │    │
│  │  造成大量无效唤醒和网络开销                             │    │
│  └─────────────────────────────────────────────────────────┘    │
│                                                                  │
│  正确方式：                                                      │
│  ┌─────────────────────────────────────────────────────────┐    │
│  │  每个客户端只Watch比自己小的前一个节点                  │    │
│  │  lock-0000000003 watches lock-0000000002                │    │
│  │  lock-0000000002 watches lock-0000000001                │    │
│  │  形成一条监听链                                         │    │
│  └─────────────────────────────────────────────────────────┘    │
│                                                                  │
└─────────────────────────────────────────────────────────────────┘
```

---

### 84. 分布式锁的续期问题如何解决？

```
┌─────────────────────────────────────────────────────────────────┐
│                     锁续期问题                                   │
├─────────────────────────────────────────────────────────────────┤
│                                                                  │
│  问题场景：                                                      │
│  ┌─────────────────────────────────────────────────────────┐    │
│  │                                                         │    │
│  │  获取锁(30s)      业务执行时间 > 30s      锁过期释放    │    │
│  │     │                    │                    │         │    │
│  │     ▼────────────────────┼────────────────────▼         │    │
│  │  Thread A               │                              │    │
│  │                          │                    ▼         │    │
│  │                          │              Thread B获取锁  │    │
│  │                          │                              │    │
│  │                          ▼                              │    │
│  │                     A继续执行但锁已失效                 │    │
│  │                     可能导致数据不一致                  │    │
│  │                                                         │    │
│  └─────────────────────────────────────────────────────────┘    │
│                                                                  │
└─────────────────────────────────────────────────────────────────┘

┌─────────────────────────────────────────────────────────────────┐
│                解决方案：看门狗机制 (Redisson)                   │
├─────────────────────────────────────────────────────────────────┤
│                                                                  │
│  ┌─────────────────────────────────────────────────────────┐    │
│  │                                                         │    │
│  │  获取锁(30s)                                            │    │
│  │     │                                                   │    │
│  │     ▼                                                   │    │
│  │  启动看门狗线程                                         │    │
│  │     │                                                   │    │
│  │     │  每10秒检查一次（过期时间的1/3）                  │    │
│  │     │                                                   │    │
│  │     ▼                                                   │    │
│  │  ┌──────────────────────────────────────────────────┐   │    │
│  │  │                                                  │   │    │
│  │  │  0s        10s       20s       30s       40s     │   │    │
│  │  │  │          │         │         │         │      │   │    │
│  │  │  ▼          ▼         ▼         ▼         ▼      │   │    │
│  │  │ 加锁      续期       续期      续期       释放    │   │    │
│  │  │ 30s      →30s       →30s      →30s               │   │    │
│  │  │                                                  │   │    │
│  │  │  业务执行中...                                   │   │    │
│  │  │                                                  │   │    │
│  │  └──────────────────────────────────────────────────┘   │    │
│  │                                                         │    │
│  │  业务完成后停止看门狗，释放锁                           │    │
│  │                                                         │    │
│  └─────────────────────────────────────────────────────────┘    │
│                                                                  │
│  实现要点：                                                      │
│  1. 后台线程定时续期                                            │
│  2. 续期间隔 = 过期时间 / 3                                     │
│  3. 业务完成或异常退出时停止续期                                │
│  4. 使用Lua脚本保证续期操作原子性                               │
│                                                                  │
└─────────────────────────────────────────────────────────────────┘
```

---

### 85. 如何实现可重入的分布式锁？

```
┌─────────────────────────────────────────────────────────────────┐
│                    可重入锁原理                                  │
├─────────────────────────────────────────────────────────────────┤
│                                                                  │
│  可重入：同一个线程可以多次获取同一把锁                         │
│                                                                  │
│  ┌─────────────────────────────────────────────────────────┐    │
│  │  public void methodA() {                                │    │
│  │      lock.lock();     // 第一次加锁，count=1            │    │
│  │      try {                                              │    │
│  │          methodB();   // 同线程再次加锁                 │    │
│  │      } finally {                                        │    │
│  │          lock.unlock(); // count-1=0，释放锁            │    │
│  │      }                                                  │    │
│  │  }                                                      │    │
│  │                                                         │    │
│  │  public void methodB() {                                │    │
│  │      lock.lock();     // 可重入，count=2                │    │
│  │      try {                                              │    │
│  │          // do something                                │    │
│  │      } finally {                                        │    │
│  │          lock.unlock(); // count-1=1                    │    │
│  │      }                                                  │    │
│  │  }                                                      │    │
│  └─────────────────────────────────────────────────────────┘    │
│                                                                  │
└─────────────────────────────────────────────────────────────────┘

┌─────────────────────────────────────────────────────────────────┐
│                Redis 可重入锁实现                                │
├─────────────────────────────────────────────────────────────────┤
│                                                                  │
│  数据结构：使用Hash存储锁信息                                   │
│                                                                  │
│  Key: lock_key                                                  │
│  Field: client_id (线程唯一标识)                                │
│  Value: count (重入次数)                                        │
│                                                                  │
│  加锁Lua脚本：                                                  │
│  ┌─────────────────────────────────────────────────────────┐    │
│  │  if redis.call('exists', KEYS[1]) == 0 then             │    │
│  │      -- 锁不存在，直接获取                               │    │
│  │      redis.call('hset', KEYS[1], ARGV[1], 1)            │    │
│  │      redis.call('pexpire', KEYS[1], ARGV[2])            │    │
│  │      return 1                                           │    │
│  │  end                                                    │    │
│  │                                                         │    │
│  │  if redis.call('hexists', KEYS[1], ARGV[1]) == 1 then   │    │
│  │      -- 同一客户端重入                                   │    │
│  │      redis.call('hincrby', KEYS[1], ARGV[1], 1)         │    │
│  │      redis.call('pexpire', KEYS[1], ARGV[2])            │    │
│  │      return 1                                           │    │
│  │  end                                                    │    │
│  │                                                         │    │
│  │  -- 其他客户端持有锁                                     │    │
│  │  return 0                                               │    │
│  └─────────────────────────────────────────────────────────┘    │
│                                                                  │
│  解锁Lua脚本：                                                  │
│  ┌─────────────────────────────────────────────────────────┐    │
│  │  if redis.call('hexists', KEYS[1], ARGV[1]) == 0 then   │    │
│  │      return -1  -- 不是锁持有者                          │    │
│  │  end                                                    │    │
│  │                                                         │    │
│  │  local count = redis.call('hincrby', KEYS[1], ARGV[1], -1)│   │
│  │  if count > 0 then                                      │    │
│  │      -- 重入次数减1后仍>0，只续期不释放                  │    │
│  │      redis.call('pexpire', KEYS[1], ARGV[2])            │    │
│  │      return 0                                           │    │
│  │  else                                                   │    │
│  │      -- 重入次数为0，释放锁                              │    │
│  │      redis.call('del', KEYS[1])                         │    │
│  │      return 1                                           │    │
│  │  end                                                    │    │
│  └─────────────────────────────────────────────────────────┘    │
│                                                                  │
└─────────────────────────────────────────────────────────────────┘
```

---

## 3.4 分布式ID（5题）

### 86. 分布式ID的生成方案有哪些？

```
┌─────────────────────────────────────────────────────────────────┐
│                    分布式ID生成方案                              │
├─────────────────────────────────────────────────────────────────┤
│                                                                  │
│  ┌─────────────────────────────────────────────────────────┐    │
│  │  1. UUID                                                │    │
│  │     格式: 550e8400-e29b-41d4-a716-446655440000          │    │
│  │     优点: 本地生成，性能高，无依赖                      │    │
│  │     缺点: 无序，不适合做主键，占用空间大(36字节)        │    │
│  └─────────────────────────────────────────────────────────┘    │
│                                                                  │
│  ┌─────────────────────────────────────────────────────────┐    │
│  │  2. 数据库自增                                          │    │
│  │     实现: AUTO_INCREMENT                                │    │
│  │     优点: 简单，有序                                    │    │
│  │     缺点: 单点瓶颈，性能有限                            │    │
│  │     改进: 号段模式，批量获取                            │    │
│  └─────────────────────────────────────────────────────────┘    │
│                                                                  │
│  ┌─────────────────────────────────────────────────────────┐    │
│  │  3. 数据库多主模式                                      │    │
│  │     节点1: 1, 3, 5, 7, 9 ...  (起始1，步长2)           │    │
│  │     节点2: 2, 4, 6, 8, 10 ... (起始2，步长2)           │    │
│  │     优点: 提高可用性                                    │    │
│  │     缺点: 扩展困难                                      │    │
│  └─────────────────────────────────────────────────────────┘    │
│                                                                  │
│  ┌─────────────────────────────────────────────────────────┐    │
│  │  4. Redis INCR                                          │    │
│  │     命令: INCR id_key                                   │    │
│  │     优点: 性能高，有序                                  │    │
│  │     缺点: 需要维护Redis，持久化问题                     │    │
│  └─────────────────────────────────────────────────────────┘    │
│                                                                  │
│  ┌─────────────────────────────────────────────────────────┐    │
│  │  5. 雪花算法 (Snowflake)                                │    │
│  │     结构: 时间戳 + 机器ID + 序列号                      │    │
│  │     优点: 有序，高性能，趋势递增                        │    │
│  │     缺点: 依赖时钟，时钟回拨问题                        │    │
│  └─────────────────────────────────────────────────────────┘    │
│                                                                  │
│  ┌─────────────────────────────────────────────────────────┐    │
│  │  6. 号段模式 (Leaf-Segment)                             │    │
│  │     原理: 从数据库批量获取一段ID                        │    │
│  │     优点: 减少数据库压力                                │    │
│  │     缺点: 存在号段浪费                                  │    │
│  └─────────────────────────────────────────────────────────┘    │
│                                                                  │
└─────────────────────────────────────────────────────────────────┘

┌─────────────────────────────────────────────────────────────────┐
│                      方案对比                                    │
├───────────┬────────┬────────┬────────┬──────────────────────────┤
│   方案    │  有序  │  性能  │ 可用性 │       适用场景           │
├───────────┼────────┼────────┼────────┼──────────────────────────┤
│   UUID    │   ✗    │   高   │   高   │ 非主键场景               │
├───────────┼────────┼────────┼────────┼──────────────────────────┤
│ DB自增    │   ✓    │   低   │   低   │ 并发量小                 │
├───────────┼────────┼────────┼────────┼──────────────────────────┤
│  Redis    │   ✓    │   高   │   中   │ 已有Redis基础设施        │
├───────────┼────────┼────────┼────────┼──────────────────────────┤
│ Snowflake │   ✓    │   高   │   高   │ 高并发场景（主流）       │
├───────────┼────────┼────────┼────────┼──────────────────────────┤
│  号段模式 │   ✓    │   高   │   高   │ 对连续性要求不高         │
└───────────┴────────┴────────┴────────┴──────────────────────────┘
```

---

### 87. 雪花算法的原理和问题？

```
┌─────────────────────────────────────────────────────────────────┐
│                  雪花算法 (Snowflake) 结构                       │
├─────────────────────────────────────────────────────────────────┤
│                                                                  │
│  64位ID = 1bit符号位 + 41bit时间戳 + 10bit机器ID + 12bit序列号  │
│                                                                  │
│  ┌───┬─────────────────────────────────────┬─────────┬────────┐ │
│  │ 0 │          41bit 时间戳               │ 10bit   │ 12bit  │ │
│  │   │       (毫秒级，约69年)              │ 机器ID  │ 序列号 │ │
│  └───┴─────────────────────────────────────┴─────────┴────────┘ │
│                                                                  │
│  符号位：固定为0，表示正数                                      │
│                                                                  │
│  时间戳：41位，2^41 / (1000*60*60*24*365) ≈ 69年               │
│          相对于起始时间的毫秒数差值                             │
│                                                                  │
│  机器ID：10位 = 5位数据中心ID + 5位工作机器ID                   │
│          支持 2^10 = 1024 个节点                                │
│                                                                  │
│  序列号：12位，同一毫秒内的自增序号                             │
│          支持 2^12 = 4096 个ID/毫秒/节点                        │
│                                                                  │
│  理论QPS：1024 * 4096 * 1000 = 约40亿/秒                        │
│                                                                  │
└─────────────────────────────────────────────────────────────────┘

┌─────────────────────────────────────────────────────────────────┐
│                    雪花算法的问题                                │
├─────────────────────────────────────────────────────────────────┤
│                                                                  │
│  问题1：时钟回拨                                                │
│  ┌─────────────────────────────────────────────────────────┐    │
│  │  场景：服务器时间回调（NTP同步、手动调整）              │    │
│  │  后果：生成重复ID或程序异常                             │    │
│  │                                                         │    │
│  │  时间线：                                               │    │
│  │  ──────────────────────────────────────────────────────  │    │
│  │  08:00:00.100  生成ID: xxx100                           │    │
│  │  08:00:00.099  时钟回拨！可能生成重复ID                 │    │
│  │  ──────────────────────────────────────────────────────  │    │
│  └─────────────────────────────────────────────────────────┘    │
│                                                                  │
│  问题2：机器ID分配                                              │
│  ┌─────────────────────────────────────────────────────────┐    │
│  │  - 需要保证机器ID全局唯一                               │    │
│  │  - 手动配置容易出错                                     │    │
│  │  - 容器化环境下IP不固定                                 │    │
│  └─────────────────────────────────────────────────────────┘    │
│                                                                  │
│  问题3：ID不连续                                                │
│  ┌─────────────────────────────────────────────────────────┐    │
│  │  - 不同机器生成的ID不连续                               │    │
│  │  - 不适合需要严格连续ID的场景                           │    │
│  └─────────────────────────────────────────────────────────┘    │
│                                                                  │
└─────────────────────────────────────────────────────────────────┘
```

---

### 88. 时钟回拨问题如何解决？

```
┌─────────────────────────────────────────────────────────────────┐
│                  时钟回拨解决方案                                │
├─────────────────────────────────────────────────────────────────┤
│                                                                  │
│  方案1：抛出异常，拒绝生成                                      │
│  ┌─────────────────────────────────────────────────────────┐    │
│  │  if (currentTimestamp < lastTimestamp) {                │    │
│  │      throw new RuntimeException("时钟回拨，拒绝生成ID"); │    │
│  │  }                                                      │    │
│  │                                                         │    │
│  │  优点：简单直接                                         │    │
│  │  缺点：服务不可用                                       │    │
│  └─────────────────────────────────────────────────────────┘    │
│                                                                  │
│  方案2：等待时钟追上                                            │
│  ┌─────────────────────────────────────────────────────────┐    │
│  │  while (currentTimestamp < lastTimestamp) {             │    │
│  │      // 等待时钟追上                                    │    │
│  │      currentTimestamp = System.currentTimeMillis();     │    │
│  │  }                                                      │    │
│  │                                                         │    │
│  │  优点：可以自动恢复                                     │    │
│  │  缺点：大幅回拨时等待时间长                             │    │
│  └─────────────────────────────────────────────────────────┘    │
│                                                                  │
│  方案3：使用扩展位                                              │
│  ┌─────────────────────────────────────────────────────────┐    │
│  │  从机器ID中借位作为时钟序列                             │    │
│  │  每次时钟回拨，时钟序列+1                               │    │
│  │                                                         │    │
│  │  ┌───┬──────────────┬───────┬───────┬────────┐         │    │
│  │  │ 0 │   41bit时间  │ 2bit  │ 8bit  │ 12bit  │         │    │
│  │  │   │              │时钟序列│机器ID │ 序列号 │         │    │
│  │  └───┴──────────────┴───────┴───────┴────────┘         │    │
│  │                                                         │    │
│  │  优点：可容忍一定次数的回拨                             │    │
│  │  缺点：减少了机器ID位数                                 │    │
│  └─────────────────────────────────────────────────────────┘    │
│                                                                  │
│  方案4：基于历史最大时间戳（美团Leaf）                          │
│  ┌─────────────────────────────────────────────────────────┐    │
│  │  1. 启动时从ZK获取上次最大时间戳                        │    │
│  │  2. 如果当前时间 < 历史最大时间，等待或报警             │    │
│  │  3. 运行时定期上报当前时间到ZK                          │    │
│  │                                                         │    │
│  │  优点：可靠性高                                         │    │
│  │  缺点：依赖ZK                                           │    │
│  └─────────────────────────────────────────────────────────┘    │
│                                                                  │
└─────────────────────────────────────────────────────────────────┘
```

---

### 89. Leaf方案的原理？

```
┌─────────────────────────────────────────────────────────────────┐
│                 Leaf-Segment 号段模式                            │
├─────────────────────────────────────────────────────────────────┤
│                                                                  │
│  数据库表设计：                                                  │
│  ┌─────────────────────────────────────────────────────────┐    │
│  │  CREATE TABLE leaf_alloc (                              │    │
│  │    biz_tag VARCHAR(128) PRIMARY KEY,  -- 业务标识       │    │
│  │    max_id BIGINT,                     -- 当前最大ID     │    │
│  │    step INT,                          -- 步长           │    │
│  │    description VARCHAR(256),                            │    │
│  │    update_time TIMESTAMP                                │    │
│  │  );                                                     │    │
│  │                                                         │    │
│  │  示例数据：                                             │    │
│  │  | biz_tag | max_id | step |                            │    │
│  │  | order   | 2000   | 1000 |                            │    │
│  │  | user    | 5000   | 1000 |                            │    │
│  └─────────────────────────────────────────────────────────┘    │
│                                                                  │
│  获取号段流程：                                                  │
│  ┌─────────────────────────────────────────────────────────┐    │
│  │                                                         │    │
│  │  UPDATE leaf_alloc                                      │    │
│  │  SET max_id = max_id + step                             │    │
│  │  WHERE biz_tag = 'order';                               │    │
│  │                                                         │    │
│  │  SELECT max_id, step FROM leaf_alloc                    │    │
│  │  WHERE biz_tag = 'order';                               │    │
│  │                                                         │    │
│  │  获取到号段：[1001, 2000]                               │    │
│  │                                                         │    │
│  └─────────────────────────────────────────────────────────┘    │
│                                                                  │
└─────────────────────────────────────────────────────────────────┘

┌─────────────────────────────────────────────────────────────────┐
│                  双Buffer优化                                    │
├─────────────────────────────────────────────────────────────────┤
│                                                                  │
│  问题：号段用完时需要访问DB，会造成短暂阻塞                      │
│                                                                  │
│  解决：双Buffer异步预加载                                       │
│                                                                  │
│  ┌─────────────────────────────────────────────────────────┐    │
│  │                                                         │    │
│  │   Buffer 1 (当前使用)        Buffer 2 (预加载)         │    │
│  │  ┌─────────────────┐       ┌─────────────────┐          │    │
│  │  │ [1001 - 2000]   │       │     空          │          │    │
│  │  │ 当前: 1500      │       │                 │          │    │
│  │  └─────────────────┘       └─────────────────┘          │    │
│  │         │                                               │    │
│  │         │ 使用率达到10%时                               │    │
│  │         ▼ 异步加载Buffer2                               │    │
│  │  ┌─────────────────┐       ┌─────────────────┐          │    │
│  │  │ [1001 - 2000]   │       │ [2001 - 3000]   │          │    │
│  │  │ 当前: 1900      │       │ 预加载完成      │          │    │
│  │  └─────────────────┘       └─────────────────┘          │    │
│  │         │                                               │    │
│  │         │ Buffer1用完                                   │    │
│  │         ▼ 切换到Buffer2                                 │    │
│  │  ┌─────────────────┐       ┌─────────────────┐          │    │
│  │  │ [3001 - 4000]   │       │ [2001 - 3000]   │          │    │
│  │  │ 预加载中        │ <──── │ 当前使用        │          │    │
│  │  └─────────────────┘       └─────────────────┘          │    │
│  │                                                         │    │
│  └─────────────────────────────────────────────────────────┘    │
│                                                                  │
│  优点：                                                          │
│  - 减少DB访问频率                                               │
│  - 无阻塞切换                                                   │
│  - 提高可用性                                                   │
│                                                                  │
└─────────────────────────────────────────────────────────────────┘
```

---

### 90. 美团的Leaf-Snowflake方案？

```
┌─────────────────────────────────────────────────────────────────┐
│              Leaf-Snowflake 架构                                 │
├─────────────────────────────────────────────────────────────────┤
│                                                                  │
│                    ┌─────────────┐                              │
│                    │  ZooKeeper  │                              │
│                    │  /leaf/     │                              │
│                    │   forever/  │                              │
│                    └──────┬──────┘                              │
│                           │                                      │
│            ┌──────────────┼──────────────┐                      │
│            │              │              │                      │
│            ▼              ▼              ▼                      │
│     ┌────────────┐ ┌────────────┐ ┌────────────┐               │
│     │ Leaf Node  │ │ Leaf Node  │ │ Leaf Node  │               │
│     │ workerId=1 │ │ workerId=2 │ │ workerId=3 │               │
│     │            │ │            │ │            │               │
│     │ IP:Port    │ │ IP:Port    │ │ IP:Port    │               │
│     └────────────┘ └────────────┘ └────────────┘               │
│                                                                  │
│  ZK节点结构：                                                   │
│  /leaf/forever/                                                 │
│      ├── 192.168.1.1:8080-0000000001  (workerId=1)             │
│      ├── 192.168.1.2:8080-0000000002  (workerId=2)             │
│      └── 192.168.1.3:8080-0000000003  (workerId=3)             │
│                                                                  │
└─────────────────────────────────────────────────────────────────┘

┌─────────────────────────────────────────────────────────────────┐
│                  启动流程                                        │
├─────────────────────────────────────────────────────────────────┤
│                                                                  │
│  1. 检查ZK中是否有该节点的注册信息                              │
│     ┌─────────────────────────────────────────────────────┐     │
│     │  path = /leaf/forever/{ip:port}                     │     │
│     │  if exists(path):                                   │     │
│     │      workerId = getData(path)                       │     │
│     │  else:                                              │     │
│     │      workerId = createSequential()                  │     │
│     └─────────────────────────────────────────────────────┘     │
│                                                                  │
│  2. 时钟回拨检测                                                │
│     ┌─────────────────────────────────────────────────────┐     │
│     │  lastTimestamp = getFromZK()                        │     │
│     │  currentTimestamp = System.currentTimeMillis()      │     │
│     │                                                     │     │
│     │  if currentTimestamp < lastTimestamp:               │     │
│     │      if diff < 5ms:                                 │     │
│     │          wait(diff)  // 等待追上                    │     │
│     │      else:                                          │     │
│     │          启动失败，报警                             │     │
│     └─────────────────────────────────────────────────────┘     │
│                                                                  │
│  3. 定期上报时间戳                                              │
│     ┌─────────────────────────────────────────────────────┐     │
│     │  每3秒上报当前时间戳到ZK                            │     │
│     │  用于重启时的时钟回拨检测                           │     │
│     └─────────────────────────────────────────────────────┘     │
│                                                                  │
└─────────────────────────────────────────────────────────────────┘

┌─────────────────────────────────────────────────────────────────┐
│                  弱依赖ZK                                        │
├─────────────────────────────────────────────────────────────────┤
│                                                                  │
│  即使ZK不可用，Leaf节点仍可正常工作：                           │
│                                                                  │
│  ┌─────────────────────────────────────────────────────────┐    │
│  │  1. workerId在启动时已获取并缓存到本地                  │    │
│  │  2. 时间戳定期上报失败不影响ID生成                      │    │
│  │  3. ZK恢复后自动重新建立连接                            │    │
│  │                                                         │    │
│  │  注意：ZK长时间不可用时重启节点可能有问题               │    │
│  └─────────────────────────────────────────────────────────┘    │
│                                                                  │
└─────────────────────────────────────────────────────────────────┘
```

---

## 3.5 分布式服务（5题）

### 91. 服务注册与发现的原理？（续）

```
┌─────────────────────────────────────────────────────────────────┐
│                  服务注册与发现架构                              │
├─────────────────────────────────────────────────────────────────┤
│                                                                  │
│        ┌────────────────────────────────────────┐               │
│        │           注册中心                      │               │
│        │    (Eureka/Nacos/Consul/ZK)            │               │
│        │                                        │               │
│        │  服务列表:                             │               │
│        │  ┌──────────────────────────────────┐  │               │
│        │  │ service-a: [ip1:8080, ip2:8080]  │  │               │
│        │  │ service-b: [ip3:8081, ip4:8081]  │  │               │
│        │  └──────────────────────────────────┘  │               │
│        └─────────────┬───────────┬──────────────┘               │
│              ▲       │           │       ▲                      │
│              │       │           │       │                      │
│   1.注册     │       │           │       │  3.订阅              │
│              │       │           │       │                      │
│   ┌──────────┴──┐    │    2.心跳 │    ┌──┴──────────┐          │
│   │             │    │           │    │             │          │
│   │ Service A   │    │           │    │ Service B   │          │
│   │ Provider    │<───┘           └───>│ Consumer    │          │
│   │ ip1:8080    │      4.服务调用     │ ip3:8081    │          │
│   │ ip2:8080    │<────────────────────│             │          │
│   └─────────────┘                     └─────────────┘          │
│                                                                  │
└─────────────────────────────────────────────────────────────────┘

┌─────────────────────────────────────────────────────────────────┐
│                      核心流程                                    │
├─────────────────────────────────────────────────────────────────┤
│                                                                  │
│  1. 服务注册 (Register)                                         │
│     ┌─────────────────────────────────────────────────────┐     │
│     │  服务启动时向注册中心注册                           │     │
│     │  注册信息：服务名、IP、端口、健康检查URL、元数据    │     │
│     └─────────────────────────────────────────────────────┘     │
│                                                                  │
│  2. 心跳续约 (Heartbeat)                                        │
│     ┌─────────────────────────────────────────────────────┐     │
│     │  定期发送心跳（默认30秒）                           │     │
│     │  注册中心更新最后活跃时间                           │     │
│     │  超时未收到心跳（默认90秒）则剔除服务               │     │
│     └─────────────────────────────────────────────────────┘     │
│                                                                  │
│  3. 服务发现 (Discovery)                                        │
│     ┌─────────────────────────────────────────────────────┐     │
│     │  方式一：Pull 定期拉取（Eureka默认30秒）            │     │
│     │  方式二：Push 订阅推送（Nacos支持）                 │     │
│     │  消费者本地缓存服务列表                             │     │
│     └─────────────────────────────────────────────────────┘     │
│                                                                  │
│  4. 服务下线 (Deregister)                                       │
│     ┌─────────────────────────────────────────────────────┐     │
│     │  主动下线：服务停止时通知注册中心                   │     │
│     │  被动剔除：心跳超时后注册中心主动剔除               │     │
│     └─────────────────────────────────────────────────────┘     │
│                                                                  │
└─────────────────────────────────────────────────────────────────┘

┌─────────────────────────────────────────────────────────────────┐
│                   注册中心对比                                   │
├──────────┬─────────┬─────────┬─────────┬────────────────────────┤
│   组件   │   CAP   │  协议   │ 健康检查│       特点             │
├──────────┼─────────┼─────────┼─────────┼────────────────────────┤
│ Eureka   │   AP    │  HTTP   │ 心跳    │ 自我保护机制           │
├──────────┼─────────┼─────────┼─────────┼────────────────────────┤
│ Nacos    │ AP/CP   │  HTTP   │ 心跳/TCP│ 支持配置中心           │
├──────────┼─────────┼─────────┼─────────┼────────────────────────┤
│ Consul   │   CP    │  HTTP   │ 多种    │ 多数据中心             │
├──────────┼─────────┼─────────┼─────────┼────────────────────────┤
│ ZK       │   CP    │   TCP   │ Session │ 强一致性               │
└──────────┴─────────┴─────────┴─────────┴────────────────────────┘
```

---

### 92. 负载均衡算法有哪些？

```
┌─────────────────────────────────────────────────────────────────┐
│                    负载均衡算法分类                              │
├─────────────────────────────────────────────────────────────────┤
│                                                                  │
│  ┌─────────────────────────────────────────────────────────┐    │
│  │  1. 轮询 (Round Robin)                                  │    │
│  │                                                         │    │
│  │  请求1 ──> Server A                                     │    │
│  │  请求2 ──> Server B                                     │    │
│  │  请求3 ──> Server C                                     │    │
│  │  请求4 ──> Server A  (循环)                             │    │
│  │                                                         │    │
│  │  优点：简单、均匀                                       │    │
│  │  缺点：不考虑服务器性能差异                             │    │
│  └─────────────────────────────────────────────────────────┘    │
│                                                                  │
│  ┌─────────────────────────────────────────────────────────┐    │
│  │  2. 加权轮询 (Weighted Round Robin)                     │    │
│  │                                                         │    │
│  │  Server A (权重3): ■■■                                  │    │
│  │  Server B (权重2): ■■                                   │    │
│  │  Server C (权重1): ■                                    │    │
│  │                                                         │    │
│  │  请求分配：A, A, A, B, B, C, A, A, A...                 │    │
│  │                                                         │    │
│  │  优点：可根据服务器性能分配                             │    │
│  └─────────────────────────────────────────────────────────┘    │
│                                                                  │
│  ┌─────────────────────────────────────────────────────────┐    │
│  │  3. 随机 (Random)                                       │    │
│  │                                                         │    │
│  │  随机选择一台服务器                                     │    │
│  │                                                         │    │
│  │  优点：简单，大数定律下趋于均匀                         │    │
│  │  缺点：短期可能不均匀                                   │    │
│  └─────────────────────────────────────────────────────────┘    │
│                                                                  │
│  ┌─────────────────────────────────────────────────────────┐    │
│  │  4. 加权随机 (Weighted Random)                          │    │
│  │                                                         │    │
│  │  根据权重随机选择，权重高的被选中概率大                 │    │
│  └─────────────────────────────────────────────────────────┘    │
│                                                                  │
│  ┌─────────────────────────────────────────────────────────┐    │
│  │  5. 最少连接 (Least Connections)                        │    │
│  │                                                         │    │
│  │  Server A: 当前连接数 10                                │    │
│  │  Server B: 当前连接数 5  ◄── 选择这个                   │    │
│  │  Server C: 当前连接数 8                                 │    │
│  │                                                         │    │
│  │  优点：动态均衡，适合长连接场景                         │    │
│  └─────────────────────────────────────────────────────────┘    │
│                                                                  │
│  ┌─────────────────────────────────────────────────────────┐    │
│  │  6. 一致性哈希 (Consistent Hash)                        │    │
│  │                                                         │    │
│  │         0°                                              │    │
│  │          │    ┌─ Server A                               │    │
│  │          │   /                                          │    │
│  │      ────┼────     相同key总是路由到同一服务器          │    │
│  │         / \        节点变化时只影响相邻节点             │    │
│  │        /   \                                            │    │
│  │    Server C  Server B                                   │    │
│  │                                                         │    │
│  │  优点：适合缓存场景，减少缓存失效                       │    │
│  └─────────────────────────────────────────────────────────┘    │
│                                                                  │
│  ┌─────────────────────────────────────────────────────────┐    │
│  │  7. IP/URL哈希                                          │    │
│  │                                                         │    │
│  │  hash(clientIP) % serverCount = serverIndex             │    │
│  │                                                         │    │
│  │  优点：同一客户端总是访问同一服务器（会话保持）         │    │
│  └─────────────────────────────────────────────────────────┘    │
│                                                                  │
└─────────────────────────────────────────────────────────────────┘

┌─────────────────────────────────────────────────────────────────┐
│                      算法选择建议                                │
├─────────────────────────────────────────────────────────────────┤
│                                                                  │
│  场景                          推荐算法                         │
│  ──────────────────────────────────────────────────────────     │
│  服务器性能相同                轮询/随机                        │
│  服务器性能不同                加权轮询/加权随机                │
│  长连接场景                    最少连接                         │
│  需要会话保持                  IP哈希/一致性哈希                │
│  缓存场景                      一致性哈希                       │
│                                                                  │
└─────────────────────────────────────────────────────────────────┘
```

---

### 93. 服务熔断的原理？

```
┌─────────────────────────────────────────────────────────────────┐
│                    服务熔断状态机                                │
├─────────────────────────────────────────────────────────────────┤
│                                                                  │
│                     失败率超过阈值                               │
│              ┌─────────────────────────────┐                    │
│              │                             │                    │
│              ▼                             │                    │
│        ┌──────────┐                  ┌──────────┐               │
│        │          │                  │          │               │
│        │  CLOSED  │                  │   OPEN   │               │
│        │  (关闭)  │                  │  (打开)  │               │
│        │          │                  │          │               │
│        │ 正常调用 │                  │ 快速失败 │               │
│        │          │                  │          │               │
│        └────┬─────┘                  └────┬─────┘               │
│             │                             │                     │
│             │        ┌──────────┐         │                     │
│             │        │          │         │                     │
│             │        │HALF-OPEN │         │ 超时后              │
│             └───────>│ (半开)   │<────────┘                     │
│               探测   │          │                               │
│               成功   │ 尝试请求 │                               │
│                      │          │                               │
│                      └────┬─────┘                               │
│                           │                                     │
│                     探测失败，重新打开                          │
│                           │                                     │
│                           ▼                                     │
│                      返回OPEN状态                               │
│                                                                  │
└─────────────────────────────────────────────────────────────────┘

┌─────────────────────────────────────────────────────────────────┐
│                    熔断工作流程                                  │
├─────────────────────────────────────────────────────────────────┤
│                                                                  │
│  时间线：                                                       │
│  ═══════════════════════════════════════════════════════════    │
│                                                                  │
│  CLOSED状态（正常）                                             │
│  ┌─────────────────────────────────────────────────────────┐    │
│  │  请求1 ✓  请求2 ✗  请求3 ✓  请求4 ✗  请求5 ✗           │    │
│  │                                                         │    │
│  │  统计窗口内失败率：60% > 阈值50%                        │    │
│  │  触发熔断！                                             │    │
│  └─────────────────────────────────────────────────────────┘    │
│                          │                                       │
│                          ▼                                       │
│  OPEN状态（熔断中）     超时时间：10秒                          │
│  ┌─────────────────────────────────────────────────────────┐    │
│  │  请求6 ⚡ 快速失败（不调用下游）                        │    │
│  │  请求7 ⚡ 快速失败                                      │    │
│  │  请求8 ⚡ 快速失败                                      │    │
│  │  ...                                                    │    │
│  │  等待10秒后进入半开状态                                 │    │
│  └─────────────────────────────────────────────────────────┘    │
│                          │                                       │
│                          ▼                                       │
│  HALF-OPEN状态（探测）                                          │
│  ┌─────────────────────────────────────────────────────────┐    │
│  │  放行少量请求进行探测                                   │    │
│  │                                                         │    │
│  │  情况1：探测成功 ──> 恢复到CLOSED状态                   │    │
│  │  情况2：探测失败 ──> 返回OPEN状态，继续等待             │    │
│  └─────────────────────────────────────────────────────────┘    │
│                                                                  │
└─────────────────────────────────────────────────────────────────┘

┌─────────────────────────────────────────────────────────────────┐
│                    熔断器配置参数                                │
├─────────────────────────────────────────────────────────────────┤
│                                                                  │
│  参数                    说明                    典型值          │
│  ───────────────────────────────────────────────────────────    │
│  failureRateThreshold    失败率阈值              50%            │
│  slowCallRateThreshold   慢调用率阈值            100%           │
│  slowCallDuration        慢调用时间定义          60s            │
│  slidingWindowSize       统计窗口大小            100次          │
│  minimumNumberOfCalls    最小调用次数            10次           │
│  waitDurationInOpenState 熔断等待时间            60s            │
│  permittedNumberInHalf   半开放行请求数          10次           │
│                                                                  │
└─────────────────────────────────────────────────────────────────┘
```

**熔断器框架：**
- Hystrix（Netflix，已停止维护）
- Resilience4j（推荐）
- Sentinel（阿里巴巴）

---

### 94. 服务限流的算法有哪些？

```
┌─────────────────────────────────────────────────────────────────┐
│                 1. 固定窗口计数器                                │
├─────────────────────────────────────────────────────────────────┤
│                                                                  │
│    窗口1 (00:00-00:01)       窗口2 (00:01-00:02)                │
│   ┌─────────────────────┐   ┌─────────────────────┐             │
│   │ ■■■■■■■■■■          │   │ ■■■                 │             │
│   │ count: 10           │   │ count: 3            │             │
│   │ limit: 10           │   │ limit: 10           │             │
│   └─────────────────────┘   └─────────────────────┘             │
│                                                                  │
│   问题：临界问题                                                │
│   ┌─────────────────────┬─────────────────────┐                 │
│   │          ■■■■■■■■■■ │ ■■■■■■■■■■          │                 │
│   │      00:00:59 10个  │ 00:01:01 10个       │                 │
│   └─────────────────────┴─────────────────────┘                 │
│           │<─────1秒内20个请求，超过限制─────>│                 │
│                                                                  │
└─────────────────────────────────────────────────────────────────┘

┌─────────────────────────────────────────────────────────────────┐
│                 2. 滑动窗口计数器                                │
├─────────────────────────────────────────────────────────────────┤
│                                                                  │
│   将窗口划分为多个小格子，窗口滑动                              │
│                                                                  │
│   时间 ─────────────────────────────────────────>               │
│                                                                  │
│   ┌────┬────┬────┬────┬────┬────┐                               │
│   │ 2  │ 3  │ 1  │ 4  │ 2  │ 3  │  = 15 (限制10则拒绝)         │
│   └────┴────┴────┴────┴────┴────┘                               │
│   │<───────── 1分钟窗口 ─────────>│                             │
│                                                                  │
│        ┌────┬────┬────┬────┬────┬────┐                          │
│        │ 3  │ 1  │ 4  │ 2  │ 3  │ 1  │  窗口滑动                │
│        └────┴────┴────┴────┴────┴────┘                          │
│        │<───────── 1分钟窗口 ─────────>│                        │
│                                                                  │
│   优点：解决临界问题                                            │
│   缺点：统计精度取决于格子数量                                  │
│                                                                  │
└─────────────────────────────────────────────────────────────────┘

┌─────────────────────────────────────────────────────────────────┐
│                   3. 漏桶算法                                    │
├─────────────────────────────────────────────────────────────────┤
│                                                                  │
│         请求流入（不规则）                                      │
│              │ │││  │ │                                         │
│              ▼ ▼▼▼  ▼ ▼                                         │
│        ┌─────────────────┐                                      │
│        │    ████████     │ ← 桶（缓冲区）                       │
│        │    ████████     │   容量固定                           │
│        │    ████████     │   溢出则拒绝                         │
│        └────────┬────────┘                                      │
│                 │                                                │
│                 ▼ 恒定速率流出                                   │
│              │  │  │  │                                         │
│              ▼  ▼  ▼  ▼                                         │
│             处理请求                                             │
│                                                                  │
│   优点：流量整形，输出平滑                                      │
│   缺点：无法应对突发流量                                        │
│                                                                  │
└─────────────────────────────────────────────────────────────────┘

┌─────────────────────────────────────────────────────────────────┐
│                   4. 令牌桶算法                                  │
├─────────────────────────────────────────────────────────────────┤
│                                                                  │
│         恒定速率放入令牌                                        │
│              │  │  │  │                                         │
│              ▼  ▼  ▼  ▼                                         │
│        ┌─────────────────┐                                      │
│        │    ○○○○○○○○     │ ← 令牌桶                            │
│        │    ○○○○○○○○     │   容量固定                          │
│        │    ○○○○○        │   满了则丢弃令牌                    │
│        └────────┬────────┘                                      │
│                 │                                                │
│       请求获取令牌                                               │
│              │ │││  │ │                                         │
│              ▼ ▼▼▼  ▼ ▼                                         │
│                 │                                                │
│       有令牌：处理请求，消耗令牌                                │
│       无令牌：拒绝或等待                                        │
│                                                                  │
│   优点：允许一定程度的突发流量                                  │
│   缺点：实现相对复杂                                            │
│                                                                  │
└─────────────────────────────────────────────────────────────────┘

┌─────────────────────────────────────────────────────────────────┐
│                      算法对比                                    │
├────────────┬──────────┬──────────┬───────────────────────────────┤
│    算法    │ 突发流量 │  精确度  │          适用场景            │
├────────────┼──────────┼──────────┼───────────────────────────────┤
│ 固定窗口   │   差     │   低     │ 简单场景                     │
├────────────┼──────────┼──────────┼───────────────────────────────┤
│ 滑动窗口   │   中     │   中     │ 需要较精确统计               │
├────────────┼──────────┼──────────┼───────────────────────────────┤
│ 漏桶       │   差     │   高     │ 需要平滑流量                 │
├────────────┼──────────┼──────────┼───────────────────────────────┤
│ 令牌桶     │   好     │   高     │ 允许突发的场景（最常用）     │
└────────────┴──────────┴──────────┴───────────────────────────────┘
```

---

### 95. 服务降级的策略有哪些？

```
┌─────────────────────────────────────────────────────────────────┐
│                    服务降级策略                                  │
├─────────────────────────────────────────────────────────────────┤
│                                                                  │
│  ┌─────────────────────────────────────────────────────────┐    │
│  │  1. 返回默认值/兜底数据                                 │    │
│  │                                                         │    │
│  │  场景：推荐服务不可用                                   │    │
│  │  降级：返回热门商品列表（预先缓存）                     │    │
│  │                                                         │    │
│  │  ┌─────────────────────────────────────────────────┐    │    │
│  │  │  public List<Product> getRecommend(User user) { │    │    │
│  │  │      try {                                      │    │    │
│  │  │          return recommendService.get(user);     │    │    │
│  │  │      } catch (Exception e) {                    │    │    │
│  │  │          return getHotProducts(); // 降级      │    │    │
│  │  │      }                                          │    │    │
│  │  │  }                                              │    │    │
│  │  └─────────────────────────────────────────────────┘    │    │
│  └─────────────────────────────────────────────────────────┘    │
│                                                                  │
│  ┌─────────────────────────────────────────────────────────┐    │
│  │  2. 返回缓存数据                                        │    │
│  │                                                         │    │
│  │  场景：商品详情服务不可用                               │    │
│  │  降级：返回Redis/本地缓存中的旧数据                     │    │
│  │                                                         │    │
│  │  正常：DB/远程服务 → 更新缓存 → 返回                   │    │
│  │  降级：直接返回缓存（可能是旧数据）                     │    │
│  └─────────────────────────────────────────────────────────┘    │
│                                                                  │
│  ┌─────────────────────────────────────────────────────────┐    │
│  │  3. 功能降级                                            │    │
│  │                                                         │    │
│  │  场景：系统压力过大                                     │    │
│  │  降级：关闭非核心功能                                   │    │
│  │                                                         │    │
│  │  ┌─────────────────────────────────────────────────┐    │    │
│  │  │  核心功能：下单、支付、查订单    → 保留         │    │    │
│  │  │  非核心：评论、推荐、积分        → 关闭/简化    │    │    │
│  │  └─────────────────────────────────────────────────┘    │    │
│  └─────────────────────────────────────────────────────────┘    │
│                                                                  │
│  ┌─────────────────────────────────────────────────────────┐    │
│  │  4. 读写降级                                            │    │
│  │                                                         │    │
│  │  场景：数据库压力过大                                   │    │
│  │  降级：只读不写 或 写入队列异步处理                     │    │
│  │                                                         │    │
│  │  ┌─────────────────────────────────────────────────┐    │    │
│  │  │  正常：同步写数据库                             │    │    │
│  │  │  降级：写入消息队列，异步批量写入               │    │    │
│  │  └─────────────────────────────────────────────────┘    │    │
│  └─────────────────────────────────────────────────────────┘    │
│                                                                  │
│  ┌─────────────────────────────────────────────────────────┐    │
│  │  5. 接口降级                                            │    │
│  │                                                         │    │
│  │  场景：某个接口响应慢影响整体                           │    │
│  │  降级：直接返回错误或空，不调用下游                     │    │
│  │                                                         │    │
│  │  配合熔断器使用，快速失败                               │    │
│  └─────────────────────────────────────────────────────────┘    │
│                                                                  │
│  ┌─────────────────────────────────────────────────────────┐    │
│  │  6. 延迟降级                                            │    │
│  │                                                         │    │
│  │  场景：实时性要求高的数据                               │    │
│  │  降级：返回T-1或T-n的数据                               │    │
│  │                                                         │    │
│  │  例：实时库存 → 降级为准实时（1分钟延迟）              │    │
│  └─────────────────────────────────────────────────────────┘    │
│                                                                  │
└─────────────────────────────────────────────────────────────────┘

┌─────────────────────────────────────────────────────────────────┐
│                    降级触发方式                                  │
├─────────────────────────────────────────────────────────────────┤
│                                                                  │
│  ┌─────────────────────────────────────────────────────────┐    │
│  │                                                         │    │
│  │  1. 自动降级                                            │    │
│  │     - 超时降级：接口超时自动切换                        │    │
│  │     - 失败率降级：失败率过高触发                        │    │
│  │     - 资源降级：CPU/内存超阈值触发                      │    │
│  │                                                         │    │
│  │  2. 手动降级                                            │    │
│  │     - 开关控制：配置中心动态开关                        │    │
│  │     - 预案降级：大促前提前降级非核心功能                │    │
│  │                                                         │    │
│  └─────────────────────────────────────────────────────────┘    │
│                                                                  │
└─────────────────────────────────────────────────────────────────┘

┌─────────────────────────────────────────────────────────────────┐
│                 熔断 vs 降级 vs 限流                             │
├─────────────────────────────────────────────────────────────────┤
│                                                                  │
│  ┌───────────┬────────────────────────────────────────────┐     │
│  │   熔断    │ 下游服务故障时，快速失败，防止级联故障     │     │
│  │           │ 保护调用方                                 │     │
│  ├───────────┼────────────────────────────────────────────┤     │
│  │   降级    │ 系统压力大或部分服务不可用时              │     │
│  │           │ 牺牲非核心功能，保证核心功能              │     │
│  ├───────────┼────────────────────────────────────────────┤     │
│  │   限流    │ 控制进入系统的流量                        │     │
│  │           │ 防止系统过载                              │     │
│  └───────────┴────────────────────────────────────────────┘     │
│                                                                  │
│  三者关系：                                                      │
│  限流是入口控制 → 熔断是调用保护 → 降级是兜底方案              │
│                                                                  │
└─────────────────────────────────────────────────────────────────┘
```

---

## 第三章总结

```
┌─────────────────────────────────────────────────────────────────┐
│                   分布式系统知识体系                             │
├─────────────────────────────────────────────────────────────────┤
│                                                                  │
│  分布式理论                                                      │
│  ├── CAP定理：C/A/P三选二，分布式通常选AP或CP                   │
│  ├── BASE理论：基本可用、软状态、最终一致                       │
│  ├── 一致性协议：Paxos（理论基础）、Raft（工程实现）            │
│  └── 拜占庭问题：恶意节点场景，区块链相关                       │
│                                                                  │
│  分布式事务                                                      │
│  ├── 强一致：2PC/3PC/XA（性能差）                               │
│  ├── 最终一致：TCC/Saga/本地消息表/事务消息                     │
│  └── 框架：Seata（AT/TCC/Saga/XA模式）                          │
│                                                                  │
│  分布式锁                                                        │
│  ├── Redis锁：SET NX PX + Lua解锁，Redlock多节点                │
│  ├── ZK锁：临时顺序节点 + Watch                                 │
│  └── 问题：续期（看门狗）、可重入（Hash计数）                   │
│                                                                  │
│  分布式ID                                                        │
│  ├── 雪花算法：时间戳+机器ID+序列号，时钟回拨问题               │
│  └── Leaf：号段模式（双Buffer）、Snowflake模式（ZK分配ID）      │
│                                                                  │
│  分布式服务                                                      │
│  ├── 注册发现：Eureka(AP)/Nacos/Consul(CP)/ZK(CP)               │
│  ├── 负载均衡：轮询/加权/随机/最少连接/一致性哈希               │
│  ├── 熔断：Closed→Open→Half-Open状态机                          │
│  ├── 限流：固定窗口/滑动窗口/漏桶/令牌桶                        │
│  └── 降级：默认值/缓存/功能关闭/读写降级                        │
│                                                                  │
└─────────────────────────────────────────────────────────────────┘
```
