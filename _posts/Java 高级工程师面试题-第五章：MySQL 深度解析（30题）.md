# 第五章：MySQL 深度解析（30题）

## 5.1 索引原理（8题）

### 126. B+树为什么适合做索引？

```
┌─────────────────────────────────────────────────────────────────────────┐
│                        B+树 vs 其他数据结构                               │
├─────────────────────────────────────────────────────────────────────────┤
│                                                                         │
│  ┌──────────────────────── B+树结构 ────────────────────────┐           │
│  │                                                          │           │
│  │                    ┌─────────────────┐                   │           │
│  │                    │  15 │ 28 │ 50  │ ← 非叶子节点       │           │
│  │                    └──┬────┬────┬───┘   (只存索引)       │           │
│  │           ┌───────────┘    │    └───────────┐            │           │
│  │           ↓                ↓                ↓            │           │
│  │    ┌───────────┐    ┌───────────┐    ┌───────────┐       │           │
│  │    │ 3│8 │12│15│    │18│22│25│28│    │35│42│48│50│       │           │
│  │    └─────┬─────┘    └─────┬─────┘    └─────┬─────┘       │           │
│  │          ↓                ↓                ↓             │           │
│  │    ┌─────────┐      ┌─────────┐      ┌─────────┐        │           │
│  │    │Data│Data│ ←→   │Data│Data│ ←→   │Data│Data│        │           │
│  │    └─────────┘      └─────────┘      └─────────┘        │           │
│  │         ↑                                                │           │
│  │    叶子节点(存数据+双向链表)                              │           │
│  └──────────────────────────────────────────────────────────┘           │
│                                                                         │
│  ┌─────────────────── 各数据结构对比 ───────────────────────┐           │
│  │                                                          │           │
│  │  数据结构    │ 等值查询 │ 范围查询 │ 磁盘IO │ 稳定性    │           │
│  │  ─────────────────────────────────────────────────────   │           │
│  │  Hash表      │ O(1)    │ 不支持   │ 一次   │ 有冲突    │           │
│  │  二叉搜索树  │ O(logN) │ 支持     │ 很多次 │ 可能退化  │           │
│  │  AVL/红黑树  │ O(logN) │ 支持     │ 很多次 │ 高度较高  │           │
│  │  B树         │ O(logN) │ 支持     │ 较少   │ 数据分散  │           │
│  │  B+树        │ O(logN) │ 支持     │ 最少   │ 最稳定    │           │
│  │                                                          │           │
│  └──────────────────────────────────────────────────────────┘           │
└─────────────────────────────────────────────────────────────────────────┘
```

```java
/**
 * B+树适合做索引的原因分析
 */
public class BPlusTreeAnalysis {

    /**
     * 原因1：磁盘IO次数少
     *
     * - B+树是多叉树，高度通常为3-4层
     * - 每个节点存储更多key，可以存满一个磁盘页(16KB)
     * - 3层B+树可以存储约2000万条数据
     */

    // 假设：页大小16KB，主键bigint(8字节)，指针(6字节)
    // 非叶子节点可存储: 16KB / 14B ≈ 1170个索引
    // 叶子节点假设每行1KB，可存储16条数据
    // 3层树: 1170 * 1170 * 16 ≈ 2200万条数据，仅需3次IO

    /**
     * 原因2：查询效率稳定
     *
     * - 所有数据都在叶子节点
     * - 每次查询路径长度相同
     * - 时间复杂度稳定为O(logN)
     */

    /**
     * 原因3：范围查询高效
     *
     * - 叶子节点通过双向链表连接
     * - 范围查询只需定位起点，顺序遍历即可
     */
    public void rangeQuery(int start, int end) {
        // 1. 通过B+树定位到start所在叶子节点 - O(logN)
        // 2. 沿链表顺序扫描到end - O(M)，M为范围内数据量
        // 总复杂度: O(logN + M)
    }

    /**
     * 原因4：数据存储有序
     *
     * - 叶子节点按key有序排列
     * - 便于ORDER BY和GROUP BY操作
     */

    /**
     * 原因5：充分利用磁盘预读
     *
     * - 操作系统按页读取数据(通常4KB)
     * - InnoDB页大小16KB，一次IO读取多个相邻节点
     * - 空间局部性好，减少随机IO
     */
}
```

---

### 127. 聚簇索引和非聚簇索引的区别？

```
┌─────────────────────────────────────────────────────────────────────────┐
│                    聚簇索引 vs 非聚簇索引                                 │
├─────────────────────────────────────────────────────────────────────────┤
│                                                                         │
│  ┌────────────── 聚簇索引(主键索引) ──────────────┐                      │
│  │                                                │                      │
│  │           ┌─────────────┐                      │                      │
│  │           │  10 │ 20    │                      │                      │
│  │           └───┬────┬────┘                      │                      │
│  │         ┌─────┘    └─────┐                     │                      │
│  │         ↓                ↓                     │                      │
│  │  ┌─────────────┐  ┌─────────────┐              │                      │
│  │  │ 5  │  10    │  │ 15 │  20    │              │                      │
│  │  └──┬─────┬────┘  └──┬─────┬────┘              │                      │
│  │     ↓     ↓          ↓     ↓                   │                      │
│  │  ┌──────┐┌──────┐ ┌──────┐┌──────┐            │                      │
│  │  │id=5  ││id=10 │ │id=15 ││id=20 │ ← 叶子节点  │                      │
│  │  │name= ││name= │ │name= ││name= │   存完整行  │                      │
│  │  │age=  ││age=  │ │age=  ││age=  │   数据      │                      │
│  │  └──────┘└──────┘ └──────┘└──────┘            │                      │
│  │        ↑                                       │                      │
│  │    数据和索引存储在一起                         │                      │
│  └────────────────────────────────────────────────┘                      │
│                                                                         │
│  ┌────────────── 非聚簇索引(二级索引) ─────────────┐                     │
│  │                                                │                      │
│  │           ┌─────────────┐                      │                      │
│  │           │  李  │ 张    │                      │                      │
│  │           └───┬────┬────┘                      │                      │
│  │         ┌─────┘    └─────┐                     │                      │
│  │         ↓                ↓                     │                      │
│  │  ┌─────────────┐  ┌─────────────┐              │                      │
│  │  │ 陈  │  李    │  │ 王 │  张    │              │                      │
│  │  └──┬─────┬────┘  └──┬─────┬────┘              │                      │
│  │     ↓     ↓          ↓     ↓                   │                      │
│  │  ┌──────┐┌──────┐ ┌──────┐┌──────┐            │                      │
│  │  │陈    ││李    │ │王    ││张    │ ← 叶子节点  │                      │
│  │  │id=15 ││id=5  │ │id=20 ││id=10 │   存主键值  │                      │
│  │  └───┬──┘└───┬──┘ └───┬──┘└───┬──┘            │                      │
│  │      │       │        │       │                │                      │
│  │      └───────┴────────┴───────┘                │                      │
│  │                    ↓                           │                      │
│  │           需要回表查询完整数据                   │                      │
│  └────────────────────────────────────────────────┘                      │
│                                                                         │
│  ┌─────────────────── 核心区别对比 ───────────────────┐                  │
│  │                                                    │                  │
│  │  特性        │  聚簇索引          │  非聚簇索引     │                  │
│  │  ─────────────────────────────────────────────────│                  │
│  │  叶子节点    │  完整行数据        │  主键值         │                  │
│  │  数量        │  一个表只有一个    │  可以有多个     │                  │
│  │  查询效率    │  更快(无需回表)    │  可能需回表     │                  │
│  │  插入效率    │  按主键顺序最快    │  需要维护索引   │                  │
│  │  物理顺序    │  决定数据存储顺序  │  不影响存储顺序 │                  │
│  │  存储引擎    │  InnoDB            │  InnoDB/MyISAM  │                  │
│  │                                                    │                  │
│  └────────────────────────────────────────────────────┘                  │
└─────────────────────────────────────────────────────────────────────────┘
```

```java
/**
 * 聚簇索引和非聚簇索引详解
 */
public class ClusteredIndexDemo {

    /**
     * 聚簇索引选择规则（InnoDB）
     *
     * 1. 如果有主键，主键就是聚簇索引
     * 2. 如果没有主键，选择第一个非空唯一索引
     * 3. 如果都没有，创建一个隐藏的row_id作为聚簇索引
     */

    // 示例表结构
    /*
    CREATE TABLE user (
        id BIGINT PRIMARY KEY,           -- 聚簇索引
        name VARCHAR(50),
        age INT,
        email VARCHAR(100),
        INDEX idx_name(name),            -- 非聚簇索引(二级索引)
        INDEX idx_age(age)               -- 非聚簇索引(二级索引)
    ) ENGINE=InnoDB;
    */

    /**
     * 查询示例
     */
    public void queryExamples() {
        // 1. 通过主键查询 - 直接使用聚簇索引，效率最高
        // SELECT * FROM user WHERE id = 100;
        // 过程: 聚簇索引 -> 直接获取完整行数据

        // 2. 通过二级索引查询 - 需要回表
        // SELECT * FROM user WHERE name = '张三';
        // 过程: 二级索引 -> 获取id=100 -> 回表查聚簇索引 -> 完整行数据

        // 3. 覆盖索引查询 - 不需要回表
        // SELECT id, name FROM user WHERE name = '张三';
        // 过程: 二级索引 -> 直接返回(索引中包含所需字段)
    }
}
```

---

### 128. 什么是回表？如何避免？

```
┌─────────────────────────────────────────────────────────────────────────┐
│                           回表查询过程                                    │
├─────────────────────────────────────────────────────────────────────────┤
│                                                                         │
│  查询: SELECT * FROM user WHERE name = '张三'                           │
│                                                                         │
│  ┌─────────────── 二级索引(idx_name) ─────────────────┐                 │
│  │                                                    │                 │
│  │        ┌───────────┐                              │                 │
│  │        │  李 │ 张   │                              │                 │
│  │        └──┬────┬───┘                              │                 │
│  │           ↓    ↓                                  │                 │
│  │    ┌─────────┐  ┌─────────┐                       │                 │
│  │    │王id=20  │  │张三id=10│ ← 找到name='张三'      │                 │
│  │    └─────────┘  └────┬────┘                       │                 │
│  │                      │                            │                 │
│  └──────────────────────┼────────────────────────────┘                 │
│                         │                                              │
│                    步骤1: 获取id=10                                     │
│                         │                                              │
│                         ↓                                              │
│  ┌─────────────── 聚簇索引(主键) ──────────────────────┐                │
│  │                                                    │                 │
│  │        ┌───────────┐                              │                 │
│  │        │  10 │ 20  │                              │                 │
│  │        └──┬────┬───┘                              │                 │
│  │           ↓    ↓                                  │                 │
│  │    ┌──────────────┐  ┌─────────┐                  │                 │
│  │    │id=10         │  │id=20    │                  │                 │
│  │    │name='张三'   │ ← 回表查询  │                  │                 │
│  │    │age=25        │  │...      │                  │                 │
│  │    │email='xx'    │  │         │                  │                 │
│  │    └──────────────┘  └─────────┘                  │                 │
│  │                                                    │                 │
│  └────────────────────────────────────────────────────┘                │
│                         │                                              │
│                    步骤2: 获取完整行数据                                 │
│                         ↓                                              │
│              返回: (10, '张三', 25, 'xx@xx.com')                        │
│                                                                         │
│  ═══════════════════════════════════════════════════════════════════   │
│                                                                         │
│                      避免回表的方法                                      │
│                                                                         │
│  ┌─────────────────── 覆盖索引 ───────────────────────┐                 │
│  │                                                    │                 │
│  │  方法1: 只查询索引中包含的列                        │                 │
│  │                                                    │                 │
│  │  -- 创建联合索引                                   │                 │
│  │  CREATE INDEX idx_name_age ON user(name, age);    │                 │
│  │                                                    │                 │
│  │  -- 查询可以被覆盖索引满足                          │                 │
│  │  SELECT id, name, age FROM user WHERE name = '张三';│                │
│  │         ↑                                          │                 │
│  │    索引中包含: id(主键自动包含) + name + age        │                 │
│  │                                                    │                 │
│  │  EXPLAIN结果: Using index (表示使用了覆盖索引)      │                 │
│  │                                                    │                 │
│  └────────────────────────────────────────────────────┘                │
└─────────────────────────────────────────────────────────────────────────┘
```

```java
/**
 * 避免回表的最佳实践
 */
public class AvoidTableLookback {

    /*
     * 表结构
     */
    private static final String CREATE_TABLE = """
        CREATE TABLE orders (
            id BIGINT PRIMARY KEY,
            user_id BIGINT,
            product_id BIGINT,
            amount DECIMAL(10,2),
            status TINYINT,
            create_time DATETIME,
            INDEX idx_user_id(user_id),
            INDEX idx_user_product(user_id, product_id),
            INDEX idx_user_status_time(user_id, status, create_time)
        );
    """;

    /**
     * 场景1: 需要回表
     */
    public void needTableLookback() {
        // 查询用户的所有订单金额
        // SELECT * FROM orders WHERE user_id = 100;
        //
        // 执行过程:
        // 1. idx_user_id 找到 user_id=100 的所有 id
        // 2. 对每个 id 回表查询完整行数据
        // 3. 如果匹配行数多，性能较差
    }

    /**
     * 场景2: 覆盖索引避免回表
     */
    public void useCoveringIndex() {
        // 只查询索引中包含的列
        // SELECT user_id, product_id FROM orders WHERE user_id = 100;
        //
        // 使用 idx_user_product 索引
        // 叶子节点包含: user_id, product_id, id(主键)
        // 不需要回表!
    }

    /**
     * 场景3: 合理设计联合索引
     */
    public void designCompositeIndex() {
        // 业务场景: 查询用户某状态的订单创建时间
        // SELECT user_id, status, create_time
        // FROM orders
        // WHERE user_id = 100 AND status = 1;

        // 使用 idx_user_status_time 联合索引
        // 索引覆盖所需字段，无需回表

        // 创建索引时考虑:
        // 1. WHERE 条件中的列
        // 2. SELECT 中需要的列
        // 3. ORDER BY 中的列
    }

    /**
     * 场景4: 索引下推减少回表
     */
    public void indexConditionPushdown() {
        // SELECT * FROM orders
        // WHERE user_id = 100 AND status = 1;

        // 如果只有 idx_user_id 索引:
        //
        // 无ICP:
        //   1. 索引找到user_id=100的所有行
        //   2. 全部回表
        //   3. 在Server层过滤status=1
        //
        // 有ICP (MySQL 5.6+):
        //   1. 索引找到user_id=100的行
        //   2. 在存储引擎层用status=1过滤
        //   3. 只对满足条件的行回表
    }
}
```

---

### 129. 什么是索引下推？

```
┌─────────────────────────────────────────────────────────────────────────┐
│                     索引下推 (Index Condition Pushdown)                   │
├─────────────────────────────────────────────────────────────────────────┤
│                                                                         │
│  表结构: CREATE INDEX idx_name_age ON user(name, age);                  │
│  查询:   SELECT * FROM user WHERE name LIKE '张%' AND age = 25;         │
│                                                                         │
│  ┌────────────── 无索引下推 (MySQL 5.6之前) ──────────────┐              │
│  │                                                        │              │
│  │   ┌──────────────┐                                    │              │
│  │   │  二级索引     │                                    │              │
│  │   │ idx_name_age │                                    │              │
│  │   └──────┬───────┘                                    │              │
│  │          │ 只能用name LIKE '张%'                       │              │
│  │          │ age条件无法使用                             │              │
│  │          ↓                                            │              │
│  │   ┌──────────────────────────────────────┐            │              │
│  │   │ 张三 age=20 id=1  → 回表              │            │              │
│  │   │ 张四 age=25 id=2  → 回表              │            │              │
│  │   │ 张五 age=30 id=3  → 回表              │            │              │
│  │   │ 张六 age=25 id=4  → 回表              │            │              │
│  │   └──────────────────────────────────────┘            │              │
│  │          │ 4次回表                                    │              │
│  │          ↓                                            │              │
│  │   ┌──────────────┐                                    │              │
│  │   │  Server层     │ 过滤 age=25                       │              │
│  │   │  过滤数据     │ 返回2条结果                        │              │
│  │   └──────────────┘                                    │              │
│  │                                                        │              │
│  └────────────────────────────────────────────────────────┘              │
│                                                                         │
│  ┌────────────── 有索引下推 (MySQL 5.6+) ─────────────────┐              │
│  │                                                        │              │
│  │   ┌──────────────┐                                    │              │
│  │   │  二级索引     │                                    │              │
│  │   │ idx_name_age │                                    │              │
│  │   └──────┬───────┘                                    │              │
│  │          │ 使用name LIKE '张%'                         │              │
│  │          │ 同时用age=25过滤!                           │              │
│  │          ↓                                            │              │
│  │   ┌──────────────────────────────────────┐            │              │
│  │   │ 张三 age=20 id=1  → ✗ 不回表          │            │              │
│  │   │ 张四 age=25 id=2  → ✓ 回表            │            │              │
│  │   │ 张五 age=30 id=3  → ✗ 不回表          │            │              │
│  │   │ 张六 age=25 id=4  → ✓ 回表            │            │              │
│  │   └──────────────────────────────────────┘            │              │
│  │          │ 只需2次回表!                                │              │
│  │          ↓                                            │              │
│  │   ┌──────────────┐                                    │              │
│  │   │  返回结果     │ 2条数据                            │              │
│  │   └──────────────┘                                    │              │
│  │                                                        │              │
│  └────────────────────────────────────────────────────────┘              │
│                                                                         │
│  ┌────────────────── ICP适用条件 ──────────────────────┐                │
│  │                                                      │                │
│  │  1. 只能用于二级索引，不适用于主键索引                  │                │
│  │  2. 只能用于 range、ref、eq_ref、ref_or_null 访问方式  │                │
│  │  3. 条件列必须在索引中                                │                │
│  │  4. InnoDB 和 MyISAM 都支持                          │                │
│  │                                                      │                │
│  └──────────────────────────────────────────────────────┘                │
└─────────────────────────────────────────────────────────────────────────┘
```

```sql
-- 查看索引下推是否开启
SHOW VARIABLES LIKE 'optimizer_switch';

-- 开启/关闭索引下推
SET optimizer_switch = 'index_condition_pushdown=on';
SET optimizer_switch = 'index_condition_pushdown=off';

-- 验证ICP效果
EXPLAIN SELECT * FROM user WHERE name LIKE '张%' AND age = 25;
-- Extra列显示: Using index condition (表示使用了ICP)

-- 对比关闭ICP后的执行计划
SET optimizer_switch = 'index_condition_pushdown=off';
EXPLAIN SELECT * FROM user WHERE name LIKE '张%' AND age = 25;
-- Extra列显示: Using where (没有使用ICP)
```

---

### 130. 联合索引的最左匹配原则？

```
┌─────────────────────────────────────────────────────────────────────────┐
│                       联合索引最左匹配原则                                │
├─────────────────────────────────────────────────────────────────────────┤
│                                                                         │
│  联合索引: INDEX idx_abc(a, b, c)                                        │
│                                                                         │
│  ┌─────────────────── 索引存储结构 ────────────────────┐                 │
│  │                                                     │                 │
│  │  索引按 a → b → c 顺序排序                           │                 │
│  │                                                     │                 │
│  │  ┌────────────────────────────────────────────┐    │                 │
│  │  │  a  │  b  │  c  │  id(主键)                │    │                 │
│  │  ├────────────────────────────────────────────┤    │                 │
│  │  │  1  │  1  │  1  │  101                     │    │                 │
│  │  │  1  │  1  │  2  │  102                     │    │                 │
│  │  │  1  │  2  │  1  │  103                     │    │                 │
│  │  │  1  │  2  │  3  │  104                     │    │                 │
│  │  │  2  │  1  │  1  │  105                     │    │                 │
│  │  │  2  │  1  │  5  │  106                     │    │                 │
│  │  │  2  │  3  │  2  │  107                     │    │                 │
│  │  │  3  │  1  │  1  │  108                     │    │                 │
│  │  └────────────────────────────────────────────┘    │                 │
│  │        ↑                                           │                 │
│  │   先按a排序，a相同按b排序，b相同按c排序              │                 │
│  │                                                     │                 │
│  └─────────────────────────────────────────────────────┘                 │
│                                                                         │
│  ┌─────────────────── 查询场景分析 ────────────────────┐                 │
│  │                                                     │                 │
│  │  ✓ 能使用索引的查询:                                 │                 │
│  │    WHERE a = 1                         使用a        │                 │
│  │    WHERE a = 1 AND b = 2               使用a,b      │                 │
│  │    WHERE a = 1 AND b = 2 AND c = 3     使用a,b,c    │                 │
│  │    WHERE a = 1 AND c = 3               使用a (c无法用)│                │
│  │    WHERE a = 1 AND b > 2               使用a,b      │                 │
│  │    WHERE a = 1 AND b = 2 ORDER BY c    使用a,b,c排序 │                 │
│  │                                                     │                 │
│  │  ✗ 不能使用索引的查询:                               │                 │
│  │    WHERE b = 2                         跳过a,无法用  │                 │
│  │    WHERE c = 3                         跳过a,b,无法用│                │
│  │    WHERE b = 2 AND c = 3               跳过a,无法用  │                 │
│  │                                                     │                 │
│  │  ⚠ 部分使用索引:                                     │                 │
│  │    WHERE a = 1 AND b > 2 AND c = 3     a,b可用(范围后停)│               │
│  │    WHERE a = 1 AND b LIKE '张%' AND c = 3  a,b可用   │                 │
│  │                                                     │                 │
│  └─────────────────────────────────────────────────────┘                 │
└─────────────────────────────────────────────────────────────────────────┘
```

```java
/**
 * 联合索引最左匹配原则详解
 */
public class LeftmostPrefixDemo {

    // 创建测试表和索引
    private static final String DDL = """
        CREATE TABLE orders (
            id BIGINT PRIMARY KEY,
            user_id BIGINT,
            product_id BIGINT,
            status TINYINT,
            amount DECIMAL(10,2),
            create_time DATETIME,
            INDEX idx_user_product_status(user_id, product_id, status)
        );
    """;

    /**
     * 最左匹配原则实战
     */
    public void leftmostPrefixExamples() {

        // ========== 完全匹配 ==========

        // ✓ 使用全部索引列
        String sql1 = """
            SELECT * FROM orders
            WHERE user_id = 100
            AND product_id = 200
            AND status = 1
        """;
        // 索引使用: user_id, product_id, status (全部)


        // ========== 部分匹配 ==========

        // ✓ 只使用最左列
        String sql2 = """
            SELECT * FROM orders WHERE user_id = 100
        """;
        // 索引使用: user_id

        // ✓ 使用最左两列
        String sql3 = """
            SELECT * FROM orders
            WHERE user_id = 100 AND product_id = 200
        """;
        // 索引使用: user_id, product_id


        // ========== 跳跃失效 ==========

        // ✗ 跳过最左列
        String sql4 = """
            SELECT * FROM orders WHERE product_id = 200
        """;
        // 索引使用: 无 (跳过了user_id)

        // ✗ 跳过中间列
        String sql5 = """
            SELECT * FROM orders
            WHERE user_id = 100 AND status = 1
        """;
        // 索引使用: 只有user_id (跳过了product_id，status无法使用)


        // ========== 范围查询导致停止 ==========

        // ⚠ 范围查询后的列无法使用索引
        String sql6 = """
            SELECT * FROM orders
            WHERE user_id = 100
            AND product_id > 200
            AND status = 1
        """;
        // 索引使用: user_id, product_id (status在范围查询之后，无法使用)


        // ========== 列顺序无关 ==========

        // ✓ WHERE条件顺序不影响
        String sql7 = """
            SELECT * FROM orders
            WHERE status = 1
            AND user_id = 100
            AND product_id = 200
        """;
        // 索引使用: user_id, product_id, status (全部)
        // MySQL优化器会自动调整顺序!
    }

    /**
     * 索引设计建议
     */
    public void designSuggestions() {
        // 1. 最常用的查询条件放最左边
        // 2. 选择性高的列放前面
        // 3. 范围查询条件放最后
        // 4. 考虑覆盖索引，把SELECT的列也加入

        // 好的索引设计示例:
        // INDEX idx_user_status_time(user_id, status, create_time)
        //
        // 支持的查询:
        // WHERE user_id = ?
        // WHERE user_id = ? AND status = ?
        // WHERE user_id = ? AND status = ? AND create_time > ?
        // WHERE user_id = ? AND status = ? ORDER BY create_time
    }
}
```

---

### 131. 索引失效的场景有哪些？

```
┌─────────────────────────────────────────────────────────────────────────┐
│                          索引失效的常见场景                               │
├─────────────────────────────────────────────────────────────────────────┤
│                                                                         │
│  ┌────────────────────── 场景分类 ──────────────────────┐               │
│  │                                                      │               │
│  │  ┌─────────────────────────────────────────────────┐ │               │
│  │  │              1. 对索引列做运算/函数              │ │               │
│  │  ├─────────────────────────────────────────────────┤ │               │
│  │  │                                                 │ │               │
│  │  │  ✗ WHERE YEAR(create_time) = 2024              │ │               │
│  │  │  ✓ WHERE create_time >= '2024-01-01'           │ │               │
│  │  │       AND create_time < '2025-01-01'           │ │               │
│  │  │                                                 │ │               │
│  │  │  ✗ WHERE age + 1 = 20                          │ │               │
│  │  │  ✓ WHERE age = 19                              │ │               │
│  │  │                                                 │ │               │
│  │  │  ✗ WHERE CONCAT(first_name, last_name) = '张三' │ │               │
│  │  │  ✓ WHERE first_name = '张' AND last_name = '三' │ │               │
│  │  │                                                 │ │               │
│  │  └─────────────────────────────────────────────────┘ │               │
│  │                                                      │               │
│  │  ┌─────────────────────────────────────────────────┐ │               │
│  │  │              2. 隐式类型转换                     │ │               │
│  │  ├─────────────────────────────────────────────────┤ │               │
│  │  │                                                 │ │               │
│  │  │  -- phone是VARCHAR类型                          │ │               │
│  │  │  ✗ WHERE phone = 13812345678  (数字)           │ │               │
│  │  │  ✓ WHERE phone = '13812345678' (字符串)        │ │               │
│  │  │                                                 │ │               │
│  │  │  -- 字符串转数字会扫描全表                       │ │               │
│  │  │  -- 相当于 CAST(phone AS SIGNED) = 13812345678 │ │               │
│  │  │                                                 │ │               │
│  │  └─────────────────────────────────────────────────┘ │               │
│  │                                                      │               │
│  │  ┌─────────────────────────────────────────────────┐ │               │
│  │  │              3. LIKE左模糊匹配                   │ │               │
│  │  ├─────────────────────────────────────────────────┤ │               │
│  │  │                                                 │ │               │
│  │  │  ✗ WHERE name LIKE '%张'     (左模糊)          │ │               │
│  │  │  ✗ WHERE name LIKE '%张%'    (全模糊)          │ │               │
│  │  │  ✓ WHERE name LIKE '张%'     (右模糊)          │ │               │
│  │  │                                                 │ │               │
│  │  │  解决方案: 使用全文索引或搜索引擎(ES)            │ │               │
│  │  │                                                 │ │               │
│  │  └─────────────────────────────────────────────────┘ │               │
│  │                                                      │               │
│  │  ┌─────────────────────────────────────────────────┐ │               │
│  │  │              4. OR条件未全覆盖索引               │ │               │
│  │  ├─────────────────────────────────────────────────┤ │               │
│  │  │                                                 │ │               │
│  │  │  -- 只有name有索引,age无索引                     │ │               │
│  │  │  ✗ WHERE name = '张三' OR age = 25             │ │               │
│  │  │                                                 │ │               │
│  │  │  -- name和age都有索引                           │ │               │
│  │  │  ✓ WHERE name = '张三' OR age = 25             │ │               │
│  │  │    (使用index_merge优化)                        │ │               │
│  │  │                                                 │ │               │
│  │  │  -- 改写为UNION                                 │ │               │
│  │  │  ✓ SELECT * FROM t WHERE name='张三'           │ │               │
│  │  │    UNION                                        │ │               │
│  │  │    SELECT * FROM t WHERE age=25                │ │               │
│  │  │                                                 │ │               │
│  │  └─────────────────────────────────────────────────┘ │               │
│  │                                                      │               │
│  │  ┌─────────────────────────────────────────────────┐ │               │
│  │  │              5. NOT IN / NOT EXISTS / !=        │ │               │
│  │  ├─────────────────────────────────────────────────┤ │               │
│  │  │                                                 │ │               │
│  │  │  ✗ WHERE status != 1        (可能失效)         │ │               │
│  │  │  ✗ WHERE status NOT IN (1,2,3)                 │ │               │
│  │  │  ✗ WHERE id NOT IN (SELECT...)                 │ │               │
│  │  │                                                 │ │               │
│  │  │  -- 根据数据分布,优化器可能选择全表扫描          │ │               │
│  │  │                                                 │ │               │
│  │  └─────────────────────────────────────────────────┘ │               │
│  │                                                      │               │
│  │  ┌─────────────────────────────────────────────────┐ │               │
│  │  │              6. 数据量少/选择性差                │ │               │
│  │  ├─────────────────────────────────────────────────┤ │               │
│  │  │                                                 │ │               │
│  │  │  -- 优化器认为全表扫描更快                       │ │               │
│  │  │  • 表数据量很少(几百条)                         │ │               │
│  │  │  • 索引选择性差(如性别只有男/女)                │ │               │
│  │  │  • 查询结果占比过大(超过30%)                    │ │               │
│  │  │                                                 │ │               │
│  │  └─────────────────────────────────────────────────┘ │               │
│  │                                                      │               │
│  └──────────────────────────────────────────────────────┘               │
│                                                                         │
└─────────────────────────────────────────────────────────────────────────┘
```

```java
/**
 * 索引失效场景及解决方案
 */
public class IndexInvalidationDemo {

    /**
     * 场景7: 联合索引不满足最左前缀
     */
    public void compositeIndexIssue() {
        // INDEX idx_a_b_c(a, b, c)

        // ✗ 失效
        String bad1 = "SELECT * FROM t WHERE b = 1";
        String bad2 = "SELECT * FROM t WHERE c = 1";
        String bad3 = "SELECT * FROM t WHERE b = 1 AND c = 2";

        // ✓ 生效
        String good1 = "SELECT * FROM t WHERE a = 1";
        String good2 = "SELECT * FROM t WHERE a = 1 AND b = 2";
    }

    /**
     * 场景8: IS NULL / IS NOT NULL 可能失效
     */
    public void nullIssue() {
        // 取决于NULL值占比和统计信息
        // ✗ 可能失效
        String sql1 = "SELECT * FROM t WHERE name IS NULL";
        String sql2 = "SELECT * FROM t WHERE name IS NOT NULL";

        // 建议: 设置NOT NULL默认值，避免NULL判断
    }

    /**
     * 场景9: 使用ORDER BY但无法利用索引
     */
    public void orderByIssue() {
        // INDEX idx_a_b(a, b)

        // ✗ 需要filesort
        String bad1 = "SELECT * FROM t ORDER BY b";      // 不是最左列
        String bad2 = "SELECT * FROM t ORDER BY a DESC, b ASC"; // 排序方向不一致

        // ✓ 使用索引排序
        String good1 = "SELECT * FROM t ORDER BY a";
        String good2 = "SELECT * FROM t ORDER BY a, b";
        String good3 = "SELECT * FROM t WHERE a = 1 ORDER BY b";
    }

    /**
     * 场景10: 字符集不匹配
     */
    public void charsetIssue() {
        // 两表JOIN时字符集/排序规则不同
        // SELECT * FROM t1 JOIN t2 ON t1.name = t2.name
        // 如果t1.name是utf8，t2.name是utf8mb4
        // 会导致隐式转换，索引失效

        // 解决: 保持字符集一致
    }
}
```

---

### 132. 如何优化慢SQL？

```
┌─────────────────────────────────────────────────────────────────────────┐
│                          慢SQL优化流程                                   │
├─────────────────────────────────────────────────────────────────────────┤
│                                                                         │
│  ┌──────────────────────────────────────────────────────────────────┐   │
│  │                       优化步骤流程                                │   │
│  │                                                                  │   │
│  │   ┌─────────────┐                                               │   │
│  │   │ 1.定位慢SQL │                                               │   │
│  │   └──────┬──────┘                                               │   │
│  │          │                                                       │   │
│  │          ↓                                                       │   │
│  │   ┌─────────────────────────────┐                               │   │
│  │   │ 2.EXPLAIN分析执行计划        │                               │   │
│  │   └──────┬──────────────────────┘                               │   │
│  │          │                                                       │   │
│  │          ↓                                                       │   │
│  │   ┌─────────────────────────────┐                               │   │
│  │   │ 3.分析问题原因               │                               │   │
│  │   │ (全表扫描/索引失效/回表多)   │                               │   │
│  │   └──────┬──────────────────────┘                               │   │
│  │          │                                                       │   │
│  │          ↓                                                       │   │
│  │   ┌─────────────────────────────┐                               │   │
│  │   │ 4.针对性优化                 │                               │   │
│  │   │ (加索引/改写SQL/调整表结构)  │                               │   │
│  │   └──────┬──────────────────────┘                               │   │
│  │          │                                                       │   │
│  │          ↓                                                       │   │
│  │   ┌─────────────────────────────┐                               │   │
│  │   │ 5.验证优化效果               │                               │   │
│  │   └─────────────────────────────┘                               │   │
│  │                                                                  │   │
│  └──────────────────────────────────────────────────────────────────┘   │
│                                                                         │
│  ┌─────────────────── 具体优化策略 ────────────────────┐                │
│  │                                                      │                │
│  │  【索引优化】                                        │                │
│  │   • 为WHERE/JOIN/ORDER BY的列添加索引               │                │
│  │   • 使用覆盖索引减少回表                             │                │
│  │   • 避免索引失效的写法                               │                │
│  │   • 删除冗余和未使用的索引                           │                │
│  │                                                      │                │
│  │  【SQL改写】                                         │                │
│  │   • 避免SELECT *，只查需要的列                       │                │
│  │   • 用EXISTS代替IN子查询                             │                │
│  │   • 用JOIN代替子查询                                 │                │
│  │   • 拆分复杂SQL为多个简单SQL                         │                │
│  │   • 避免在循环中执行SQL                              │                │
│  │                                                      │                │
│  │  【表结构优化】                                      │                │
│  │   • 选择合适的数据类型(越小越好)                     │                │
│  │   • 适当冗余减少JOIN                                 │                │
│  │   • 大字段拆分到独立表                               │                │
│  │   • 归档历史数据，减少表大小                         │                │
│  │                                                      │                │
│  │  【业务层优化】                                      │                │
│  │   • 增加缓存层(Redis)                               │                │
│  │   • 读写分离                                        │                │
│  │   • 分库分表                                        │                │
│  │   • 预计算/异步处理                                 │                │
│  │                                                      │                │
│  └──────────────────────────────────────────────────────┘                │
└─────────────────────────────────────────────────────────────────────────┘
```

```sql
-- ========== 1. 开启慢查询日志 ==========
SET GLOBAL slow_query_log = ON;
SET GLOBAL long_query_time = 1;  -- 超过1秒记录
SET GLOBAL slow_query_log_file = '/var/log/mysql/slow.log';

-- 查看慢查询日志
SHOW VARIABLES LIKE '%slow%';

-- ========== 2. EXPLAIN分析 ==========
EXPLAIN SELECT * FROM orders o
JOIN users u ON o.user_id = u.id
WHERE o.status = 1 AND o.create_time > '2024-01-01';

-- ========== 3. 优化示例 ==========

-- 原始慢SQL
SELECT * FROM orders
WHERE DATE(create_time) = '2024-01-15'
AND status IN (1,2,3);

-- 优化后
SELECT * FROM orders
WHERE create_time >= '2024-01-15 00:00:00'
AND create_time < '2024-01-16 00:00:00'
AND status IN (1,2,3);

-- 添加索引
CREATE INDEX idx_status_time ON orders(status, create_time);

-- ========== 4. 子查询优化 ==========

-- 原始：IN子查询
SELECT * FROM orders
WHERE user_id IN (SELECT id FROM users WHERE vip_level > 3);

-- 优化：改为JOIN
SELECT o.* FROM orders o
INNER JOIN users u ON o.user_id = u.id
WHERE u.vip_level > 3;

-- ========== 5. 分页优化 ==========

-- 原始：大偏移量分页很慢
SELECT * FROM orders ORDER BY id LIMIT 1000000, 10;

-- 优化：利用索引延迟关联
SELECT * FROM orders o
INNER JOIN (SELECT id FROM orders ORDER BY id LIMIT 1000000, 10) tmp
ON o.id = tmp.id;

-- 或使用游标分页
SELECT * FROM orders WHERE id > 1000000 ORDER BY id LIMIT 10;
```

---

### 133. Explain执行计划怎么看？

```
┌─────────────────────────────────────────────────────────────────────────┐
│                        EXPLAIN 执行计划详解                              │
├─────────────────────────────────────────────────────────────────────────┤
│                                                                         │
│  EXPLAIN SELECT * FROM t1 JOIN t2 ON t1.id = t2.t1_id WHERE t1.x = 1;  │
│                                                                         │
│  ┌────────────────────────────────────────────────────────────────────┐ │
│  │ id │select_type│ table│type│possible_keys│ key │key_len│ref│rows│Ex│ │
│  │────────────────────────────────────────────────────────────────────│ │
│  │  1 │ SIMPLE    │ t1   │ref │idx_x        │idx_x│  4    │const│10│   │ │
│  │  1 │ SIMPLE    │ t2   │ref │idx_t1_id    │idx_t│  8    │t1.id│5 │   │ │
│  └────────────────────────────────────────────────────────────────────┘ │
│                                                                         │
│  ═══════════════════════════════════════════════════════════════════   │
│                                                                         │
│  ┌──────────────── 关键字段详解 ────────────────────┐                   │
│  │                                                  │                   │
│  │  【id】执行顺序                                   │                   │
│  │   • id相同: 从上往下执行                         │                   │
│  │   • id不同: id大的先执行                         │                   │
│  │                                                  │                   │
│  │  【select_type】查询类型                          │                   │
│  │   • SIMPLE: 简单查询                            │                   │
│  │   • PRIMARY: 最外层查询                         │                   │
│  │   • SUBQUERY: 子查询                            │                   │
│  │   • DERIVED: 派生表(FROM中的子查询)              │                   │
│  │   • UNION: UNION中的第二个及后面的查询           │                   │
│  │                                                  │                   │
│  └──────────────────────────────────────────────────┘                   │
│                                                                         │
│  ┌──────────────── type(访问类型) ─ 重要! ──────────┐                   │
│  │                                                  │                   │
│  │   性能从好到差:                                   │                   │
│  │                                                  │                   │
│  │   system > const > eq_ref > ref > range >        │                   │
│  │   index > ALL                                    │                   │
│  │                                                  │                   │
│  │   ┌────────────────────────────────────────────┐ │                   │
│  │   │ system │ 表只有一行(系统表)                 │ │                   │
│  │   │ const  │ 主键或唯一索引等值查询             │ │                   │
│  │   │ eq_ref │ 主键或唯一索引JOIN                 │ │                   │
│  │   │ ref    │ 非唯一索引等值查询                 │ │                   │
│  │   │ range  │ 索引范围扫描(>,<,BETWEEN,IN)       │ │                   │
│  │   │ index  │ 全索引扫描(覆盖索引)               │ │                   │
│  │   │ ALL    │ 全表扫描 ← 需要优化!              │ │                   │
│  │   └────────────────────────────────────────────┘ │                   │
│  │                                                  │                   │
│  │   目标: 至少达到 range 级别,最好是 ref 或以上    │                   │
│  │                                                  │                   │
│  └──────────────────────────────────────────────────┘                   │
│                                                                         │
│  ┌──────────────── Extra(额外信息) ─ 重要! ─────────┐                   │
│  │                                                  │                   │
│  │   ✓ 好的信息:                                    │                   │
│  │   • Using index: 覆盖索引，无需回表              │                   │
│  │   • Using index condition: 索引下推(ICP)         │                   │
│  │   • Using where: Server层过滤                   │                   │
│  │                                                  │                   │
│  │   ✗ 需要优化:                                    │                   │
│  │   • Using filesort: 额外排序，没用索引排序       │                   │
│  │   • Using temporary: 使用临时表                  │                   │
│  │   • Using join buffer: JOIN没用索引             │                   │
│  │                                                  │                   │
│  └──────────────────────────────────────────────────┘                   │
│                                                                         │
│  ┌──────────────── 其他重要字段 ────────────────────┐                   │
│  │                                                  │                   │
│  │  【possible_keys】可能使用的索引                  │                   │
│  │  【key】实际使用的索引                           │                   │
│  │  【key_len】索引使用的字节数(越短越好)            │                   │
│  │  【ref】与索引比较的列或常量                      │                   │
│  │  【rows】预估扫描的行数(越少越好)                 │                   │
│  │  【filtered】存储引擎返回数据后Server层过滤比例   │                   │
│  │                                                  │                   │
│  └──────────────────────────────────────────────────┘                   │
│                                                                         │
└─────────────────────────────────────────────────────────────────────────┘
```

```sql
-- 查看更详细的执行计划
EXPLAIN FORMAT=JSON SELECT ...;

-- MySQL 8.0+ 查看实际执行情况
EXPLAIN ANALYZE SELECT ...;

-- 实战分析示例
EXPLAIN SELECT o.*, u.name
FROM orders o
LEFT JOIN users u ON o.user_id = u.id
WHERE o.status = 1
AND o.create_time > '2024-01-01'
ORDER BY o.create_time DESC
LIMIT 10;

-- 分析结果关注点:
-- 1. type是否为ALL(全表扫描)?
-- 2. key是否为NULL(没用索引)?
-- 3. rows数值是否过大?
-- 4. Extra是否有filesort/temporary?
```

---

## 5.2 事务与锁（8题）

### 134. MySQL事务隔离级别有哪些？

```
┌─────────────────────────────────────────────────────────────────────────┐
│                        MySQL 事务隔离级别                                │
├─────────────────────────────────────────────────────────────────────────┤
│                                                                         │
│  ┌────────────────────── 四种隔离级别 ──────────────────────┐           │
│  │                                                          │           │
│  │   隔离级别          │ 脏读 │ 不可重复读 │ 幻读           │           │
│  │   ─────────────────────────────────────────────────────  │           │
│  │   READ UNCOMMITTED  │  ✓   │     ✓      │   ✓           │           │
│  │   (读未提交)        │      │            │               │           │
│  │   ─────────────────────────────────────────────────────  │           │
│  │   READ COMMITTED    │  ✗   │     ✓      │   ✓           │           │
│  │   (读已提交) [Oracle默认]  │            │               │           │
│  │   ─────────────────────────────────────────────────────  │           │
│  │   REPEATABLE READ   │  ✗   │     ✗      │   ✓*          │           │
│  │   (可重复读) [MySQL默认]   │            │  *MVCC解决     │           │
│  │   ─────────────────────────────────────────────────────  │           │
│  │   SERIALIZABLE      │  ✗   │     ✗      │   ✗           │           │
│  │   (串行化)          │      │            │               │           │
│  │                                                          │           │
│  └──────────────────────────────────────────────────────────┘           │
│                                                                         │
│  ═══════════════════════════════════════════════════════════════════   │
│                                                                         │
│  ┌────────────────────── 问题演示 ────────────────────────┐             │
│  │                                                        │             │
│  │  【脏读】读取到其他事务未提交的数据                      │             │
│  │                                                        │             │
│  │   事务A                    事务B                       │             │
│  │   ──────                   ──────                      │             │
│  │   BEGIN;                                               │             │
│  │   UPDATE SET x=200;                                    │             │
│  │                            BEGIN;                      │             │
│  │                            SELECT x; → 200 (脏数据!)   │             │
│  │   ROLLBACK;                                            │             │
│  │                            SELECT x; → 100 (原值)      │             │
│  │                                                        │             │
│  └────────────────────────────────────────────────────────┘             │
│                                                                         │
│  ┌────────────────────── 问题演示 ────────────────────────┐             │
│  │                                                        │             │
│  │  【不可重复读】同一事务内多次读取同一数据结果不同         │             │
│  │                                                        │             │
│  │   事务A                    事务B                       │             │
│  │   ──────                   ──────                      │             │
│  │   BEGIN;                                               │             │
│  │   SELECT x; → 100                                      │             │
│  │                            BEGIN;                      │             │
│  │                            UPDATE SET x=200;           │             │
│  │                            COMMIT;                     │             │
│  │   SELECT x; → 200 (不一致!)                            │             │
│  │                                                        │             │
│  └────────────────────────────────────────────────────────┘             │
│                                                                         │
│  ┌────────────────────── 问题演示 ────────────────────────┐             │
│  │                                                        │             │
│  │  【幻读】同一事务内多次查询记录数不同                    │             │
│  │                                                        │             │
│  │   事务A                    事务B                       │             │
│  │   ──────                   ──────                      │             │
│  │   BEGIN;                                               │             │
│  │   SELECT COUNT(*) → 10                                 │             │
│  │                            BEGIN;                      │             │
│  │                            INSERT INTO t VALUES(...);  │             │
│  │                            COMMIT;                     │             │
│  │   SELECT COUNT(*) → 11 (多了一条!)                     │             │
│  │                                                        │             │
│  └────────────────────────────────────────────────────────┘             │
│                                                                         │
└─────────────────────────────────────────────────────────────────────────┘
```

```sql
-- 查看当前隔离级别
SELECT @@transaction_isolation;
-- 或 (MySQL 5.7)
SELECT @@tx_isolation;

-- 设置隔离级别
SET SESSION TRANSACTION ISOLATION LEVEL READ COMMITTED;
SET SESSION TRANSACTION ISOLATION LEVEL REPEATABLE READ;

-- 全局设置
SET GLOBAL TRANSACTION ISOLATION LEVEL REPEATABLE READ;
```

---

### 135. MVCC的原理是什么？

```
┌─────────────────────────────────────────────────────────────────────────┐
│                   MVCC (多版本并发控制) 原理                              │
├─────────────────────────────────────────────────────────────────────────┤
│                                                                         │
│  ┌─────────────────── MVCC核心组件 ────────────────────┐                │
│  │                                                      │                │
│  │  ┌─────────────────────────────────────────────────┐ │                │
│  │  │           隐藏列 (每行数据都有)                   │ │                │
│  │  │                                                 │ │                │
│  │  │  ┌────────────────────────────────────────────┐ │ │                │
│  │  │  │ id │ name │ DB_TRX_ID │ DB_ROLL_PTR │ ... │ │ │                │
│  │  │  └────────────────────────────────────────────┘ │ │                │
│  │  │                    ↑              ↑             │ │                │
│  │  │              最近修改的      指向undo log        │ │                │
│  │  │              事务ID        的版本链              │ │                │
│  │  │                                                 │ │                │
│  │  └─────────────────────────────────────────────────┘ │                │
│  │                                                      │                │
│  │  ┌─────────────────────────────────────────────────┐ │                │
│  │  │           Undo Log 版本链                        │ │                │
│  │  │                                                 │ │                │
│  │  │   当前版本                                       │ │                │
│  │  │   ┌────────────────┐                            │ │                │
│  │  │   │ name='李四'    │                            │ │                │
│  │  │   │ trx_id=102     │                            │ │                │
│  │  │   │ roll_ptr ──────┼───┐                        │ │                │
│  │  │   └────────────────┘   │                        │ │                │
│  │  │                        ↓                        │ │                │
│  │  │   ┌────────────────┐                            │ │                │
│  │  │   │ name='张三'    │ ← 上一版本                  │ │                │
│  │  │   │ trx_id=101     │                            │ │                │
│  │  │   │ roll_ptr ──────┼───┐                        │ │                │
│  │  │   └────────────────┘   │                        │ │                │
│  │  │                        ↓                        │ │                │
│  │  │   ┌────────────────┐                            │ │                │
│  │  │   │ name='王五'    │ ← 更早版本                  │ │                │
│  │  │   │ trx_id=100     │                            │ │                │
│  │  │   │ roll_ptr=NULL  │                            │ │                │
│  │  │   └────────────────┘                            │ │                │
│  │  │                                                 │ │                │
│  │  └─────────────────────────────────────────────────┘ │                │
│  │                                                      │                │
│  │  ┌─────────────────────────────────────────────────┐ │                │
│  │  │           ReadView (读视图)                      │ │                │
│  │  │                                                 │ │                │
│  │  │   创建时机:                                      │ │                │
│  │  │   • RC: 每次SELECT都创建新的ReadView            │ │                │
│  │  │   • RR: 事务开始时创建，整个事务复用             │ │                │
│  │  │                                                 │ │                │
│  │  │   ReadView内容:                                 │ │                │
│  │  │   ┌───────────────────────────────────────────┐ │ │                │
│  │  │   │ creator_trx_id: 100  (创建者事务ID)       │ │ │                │
│  │  │   │ m_ids: [101, 102]    (活跃事务ID列表)     │ │ │                │
│  │  │   │ min_trx_id: 101      (活跃事务最小ID)     │ │ │                │
│  │  │   │ max_trx_id: 103      (下一个分配的事务ID)  │ │ │                │
│  │  │   └───────────────────────────────────────────┘ │ │                │
│  │  │                                                 │ │                │
│  │  └─────────────────────────────────────────────────┘ │                │
│  │                                                      │                │
│  └──────────────────────────────────────────────────────┘                │
│                                                                         │
│  ┌─────────────────── 可见性判断规则 ──────────────────┐                 │
│  │                                                     │                 │
│  │  对于版本的 trx_id:                                  │                 │
│  │                                                     │                 │
│  │  1. trx_id == creator_trx_id                        │                 │
│  │     → 自己修改的，可见 ✓                             │                 │
│  │                                                     │                 │
│  │  2. trx_id < min_trx_id                             │                 │
│  │     → 事务已提交，可见 ✓                             │                 │
│  │                                                     │                 │
│  │  3. trx_id >= max_trx_id                            │                 │
│  │     → 事务在ReadView创建后开始，不可见 ✗             │                 │
│  │                                                     │                 │
│  │  4. min_trx_id <= trx_id < max_trx_id               │                 │
│  │     → 如果trx_id在m_ids中，不可见 ✗                  │                 │
│  │     → 如果trx_id不在m_ids中，已提交，可见 ✓          │                 │
│  │                                                     │                 │
│  │  如果当前版本不可见，沿版本链找更早版本              │                 │
│  │                                                     │                 │
│  └─────────────────────────────────────────────────────┘                 │
│                                                                         │
└─────────────────────────────────────────────────────────────────────────┘
```

```java
/**
 * MVCC可见性判断算法
 */
public class MvccVisibility {

    static class ReadView {
        long creatorTrxId;      // 创建该ReadView的事务ID
        List<Long> mIds;        // 活跃事务ID列表
        long minTrxId;          // 活跃事务最小ID
        long maxTrxId;          // 下一个将分配的事务ID
    }

    /**
     * 判断某个版本是否对当前ReadView可见
     */
    public boolean isVisible(long trxId, ReadView readView) {
        // 1. 是当前事务自己的修改
        if (trxId == readView.creatorTrxId) {
            return true;
        }

        // 2. 事务ID小于最小活跃ID，说明该事务已提交
        if (trxId < readView.minTrxId) {
            return true;
        }

        // 3. 事务ID大于等于下一个分配ID，说明是之后开始的事务
        if (trxId >= readView.maxTrxId) {
            return false;
        }

        // 4. 在活跃事务范围内，判断是否在活跃列表中
        // 在列表中 = 未提交 = 不可见
        // 不在列表中 = 已提交 = 可见
        return !readView.mIds.contains(trxId);
    }

    /**
     * 获取可见版本
     */
    public Object getVisibleVersion(Object currentVersion, ReadView readView) {
        Object version = currentVersion;

        while (version != null) {
            long trxId = getTrxId(version);

            if (isVisible(trxId, readView)) {
                return version;  // 找到可见版本
            }

            // 沿版本链继续往前找
            version = getPreviousVersion(version);
        }

        return null;  // 没有可见版本
    }

    private long getTrxId(Object version) { return 0; }
    private Object getPreviousVersion(Object version) { return null; }
}
```

---

### 136. 什么是当前读和快照读？

```
┌─────────────────────────────────────────────────────────────────────────┐
│                        当前读 vs 快照读                                  │
├─────────────────────────────────────────────────────────────────────────┤
│                                                                         │
│  ┌────────────────────── 快照读 ──────────────────────┐                 │
│  │                                                    │                 │
│  │  定义: 读取数据的历史版本(MVCC机制)                 │                 │
│  │                                                    │                 │
│  │  SQL语句:                                          │                 │
│  │  • SELECT ... (普通SELECT)                         │                 │
│  │                                                    │                 │
│  │  特点:                                             │                 │
│  │  • 不加锁，读取历史快照                            │                 │
│  │  • 通过ReadView + undo log版本链实现               │                 │
│  │  • 不会阻塞其他事务的写操作                        │                 │
│  │  • 可能读到旧数据                                  │                 │
│  │                                                    │                 │
│  │  ┌───────────────────────────────────────────────┐ │                 │
│  │  │  事务A (RR级别)           事务B               │ │                 │
│  │  │  BEGIN;                                       │ │                 │
│  │  │  SELECT x; → 100          BEGIN;             │ │                 │
│  │  │  (创建ReadView)           UPDATE SET x=200;  │ │                 │
│  │  │                           COMMIT;            │ │                 │
│  │  │  SELECT x; → 100 (仍是100!)                   │ │                 │
│  │  │  (复用ReadView，读历史版本)                    │ │                 │
│  │  └───────────────────────────────────────────────┘ │                 │
│  │                                                    │                 │
│  └────────────────────────────────────────────────────┘                 │
│                                                                         │
│  ┌────────────────────── 当前读 ──────────────────────┐                 │
│  │                                                    │                 │
│  │  定义: 读取数据的最新版本，并加锁                   │                 │
│  │                                                    │                 │
│  │  SQL语句:                                          │                 │
│  │  • SELECT ... FOR UPDATE     (排他锁X锁)          │                 │
│  │  • SELECT ... FOR SHARE      (共享锁S锁)          │                 │
│  │  • SELECT ... LOCK IN SHARE MODE (MySQL 5.7)      │                 │
│  │  • UPDATE ...                                      │                 │
│  │  • DELETE ...                                      │                 │
│  │  • INSERT ...                                      │                 │
│  │                                                    │                 │
│  │  特点:                                             │                 │
│  │  • 需要加锁，读取最新数据                          │                 │
│  │  • 会阻塞其他事务的写操作(或被阻塞)                │                 │
│  │  • 保证数据一致性                                  │                 │
│  │                                                    │                 │
│  │  ┌───────────────────────────────────────────────┐ │                 │
│  │  │  事务A                    事务B               │ │                 │
│  │  │  BEGIN;                   BEGIN;             │ │                 │
│  │  │  SELECT x FOR UPDATE;                         │ │                 │
│  │  │  → 100 (加X锁)                                │ │                 │
│  │  │                           UPDATE SET x=200;  │ │                 │
│  │  │                           → 等待(被A的锁阻塞) │ │                 │
│  │  │  UPDATE SET x=150;                            │ │                 │
│  │  │  COMMIT;                                      │ │                 │
│  │  │                           → 执行成功          │ │                 │
│  │  └───────────────────────────────────────────────┘ │                 │
│  │                                                    │                 │
│  └────────────────────────────────────────────────────┘                 │
│                                                                         │
│  ┌────────────────────── 对比总结 ─────────────────────┐                │
│  │                                                     │                │
│  │  特性        │  快照读            │  当前读          │                │
│  │  ─────────────────────────────────────────────────  │                │
│  │  读取版本    │  历史版本          │  最新版本        │                │
│  │  加锁        │  不加锁            │  加锁(S/X)       │                │
│  │  阻塞        │  不阻塞            │  可能阻塞        │                │
│  │  使用场景    │  普通查询          │  需要最新数据时  │                │
│  │  实现机制    │  MVCC              │  锁机制          │                │
│  │                                                     │                │
│  └─────────────────────────────────────────────────────┘                │
│                                                                         │
└─────────────────────────────────────────────────────────────────────────┘
```

```sql
-- 快照读示例
BEGIN;
SELECT * FROM account WHERE id = 1;  -- 快照读，不加锁

-- 当前读示例
BEGIN;
SELECT * FROM account WHERE id = 1 FOR UPDATE;  -- 当前读，加X锁
SELECT * FROM account WHERE id = 1 FOR SHARE;   -- 当前读，加S锁

-- 写操作都是当前读
UPDATE account SET balance = balance - 100 WHERE id = 1;  -- 当前读+写
DELETE FROM account WHERE id = 1;  -- 当前读

-- 实际应用场景
-- 扣减库存时必须用当前读，确保读到最新值
BEGIN;
SELECT stock FROM products WHERE id = 1 FOR UPDATE;
-- 如果 stock > 0
UPDATE products SET stock = stock - 1 WHERE id = 1;
COMMIT;
```

---

### 137. MySQL的锁类型有哪些？

```
┌─────────────────────────────────────────────────────────────────────────┐
│                          MySQL 锁类型全景                                │
├─────────────────────────────────────────────────────────────────────────┤
│                                                                         │
│  ┌─────────────────────────────────────────────────────────────────┐   │
│  │                        按锁粒度分类                              │   │
│  │                                                                  │   │
│  │   ┌─────────────────────────────────────────────────────────┐   │   │
│  │   │                     全局锁                               │   │   │
│  │   │   FLUSH TABLES WITH READ LOCK;                          │   │   │
│  │   │   • 整个数据库只读                                       │   │   │
│  │   │   • 用于全库逻辑备份                                     │   │   │
│  │   └─────────────────────────────────────────────────────────┘   │   │
│  │                           ↓                                      │   │
│  │   ┌─────────────────────────────────────────────────────────┐   │   │
│  │   │                     表级锁                               │   │   │
│  │   │   • 表锁: LOCK TABLES t READ/WRITE                      │   │   │
│  │   │   • 元数据锁(MDL): DDL操作时自动加                       │   │   │
│  │   │   • 意向锁: IS(意向共享锁), IX(意向排他锁)               │   │   │
│  │   │   • AUTO-INC锁: 自增主键                                │   │   │
│  │   └─────────────────────────────────────────────────────────┘   │   │
│  │                           ↓                                      │   │
│  │   ┌─────────────────────────────────────────────────────────┐   │   │
│  │   │                     行级锁 (InnoDB)                       │   │   │
│  │   │   • 记录锁(Record Lock): 锁定单行                        │   │   │
│  │   │   • 间隙锁(Gap Lock): 锁定范围间隙                       │   │   │
│  │   │   • 临键锁(Next-Key Lock): 记录锁+间隙锁                 │   │   │
│  │   └─────────────────────────────────────────────────────────┘   │   │
│  │                                                                  │   │
│  └─────────────────────────────────────────────────────────────────┘   │
│                                                                         │
│  ┌─────────────────────────────────────────────────────────────────┐   │
│  │                        按锁模式分类                              │   │
│  │                                                                  │   │
│  │   ┌─────────────────────────────────────────────────────────┐   │   │
│  │   │  共享锁(S锁/读锁)         排他锁(X锁/写锁)               │   │   │
│  │   │  ────────────────         ────────────────               │   │   │
│  │   │  SELECT ... FOR SHARE     SELECT ... FOR UPDATE         │   │   │
│  │   │                           UPDATE / DELETE / INSERT      │   │   │
│  │   │                                                         │   │   │
│  │   │         S锁    X锁                                      │   │   │
│  │   │  S锁    兼容   冲突                                     │   │   │
│  │   │  X锁    冲突   冲突                                     │   │   │
│  │   └─────────────────────────────────────────────────────────┘   │   │
│  │                                                                  │   │
│  └─────────────────────────────────────────────────────────────────┘   │
│                                                                         │
│  ┌─────────────────── 行锁类型详解 (InnoDB RR级别) ─────────────────┐   │
│  │                                                                  │   │
│  │  假设索引: id = [1, 5, 10, 15, 20]                              │   │
│  │                                                                  │   │
│  │  ┌───────────────────────────────────────────────────────────┐  │   │
│  │  │  记录锁 (Record Lock)                                     │  │   │
│  │  │                                                           │  │   │
│  │  │  SELECT * FROM t WHERE id = 10 FOR UPDATE;               │  │   │
│  │  │                                                           │  │   │
│  │  │  (-∞)  (1)  (5)  [10]  (15)  (20)  (+∞)                   │  │   │
│  │  │                   ↑                                       │  │   │
│  │  │              锁定id=10这一行                               │  │   │
│  │  │                                                           │  │   │
│  │  └───────────────────────────────────────────────────────────┘  │   │
│  │                                                                  │   │
│  │  ┌───────────────────────────────────────────────────────────┐  │   │
│  │  │  间隙锁 (Gap Lock)                                        │  │   │
│  │  │                                                           │  │   │
│  │  │  SELECT * FROM t WHERE id = 8 FOR UPDATE; (id=8不存在)   │  │   │
│  │  │                                                           │  │   │
│  │  │  (-∞)  (1)  (5) ((((((( (10)  (15)  (20)  (+∞)             │  │   │
│  │  │              ↑─────────↑                                  │  │   │
│  │  │           锁定(5,10)区间，阻止插入id=6,7,8,9               │  │   │
│  │  │                                                           │  │   │
│  │  └───────────────────────────────────────────────────────────┘  │   │
│  │                                                                  │   │
│  │  ┌───────────────────────────────────────────────────────────┐  │   │
│  │  │  临键锁 (Next-Key Lock) = 记录锁 + 间隙锁                  │  │   │
│  │  │                                                           │  │   │
│  │  │  SELECT * FROM t WHERE id >= 10 FOR UPDATE;              │  │   │
│  │  │                                                           │  │   │
│  │  │  (-∞)  (1)  (5) ((((((([10]((((([15](((((([20]((((((((+∞)  │  │   │
│  │  │              ↑─────────↑──────────↑──────────↑─────────↑   │  │   │
│  │  │           锁定(5,10], (10,15], (15,20], (20,+∞)          │  │   │
│  │  │                                                           │  │   │
│  │  └───────────────────────────────────────────────────────────┘  │   │
│  │                                                                  │   │
│  └──────────────────────────────────────────────────────────────────┘   │
│                                                                         │
└─────────────────────────────────────────────────────────────────────────┘
```

```sql
-- 查看当前锁情况
SELECT * FROM performance_schema.data_locks;
SELECT * FROM performance_schema.data_lock_waits;

-- MySQL 5.7
SELECT * FROM information_schema.innodb_locks;
SELECT * FROM information_schema.innodb_lock_waits;

-- 意向锁示例
-- 当事务要给行加S锁时，先给表加IS锁
-- 当事务要给行加X锁时，先给表加IX锁
-- 这样判断能否加表锁时只需检查意向锁，不用逐行检查

-- 意向锁兼容性
--      IS    IX    S    X
-- IS   兼容  兼容  兼容  冲突
-- IX   兼容  兼容  冲突  冲突
-- S    兼容  冲突  兼容  冲突
-- X    冲突  冲突  冲突  冲突
```

---

### 138. 什么是间隙锁？作用是什么？

```
┌─────────────────────────────────────────────────────────────────────────┐
│                         间隙锁 (Gap Lock) 详解                           │
├─────────────────────────────────────────────────────────────────────────┤
│                                                                         │
│  ┌─────────────────────── 间隙锁的作用 ──────────────────────┐          │
│  │                                                           │          │
│  │   核心目的: 解决幻读问题                                   │          │
│  │                                                           │          │
│  │   在RR(可重复读)隔离级别下:                                │          │
│  │   • 快照读: 通过MVCC解决幻读                              │          │
│  │   • 当前读: 通过间隙锁/临键锁解决幻读                      │          │
│  │                                                           │          │
│  └───────────────────────────────────────────────────────────┘          │
│                                                                         │
│  ┌─────────────────────── 间隙锁工作原理 ────────────────────┐          │
│  │                                                           │          │
│  │   表数据: id = [5, 10, 15]                                │          │
│  │                                                           │          │
│  │   记录间的"间隙":                                         │          │
│  │   (-∞, 5), (5, 10), (10, 15), (15, +∞)                   │          │
│  │                                                           │          │
│  │   ┌─────────────────────────────────────────────────────┐ │          │
│  │   │                                                     │ │          │
│  │   │    事务A                     事务B                  │ │          │
│  │   │    ──────                    ──────                 │ │          │
│  │   │    BEGIN;                                           │ │          │
│  │   │    SELECT * FROM t                                  │ │          │
│  │   │    WHERE id > 10 AND id < 15                        │ │          │
│  │   │    FOR UPDATE;                                      │ │          │
│  │   │    -- 锁定间隙(10, 15)                              │ │          │
│  │   │                              BEGIN;                 │ │          │
│  │   │                              INSERT INTO t(id)      │ │          │
│  │   │                              VALUES(12);            │ │          │
│  │   │                              -- 等待! 被间隙锁阻塞   │ │          │
│  │   │    COMMIT;                                          │ │          │
│  │   │                              -- 插入成功            │ │          │
│  │   │                                                     │ │          │
│  │   └─────────────────────────────────────────────────────┘ │          │
│  │                                                           │          │
│  └───────────────────────────────────────────────────────────┘          │
│                                                                         │
│  ┌─────────────────────── 间隙锁加锁规则 ────────────────────┐          │
│  │                                                           │          │
│  │   数据: id = [1, 5, 10, 15, 20]  (id是主键)               │          │
│  │                                                           │          │
│  │   ┌─────────────────────────────────────────────────────┐ │          │
│  │   │  场景1: 等值查询存在的记录                           │ │          │
│  │   │                                                     │ │          │
│  │   │  SELECT * FROM t WHERE id = 10 FOR UPDATE;         │ │          │
│  │   │                                                     │ │          │
│  │   │  唯一索引: 只加记录锁，不加间隙锁                    │ │          │
│  │   │  非唯一索引: 加临键锁 (间隙锁+记录锁)               │ │          │
│  │   │                                                     │ │          │
│  │   └─────────────────────────────────────────────────────┘ │          │
│  │                                                           │          │
│  │   ┌─────────────────────────────────────────────────────┐ │          │
│  │   │  场景2: 等值查询不存在的记录                         │ │          │
│  │   │                                                     │ │          │
│  │   │  SELECT * FROM t WHERE id = 8 FOR UPDATE;          │ │          │
│  │   │                                                     │ │          │
│  │   │  加间隙锁: (5, 10)                                  │ │          │
│  │   │  阻止在此区间插入新记录                             │ │          │
│  │   │                                                     │ │          │
│  │   └─────────────────────────────────────────────────────┘ │          │
│  │                                                           │          │
│  │   ┌─────────────────────────────────────────────────────┐ │          │
│  │   │  场景3: 范围查询                                     │ │          │
│  │   │                                                     │ │          │
│  │   │  SELECT * FROM t WHERE id >= 10 AND id < 15        │ │          │
│  │   │  FOR UPDATE;                                        │ │          │
│  │   │                                                     │ │          │
│  │   │  加临键锁: (5, 10], (10, 15)                        │ │          │
│  │   │                                                     │ │          │
│  │   └─────────────────────────────────────────────────────┘ │          │
│  │                                                           │          │
│  └───────────────────────────────────────────────────────────┘          │
│                                                                         │
│  ┌─────────────────────── 间隙锁的特点 ──────────────────────┐          │
│  │                                                           │          │
│  │   1. 间隙锁之间不冲突，只阻止INSERT                       │          │
│  │   2. 只在RR级别下存在，RC级别没有间隙锁                   │          │
│  │   3. 可能导致死锁(两个事务互相等待对方的间隙)              │          │
│  │                                                           │          │
│  └───────────────────────────────────────────────────────────┘          │
│                                                                         │
└─────────────────────────────────────────────────────────────────────────┘
```

---

### 139. 死锁如何产生？如何解决？

```
┌─────────────────────────────────────────────────────────────────────────┐
│                          死锁产生与解决                                   │
├─────────────────────────────────────────────────────────────────────────┤
│                                                                         │
│  ┌────────────────────── 死锁产生条件 ──────────────────────┐           │
│  │                                                          │           │
│  │   四个必要条件 (同时满足才会死锁):                         │           │
│  │                                                          │           │
│  │   1. 互斥: 资源只能被一个事务持有                         │           │
│  │   2. 占有且等待: 持有资源的同时等待其他资源                │           │
│  │   3. 不可剥夺: 已获得的资源不能被强行剥夺                  │           │
│  │   4. 循环等待: 事务之间形成环形等待链                      │           │
│  │                                                          │           │
│  └──────────────────────────────────────────────────────────┘           │
│                                                                         │
│  ┌────────────────────── 死锁场景示例 ──────────────────────┐           │
│  │                                                          │           │
│  │   场景1: 交叉更新不同行                                   │           │
│  │   ┌───────────────────────────────────────────────────┐  │           │
│  │   │                                                   │  │           │
│  │   │   事务A                    事务B                  │  │           │
│  │   │   ──────                   ──────                 │  │           │
│  │   │   BEGIN;                   BEGIN;                 │  │           │
│  │   │   UPDATE t SET x=1                                │  │           │
│  │   │   WHERE id=1; ✓获得锁                             │  │           │
│  │   │                            UPDATE t SET x=2       │  │           │
│  │   │                            WHERE id=2; ✓获得锁    │  │           │
│  │   │   UPDATE t SET x=1                                │  │           │
│  │   │   WHERE id=2; ⏳等待B                              │  │           │
│  │   │                            UPDATE t SET x=2       │  │           │
│  │   │                            WHERE id=1; ⏳等待A     │  │           │
│  │   │                                                   │  │           │
│  │   │               💀 死锁!                             │  │           │
│  │   │                                                   │  │           │
│  │   │   事务A持有id=1的锁，等待id=2                      │  │           │
│  │   │   事务B持有id=2的锁，等待id=1                      │  │           │
│  │   │                                                   │  │           │
│  │   └───────────────────────────────────────────────────┘  │           │
│  │                                                          │           │
│  │   场景2: 间隙锁导致死锁                                   │           │
│  │   ┌───────────────────────────────────────────────────┐  │           │
│  │   │                                                   │  │           │
│  │   │   表数据: id = [5, 10, 15]                        │  │           │
│  │   │                                                   │  │           │
│  │   │   事务A                    事务B                  │  │           │
│  │   │   ──────                   ──────                 │  │           │
│  │   │   SELECT * FROM t                                 │  │           │
│  │   │   WHERE id=8 FOR UPDATE;                         │  │           │
│  │   │   (获取间隙锁(5,10))                              │  │           │
│  │   │                            SELECT * FROM t        │  │           │
│  │   │                            WHERE id=7 FOR UPDATE; │  │           │
│  │   │                            (也获取间隙锁(5,10))   │  │           │
│  │   │   INSERT(id=6);                                   │  │           │
│  │   │   ⏳等待B的间隙锁                                   │  │           │
│  │   │                            INSERT(id=9);         │  │           │
│  │   │                            ⏳等待A的间隙锁         │  │           │
│  │   │                                                   │  │           │
│  │   │               💀 死锁!                             │  │           │
│  │   │                                                   │  │           │
│  │   └───────────────────────────────────────────────────┘  │           │
│  │                                                          │           │
│  └──────────────────────────────────────────────────────────┘           │
│                                                                         │
│  ┌────────────────────── 解决方案 ──────────────────────────┐           │
│  │                                                          │           │
│  │   【预防死锁】                                           │           │
│  │   1. 固定顺序访问资源                                    │           │
│  │      按id从小到大顺序更新，避免交叉                       │           │
│  │                                                          │           │
│  │   2. 减少锁的持有时间                                    │           │
│  │      • 大事务拆小事务                                    │           │
│  │      • 避免在事务中做耗时操作                            │           │
│  │                                                          │           │
│  │   3. 降低隔离级别                                        │           │
│  │      RC级别没有间隙锁，死锁概率降低                       │           │
│  │                                                          │           │
│  │   4. 合理使用索引                                        │           │
│  │      避免全表扫描导致锁整表                               │           │
│  │                                                          │           │
│  │   【死锁检测】                                           │           │
│  │   • InnoDB默认开启死锁检测(innodb_deadlock_detect=ON)    │           │
│  │   • 检测到死锁后，回滚代价较小的事务                      │           │
│  │                                                          │           │
│  │   【超时机制】                                           │           │
│  │   • innodb_lock_wait_timeout = 50 (默认50秒)            │           │
│  │   • 等待超时后放弃                                       │           │
│  │                                                          │           │
│  └──────────────────────────────────────────────────────────┘           │
│                                                                         │
└─────────────────────────────────────────────────────────────────────────┘
```

```sql
-- 查看死锁信息
SHOW ENGINE INNODB STATUS;  -- 查看最近一次死锁

-- 查看锁等待情况
SELECT * FROM performance_schema.data_lock_waits;

-- 死锁检测配置
SHOW VARIABLES LIKE 'innodb_deadlock_detect';
SHOW VARIABLES LIKE 'innodb_lock_wait_timeout';

-- 代码层面避免死锁
-- 按固定顺序更新
public void transfer(int fromId, int toId, int amount) {
    int first = Math.min(fromId, toId);
    int second = Math.max(fromId, toId);

    // 总是先锁小id，后锁大id
    lock(first);
    lock(second);

    // 执行转账
    doTransfer(fromId, toId, amount);

    unlock(second);
    unlock(first);
}
```

---

### 140. 什么是两阶段锁协议？

```
┌─────────────────────────────────────────────────────────────────────────┐
│                         两阶段锁协议 (2PL)                               │
├─────────────────────────────────────────────────────────────────────────┤
│                                                                         │
│  ┌────────────────────── 协议定义 ──────────────────────────┐           │
│  │                                                          │           │
│  │   两阶段锁协议将事务的加锁和解锁分为两个阶段:              │           │
│  │                                                          │           │
│  │   1. 加锁阶段(Growing Phase): 只能获取锁，不能释放锁      │           │
│  │   2. 解锁阶段(Shrinking Phase): 只能释放锁，不能获取锁    │           │
│  │                                                          │           │
│  └──────────────────────────────────────────────────────────┘           │
│                                                                         │
│  ┌────────────────────── 执行过程 ──────────────────────────┐           │
│  │                                                          │           │
│  │   事务执行时间线                                          │           │
│  │   ┌───────────────────────────────────────────────────┐  │           │
│  │   │                                                   │  │           │
│  │   │   BEGIN                                           │  │           │
│  │   │     │                                             │  │           │
│  │   │     ↓  ┌────────────────────┐                     │  │           │
│  │   │        │   加锁阶段          │                     │  │           │
│  │   │        │   (Growing)        │                     │  │           │
│  │   │        │                    │                     │  │           │
│  │   │        │  UPDATE ... ← 加X锁│                     │  │           │
│  │   │        │  SELECT FOR UPDATE │                     │  │           │
│  │   │        │  INSERT ... ← 加X锁│                     │  │           │
│  │   │        │                    │                     │  │           │
│  │   │        └────────────────────┘                     │  │           │
│  │   │                │                                  │  │           │
│  │   │                ↓  Lock Point (加锁点)              │  │           │
│  │   │                                                   │  │           │
│  │   │        ┌────────────────────┐                     │  │           │
│  │   │        │   解锁阶段          │                     │  │           │
│  │   │        │   (Shrinking)      │                     │  │           │
│  │   │        │                    │                     │  │           │
│  │   │        │  COMMIT ← 释放所有锁│                     │  │           │
│  │   │        │                    │                     │  │           │
│  │   │        └────────────────────┘                     │  │           │
│  │   │                │                                  │  │           │
│  │   │                ↓                                  │  │           │
│  │   │   END                                             │  │           │
│  │   │                                                   │  │           │
│  │   └───────────────────────────────────────────────────┘  │           │
│  │                                                          │           │
│  └──────────────────────────────────────────────────────────┘           │
│                                                                         │
│  ┌────────────────────── InnoDB的实现 ─────────────────────┐            │
│  │                                                          │           │
│  │   InnoDB 使用 S2PL (严格两阶段锁):                        │           │
│  │                                                          │           │
│  │   • 所有锁在COMMIT/ROLLBACK时统一释放                     │           │
│  │   • 不会在事务中间释放任何锁                              │           │
│  │                                                          │           │
│  │   ┌───────────────────────────────────────────────────┐  │           │
│  │   │   BEGIN;                                          │  │           │
│  │   │   UPDATE t SET x=1 WHERE id=1;  -- 获取X锁         │  │           │
│  │   │   UPDATE t SET x=2 WHERE id=2;  -- 获取X锁         │  │           │
│  │   │   SELECT * FROM t WHERE id=3;   -- 快照读,不加锁   │  │           │
│  │   │   -- 此时持有id=1和id=2的X锁                       │  │           │
│  │   │   COMMIT;  -- 释放所有锁                           │  │           │
│  │   └───────────────────────────────────────────────────┘  │           │
│  │                                                          │           │
│  │   作用:                                                  │           │
│  │   • 保证事务的可串行化                                   │           │
│  │   • 避免脏读、不可重复读                                 │           │
│  │   • 但不能避免死锁                                       │           │
│  │                                                          │           │
│  └──────────────────────────────────────────────────────────┘           │
│                                                                         │
│  ┌────────────────────── 优化建议 ──────────────────────────┐           │
│  │                                                          │           │
│  │   由于锁要到COMMIT才释放，所以:                           │           │
│  │                                                          │           │
│  │   1. 将最可能造成冲突的操作放到事务最后                   │           │
│  │   2. 减少事务执行时间                                    │           │
│  │   3. 避免大事务                                          │           │
│  │                                                          │           │
│  └──────────────────────────────────────────────────────────┘           │
│                                                                         │
└─────────────────────────────────────────────────────────────────────────┘
```

---

### 141. 乐观锁在MySQL中如何实现？

```
┌─────────────────────────────────────────────────────────────────────────┐
│                         乐观锁实现方式                                   │
├─────────────────────────────────────────────────────────────────────────┤
│                                                                         │
│  ┌─────────────────── 乐观锁 vs 悲观锁 ───────────────────┐             │
│  │                                                        │             │
│  │   悲观锁: 假设会发生冲突，先加锁再操作                   │             │
│  │           SELECT ... FOR UPDATE                        │             │
│  │                                                        │             │
│  │   乐观锁: 假设不会发生冲突，提交时检查是否有冲突         │             │
│  │           通过版本号/时间戳实现                         │             │
│  │                                                        │             │
│  └────────────────────────────────────────────────────────┘             │
│                                                                         │
│  ┌─────────────────── 方式1: 版本号机制 ───────────────────┐            │
│  │                                                         │            │
│  │   表结构:                                               │            │
│  │   ┌──────────────────────────────────────────────────┐ │            │
│  │   │  CREATE TABLE stock (                            │ │            │
│  │   │    id BIGINT PRIMARY KEY,                        │ │            │
│  │   │    product_id BIGINT,                            │ │            │
│  │   │    count INT,                                    │ │            │
│  │   │    version INT DEFAULT 0   ← 版本号字段           │ │            │
│  │   │  );                                              │ │            │
│  │   └──────────────────────────────────────────────────┘ │            │
│  │                                                         │            │
│  │   操作流程:                                             │            │
│  │   ┌──────────────────────────────────────────────────┐ │            │
│  │   │  1. 查询数据，获取版本号                          │ │            │
│  │   │     SELECT id, count, version                    │ │            │
│  │   │     FROM stock WHERE product_id = 100;           │ │            │
│  │   │     -- 结果: count=50, version=1                 │ │            │
│  │   │                                                  │ │            │
│  │   │  2. 更新时带上版本号                              │ │            │
│  │   │     UPDATE stock                                 │ │            │
│  │   │     SET count = count - 1,                       │ │            │
│  │   │         version = version + 1                    │ │            │
│  │   │     WHERE product_id = 100                       │ │            │
│  │   │     AND version = 1;   ← 版本号必须匹配           │ │            │
│  │   │                                                  │ │            │
│  │   │  3. 检查影响行数                                  │ │            │
│  │   │     • affected_rows = 1: 更新成功                │ │            │
│  │   │     • affected_rows = 0: 版本已变,需要重试        │ │            │
│  │   └──────────────────────────────────────────────────┘ │            │
│  │                                                         │            │
│  └─────────────────────────────────────────────────────────┘            │
│                                                                         │
│  ┌─────────────────── 方式2: CAS操作 ──────────────────────┐            │
│  │                                                         │            │
│  │   不用单独的版本号字段，直接用业务字段做CAS               │            │
│  │                                                         │            │
│  │   ┌──────────────────────────────────────────────────┐ │            │
│  │   │  -- 扣减库存                                     │ │            │
│  │   │  UPDATE stock                                    │ │            │
│  │   │  SET count = count - 1                           │ │            │
│  │   │  WHERE product_id = 100                          │ │            │
│  │   │  AND count >= 1;   ← 确保库存足够                 │ │            │
│  │   │                                                  │ │            │
│  │   │  -- 检查结果                                     │ │            │
│  │   │  IF affected_rows == 0:                         │ │            │
│  │   │      库存不足或已被其他事务修改                    │ │            │
│  │   └──────────────────────────────────────────────────┘ │            │
│  │                                                         │            │
│  └─────────────────────────────────────────────────────────┘            │
│                                                                         │
└─────────────────────────────────────────────────────────────────────────┘
```

```java
/**
 * 乐观锁的Java实现
 */
@Service
public class StockService {

    @Autowired
    private StockMapper stockMapper;

    /**
     * 方式1: 版本号实现
     */
    public boolean decreaseStockWithVersion(Long productId, int quantity) {
        // 最大重试次数
        int maxRetry = 3;
        int retry = 0;

        while (retry < maxRetry) {
            // 1. 查询当前库存和版本号
            Stock stock = stockMapper.selectByProductId(productId);
            if (stock == null || stock.getCount() < quantity) {
                return false;  // 库存不足
            }

            // 2. 尝试更新，带上版本号
            int affected = stockMapper.decreaseWithVersion(
                productId,
                quantity,
                stock.getVersion()
            );

            // 3. 检查是否成功
            if (affected > 0) {
                return true;  // 成功
            }

            // 4. 失败则重试
            retry++;
            log.info("版本冲突，重试第{}次", retry);
        }

        return false;  // 重试次数用完
    }

    /**
     * 方式2: CAS实现（更简洁）
     */
    public boolean decreaseStockWithCAS(Long productId, int quantity) {
        // 直接用条件更新
        int affected = stockMapper.decreaseWithCondition(productId, quantity);
        return affected > 0;
    }
}

// Mapper接口
@Mapper
public interface StockMapper {

    // 版本号方式
    @Update("UPDATE stock SET count = count - #{quantity}, " +
            "version = version + 1 " +
            "WHERE product_id = #{productId} " +
            "AND version = #{version} " +
            "AND count >= #{quantity}")
    int decreaseWithVersion(@Param("productId") Long productId,
                           @Param("quantity") int quantity,
                           @Param("version") int version);

    // CAS方式
    @Update("UPDATE stock SET count = count - #{quantity} " +
            "WHERE product_id = #{productId} " +
            "AND count >= #{quantity}")
    int decreaseWithCondition(@Param("productId") Long productId,
                              @Param("quantity") int quantity);
}
```

---

## 5.3 日志与主从（7题）

### 142. redo log和undo log的作用？

```
┌─────────────────────────────────────────────────────────────────────────┐
│                      redo log 与 undo log 详解                           │
├─────────────────────────────────────────────────────────────────────────┤
│                                                                         │
│  ┌─────────────────────── redo log (重做日志) ──────────────────────┐   │
│  │                                                                  │   │
│  │  作用: 保证事务的持久性 (Durability) - 崩溃恢复                   │   │
│  │                                                                  │   │
│  │  ┌────────────────────────────────────────────────────────────┐ │   │
│  │  │                     WAL机制 (Write-Ahead Logging)          │ │   │
│  │  │                                                            │ │   │
│  │  │   事务提交流程:                                            │ │   │
│  │  │                                                            │ │   │
│  │  │   ┌─────────┐    ┌─────────────┐    ┌──────────────────┐  │ │   │
│  │  │   │ UPDATE  │ →  │ 修改内存中   │ →  │ 写redo log到磁盘│  │ │   │
│  │  │   │ 操作    │    │ Buffer Pool │    │ (顺序写,很快)   │  │ │   │
│  │  │   └─────────┘    └─────────────┘    └──────────────────┘  │ │   │
│  │  │                         │                    │            │ │   │
│  │  │                         ↓                    ↓            │ │   │
│  │  │                  ┌─────────────┐      事务提交成功!        │ │   │
│  │  │                  │ 后台线程    │                          │ │   │
│  │  │                  │ 异步刷盘    │ ← 脏页刷到数据文件        │ │   │
│  │  │                  │ (随机写)   │                          │ │   │
│  │  │                  └─────────────┘                          │ │   │
│  │  │                                                            │ │   │
│  │  └────────────────────────────────────────────────────────────┘ │   │
│  │                                                                  │   │
│  │  特点:                                                          │   │
│  │  • 物理日志: 记录"在某个数据页做了什么修改"                       │   │
│  │  • 循环写入: 固定大小文件组成环形结构                            │   │
│  │  • InnoDB特有: 存储引擎层日志                                   │   │
│  │  • 顺序IO: 追加写入，性能高                                     │   │
│  │                                                                  │   │
│  │  崩溃恢复:                                                      │   │
│  │  ┌────────────────────────────────────────────────────────────┐ │   │
│  │  │  MySQL重启后:                                              │ │   │
│  │  │  1. 读取redo log                                          │ │   │
│  │  │  2. 重放已提交但未刷盘的事务 (redo)                         │ │   │
│  │  │  3. 数据恢复到崩溃前状态                                   │ │   │
│  │  └────────────────────────────────────────────────────────────┘ │   │
│  │                                                                  │   │
│  └──────────────────────────────────────────────────────────────────┘   │
│                                                                         │
│  ┌─────────────────────── undo log (回滚日志) ──────────────────────┐   │
│  │                                                                  │   │
│  │  作用: 保证事务的原子性 (Atomicity) + 实现MVCC                    │   │
│  │                                                                  │   │
│  │  ┌────────────────────────────────────────────────────────────┐ │   │
│  │  │                     作用1: 事务回滚                         │ │   │
│  │  │                                                            │ │   │
│  │  │   BEGIN;                                                   │ │   │
│  │  │   UPDATE user SET name='李四' WHERE id=1;                  │ │   │
│  │  │   -- 记录undo: (id=1, name='张三')  ← 旧值                 │ │   │
│  │  │                                                            │ │   │
│  │  │   ROLLBACK;                                                │ │   │
│  │  │   -- 根据undo log恢复: name='张三'                         │ │   │
│  │  │                                                            │ │   │
│  │  └────────────────────────────────────────────────────────────┘ │   │
│  │                                                                  │   │
│  │  ┌────────────────────────────────────────────────────────────┐ │   │
│  │  │                     作用2: MVCC多版本                       │ │   │
│  │  │                                                            │ │   │
│  │  │   当前版本                                                  │ │   │
│  │  │   ┌─────────────────┐                                      │ │   │
│  │  │   │ name='王五'     │                                      │ │   │
│  │  │   │ trx_id=103      │                                      │ │   │
│  │  │   │ roll_ptr ───────┼───┐                                  │ │   │
│  │  │   └─────────────────┘   │                                  │ │   │
│  │  │                         ↓  undo log版本链                   │ │   │
│  │  │   ┌─────────────────┐                                      │ │   │
│  │  │   │ name='李四'     │                                      │ │   │
│  │  │   │ trx_id=102      │                                      │ │   │
│  │  │   │ roll_ptr ───────┼───┐                                  │ │   │
│  │  │   └─────────────────┘   │                                  │ │   │
│  │  │                         ↓                                  │ │   │
│  │  │   ┌─────────────────┐                                      │ │   │
│  │  │   │ name='张三'     │ ← 快照读可能读到这个版本              │ │   │
│  │  │   │ trx_id=101      │                                      │ │   │
│  │  │   └─────────────────┘                                      │ │   │
│  │  │                                                            │ │   │
│  │  └────────────────────────────────────────────────────────────┘ │   │
│  │                                                                  │   │
│  │  特点:                                                          │   │
│  │  • 逻辑日志: 记录数据修改前的值(旧值)                            │   │
│  │  • 存储在共享表空间或undo表空间                                  │   │
│  │  • 需要purge线程定期清理不再需要的版本                           │   │
│  │                                                                  │   │
│  └──────────────────────────────────────────────────────────────────┘   │
│                                                                         │
│  ┌─────────────────────── 对比总结 ─────────────────────────────────┐   │
│  │                                                                  │   │
│  │   特性        │  redo log              │  undo log              │   │
│  │   ──────────────────────────────────────────────────────────────│   │
│  │   作用        │  崩溃恢复(持久性)       │  回滚+MVCC(原子性)     │   │
│  │   内容        │  物理日志(页修改)       │  逻辑日志(旧值)        │   │
│  │   写入时机    │  事务执行过程中         │  事务执行过程中        │   │
│  │   存储        │  循环覆盖写             │  保留直到不需要        │   │
│  │   所属层      │  InnoDB存储引擎         │  InnoDB存储引擎        │   │
│  │                                                                  │   │
│  └──────────────────────────────────────────────────────────────────┘   │
│                                                                         │
└─────────────────────────────────────────────────────────────────────────┘
```

---

### 143. binlog和redo log的区别？

```
┌─────────────────────────────────────────────────────────────────────────┐
│                      binlog 与 redo log 区别                             │
├─────────────────────────────────────────────────────────────────────────┤
│                                                                         │
│  ┌─────────────────────── 核心区别对比 ─────────────────────────────┐   │
│  │                                                                  │   │
│  │   特性        │  binlog                │  redo log              │   │
│  │   ──────────────────────────────────────────────────────────────│   │
│  │   所属层      │  Server层              │  InnoDB存储引擎层       │   │
│  │   日志类型    │  逻辑日志              │  物理日志               │   │
│  │   写入方式    │  追加写(不覆盖)         │  循环写(覆盖)           │   │
│  │   主要作用    │  主从复制、数据恢复     │  崩溃恢复               │   │
│  │   存储引擎    │  所有引擎              │  仅InnoDB               │   │
│  │   文件大小    │  可配置,达到后切换新文件│  固定大小循环使用        │   │
│  │                                                                  │   │
│  └──────────────────────────────────────────────────────────────────┘   │
│                                                                         │
│  ┌─────────────────────── binlog 详解 ──────────────────────────────┐   │
│  │                                                                  │   │
│  │  记录内容(三种格式):                                              │   │
│  │                                                                  │   │
│  │  ┌────────────────────────────────────────────────────────────┐ │   │
│  │  │  STATEMENT格式:                                            │ │   │
│  │  │  记录SQL语句                                               │ │   │
│  │  │  UPDATE user SET name='张三' WHERE id=1;                   │ │   │
│  │  │  优点: 日志量小                                            │ │   │
│  │  │  缺点: 某些函数可能导致主从不一致(如NOW(),RAND())           │ │   │
│  │  └────────────────────────────────────────────────────────────┘ │   │
│  │                                                                  │   │
│  │  ┌────────────────────────────────────────────────────────────┐ │   │
│  │  │  ROW格式:                                                  │ │   │
│  │  │  记录每行数据的变更                                        │ │   │
│  │  │  @1=1, @2='张三' → @1=1, @2='李四'                        │ │   │
│  │  │  优点: 数据一致性好                                        │ │   │
│  │  │  缺点: 日志量大                                            │ │   │
│  │  └────────────────────────────────────────────────────────────┘ │   │
│  │                                                                  │   │
│  │  ┌────────────────────────────────────────────────────────────┐ │   │
│  │  │  MIXED格式:                                                │ │   │
│  │  │  自动选择STATEMENT或ROW                                    │ │   │
│  │  │  一般情况用STATEMENT，特殊情况用ROW                         │ │   │
│  │  └────────────────────────────────────────────────────────────┘ │   │
│  │                                                                  │   │
│  └──────────────────────────────────────────────────────────────────┘   │
│                                                                         │
│  ┌─────────────────────── 两阶段提交 ───────────────────────────────┐   │
│  │                                                                  │   │
│  │  为什么需要两阶段提交?                                           │   │
│  │  保证 binlog 和 redo log 的一致性                                │   │
│  │                                                                  │   │
│  │  ┌────────────────────────────────────────────────────────────┐ │   │
│  │  │                                                            │ │   │
│  │  │   UPDATE user SET name='李四' WHERE id=1;                  │ │   │
│  │  │                                                            │ │   │
│  │  │   ┌─────────────────────────────────────────────────────┐ │ │   │
│  │  │   │  阶段1: Prepare                                     │ │ │   │
│  │  │   │  1. 写入redo log，状态为prepare                     │ │ │   │
│  │  │   └─────────────────────────────────────────────────────┘ │ │   │
│  │  │                        ↓                                   │ │   │
│  │  │   ┌─────────────────────────────────────────────────────┐ │ │   │
│  │  │   │  阶段2: Commit                                      │ │ │   │
│  │  │   │  2. 写入binlog                                      │ │ │   │
│  │  │   │  3. 修改redo log状态为commit                        │ │ │   │
│  │  │   └─────────────────────────────────────────────────────┘ │ │   │
│  │  │                                                            │ │   │
│  │  └────────────────────────────────────────────────────────────┘ │   │
│  │                                                                  │   │
│  │  崩溃恢复判断逻辑:                                               │   │
│  │  ┌────────────────────────────────────────────────────────────┐ │   │
│  │  │                                                            │ │   │
│  │  │  if (redo log是commit状态):                               │ │   │
│  │  │      直接提交事务                                          │ │   │
│  │  │  else if (redo log是prepare状态):                         │ │   │
│  │  │      if (binlog存在且完整):                               │ │   │
│  │  │          提交事务                                          │ │   │
│  │  │      else:                                                 │ │   │
│  │  │          回滚事务                                          │ │   │
│  │  │                                                            │ │   │
│  │  └────────────────────────────────────────────────────────────┘ │   │
│  │                                                                  │   │
│  └──────────────────────────────────────────────────────────────────┘   │
│                                                                         │
│  ┌─────────────────────── 写入流程图 ───────────────────────────────┐   │
│  │                                                                  │   │
│  │      UPDATE语句                                                  │   │
│  │          │                                                       │   │
│  │          ↓                                                       │   │
│  │   ┌─────────────┐                                               │   │
│  │   │ 执行器调用   │                                               │   │
│  │   │ InnoDB接口  │                                               │   │
│  │   └──────┬──────┘                                               │   │
│  │          │                                                       │   │
│  │          ↓                                                       │   │
│  │   ┌─────────────┐     ┌─────────────┐                           │   │
│  │   │ 写undo log  │ →   │ 修改数据页   │                           │   │
│  │   │ (记录旧值)   │     │ (Buffer Pool)│                          │   │
│  │   └─────────────┘     └──────┬──────┘                           │   │
│  │                              │                                   │   │
│  │                              ↓                                   │   │
│  │   ┌─────────────────────────────────────────────────────────┐   │   │
│  │   │ 写redo log (prepare状态) → 写binlog → redo log (commit) │   │   │
│  │   └─────────────────────────────────────────────────────────┘   │   │
│  │                              │                                   │   │
│  │                              ↓                                   │   │
│  │                       事务提交成功                                │   │
│  │                                                                  │   │
│  └──────────────────────────────────────────────────────────────────┘   │
│                                                                         │
└─────────────────────────────────────────────────────────────────────────┘
```

```sql
-- 查看binlog相关配置
SHOW VARIABLES LIKE '%binlog%';

-- binlog格式
SHOW VARIABLES LIKE 'binlog_format';
SET GLOBAL binlog_format = 'ROW';

-- 查看binlog文件列表
SHOW BINARY LOGS;

-- 查看binlog内容
SHOW BINLOG EVENTS IN 'mysql-bin.000001';

-- 使用mysqlbinlog工具解析
-- mysqlbinlog --base64-output=decode-rows -v mysql-bin.000001
```

---

### 144. MySQL如何保证数据不丢失？

```
┌─────────────────────────────────────────────────────────────────────────┐
│                       MySQL 数据不丢失保障机制                            │
├─────────────────────────────────────────────────────────────────────────┤
│                                                                         │
│  ┌─────────────────────── 核心保障机制 ─────────────────────────────┐   │
│  │                                                                  │   │
│  │   数据持久性 = redo log持久化 + binlog持久化 + 两阶段提交         │   │
│  │                                                                  │   │
│  └──────────────────────────────────────────────────────────────────┘   │
│                                                                         │
│  ┌─────────────────────── 1. redo log 刷盘策略 ─────────────────────┐   │
│  │                                                                  │   │
│  │   参数: innodb_flush_log_at_trx_commit                          │   │
│  │                                                                  │   │
│  │   ┌────────────────────────────────────────────────────────────┐ │   │
│  │   │  值=0: 每秒刷盘                                            │ │   │
│  │   │                                                            │ │   │
│  │   │  事务提交 → 写入Log Buffer → 每秒fsync到磁盘               │ │   │
│  │   │                                                            │ │   │
│  │   │  风险: 宕机可能丢失1秒数据                                  │ │   │
│  │   │  性能: 最高                                                │ │   │
│  │   └────────────────────────────────────────────────────────────┘ │   │
│  │                                                                  │   │
│  │   ┌────────────────────────────────────────────────────────────┐ │   │
│  │   │  值=1: 每次提交都刷盘 (默认,最安全) ⭐                      │ │   │
│  │   │                                                            │ │   │
│  │   │  事务提交 → 写入Log Buffer → 立即fsync到磁盘               │ │   │
│  │   │                                                            │ │   │
│  │   │  风险: 不会丢失数据                                        │ │   │
│  │   │  性能: 最低                                                │ │   │
│  │   └────────────────────────────────────────────────────────────┘ │   │
│  │                                                                  │   │
│  │   ┌────────────────────────────────────────────────────────────┐ │   │
│  │   │  值=2: 每次提交写OS缓存,每秒刷盘                           │ │   │
│  │   │                                                            │ │   │
│  │   │  事务提交 → 写入OS Page Cache → 每秒fsync到磁盘            │ │   │
│  │   │                                                            │ │   │
│  │   │  风险: 操作系统崩溃可能丢失1秒数据                          │ │   │
│  │   │  性能: 中等                                                │ │   │
│  │   └────────────────────────────────────────────────────────────┘ │   │
│  │                                                                  │   │
│  └──────────────────────────────────────────────────────────────────┘   │
│                                                                         │
│  ┌─────────────────────── 2. binlog 刷盘策略 ───────────────────────┐   │
│  │                                                                  │   │
│  │   参数: sync_binlog                                             │   │
│  │                                                                  │   │
│  │   ┌────────────────────────────────────────────────────────────┐ │   │
│  │   │  值=0: 由操作系统决定何时刷盘                               │ │   │
│  │   │        性能最好,但可能丢失数据                              │ │   │
│  │   │                                                            │ │   │
│  │   │  值=1: 每次提交事务都刷盘 (最安全) ⭐                       │ │   │
│  │   │        不会丢失binlog                                      │ │   │
│  │   │                                                            │ │   │
│  │   │  值=N: 每N个事务刷一次盘                                   │ │   │
│  │   │        折中方案                                            │ │   │
│  │   └────────────────────────────────────────────────────────────┘ │   │
│  │                                                                  │   │
│  └──────────────────────────────────────────────────────────────────┘   │
│                                                                         │
│  ┌─────────────────────── 3. 双1配置 (最安全) ──────────────────────┐   │
│  │                                                                  │   │
│  │   innodb_flush_log_at_trx_commit = 1                            │   │
│  │   sync_binlog = 1                                               │   │
│  │                                                                  │   │
│  │   ┌────────────────────────────────────────────────────────────┐ │   │
│  │   │                                                            │ │   │
│  │   │   事务提交流程 (双1配置):                                   │ │   │
│  │   │                                                            │ │   │
│  │   │   ┌───────────┐                                           │ │   │
│  │   │   │  UPDATE   │                                           │ │   │
│  │   │   └─────┬─────┘                                           │ │   │
│  │   │         │                                                 │ │   │
│  │   │         ↓                                                 │ │   │
│  │   │   ┌───────────────────┐                                   │ │   │
│  │   │   │ 写redo log(prepare)│                                  │ │   │
│  │   │   │ + fsync到磁盘      │ ← 第一次刷盘                      │ │   │
│  │   │   └─────────┬─────────┘                                   │ │   │
│  │   │             │                                             │ │   │
│  │   │             ↓                                             │ │   │
│  │   │   ┌───────────────────┐                                   │ │   │
│  │   │   │ 写binlog          │                                   │ │   │
│  │   │   │ + fsync到磁盘      │ ← 第二次刷盘                      │ │   │
│  │   │   └─────────┬─────────┘                                   │ │   │
│  │   │             │                                             │ │   │
│  │   │             ↓                                             │ │   │
│  │   │   ┌───────────────────┐                                   │ │   │
│  │   │   │ 写redo log(commit)│                                   │ │   │
│  │   │   └───────────────────┘                                   │ │   │
│  │   │             │                                             │ │   │
│  │   │             ↓                                             │ │   │
│  │   │        事务提交成功                                        │ │   │
│  │   │                                                            │ │   │
│  │   └────────────────────────────────────────────────────────────┘ │   │
│  │                                                                  │   │
│  │   代价: 每次提交至少2次磁盘IO,性能有影响                         │   │
│  │   优化: 使用组提交(group commit)减少IO次数                       │   │
│  │                                                                  │   │
│  └──────────────────────────────────────────────────────────────────┘   │
│                                                                         │
│  ┌─────────────────────── 4. 组提交优化 ────────────────────────────┐   │
│  │                                                                  │   │
│  │   多个事务合并成一组，一次fsync写入                              │   │
│  │                                                                  │   │
│  │   ┌────────────────────────────────────────────────────────────┐ │   │
│  │   │                                                            │ │   │
│  │   │   事务1 ─┐                                                 │ │   │
│  │   │   事务2 ─┼──→ 合并成一组 ──→ 一次fsync                     │ │   │
│  │   │   事务3 ─┘                                                 │ │   │
│  │   │                                                            │ │   │
│  │   │   参数:                                                    │ │   │
│  │   │   binlog_group_commit_sync_delay = 0       # 延迟微秒      │ │   │
│  │   │   binlog_group_commit_sync_no_delay_count = 0 # 累积事务数 │ │   │
│  │   │                                                            │ │   │
│  │   └────────────────────────────────────────────────────────────┘ │   │
│  │                                                                  │   │
│  └──────────────────────────────────────────────────────────────────┘   │
│                                                                         │
└─────────────────────────────────────────────────────────────────────────┘
```

```sql
-- 查看当前配置
SHOW VARIABLES LIKE 'innodb_flush_log_at_trx_commit';
SHOW VARIABLES LIKE 'sync_binlog';

-- 配置双1 (最安全,建议生产环境使用)
SET GLOBAL innodb_flush_log_at_trx_commit = 1;
SET GLOBAL sync_binlog = 1;

-- my.cnf 配置
[mysqld]
innodb_flush_log_at_trx_commit = 1
sync_binlog = 1

-- 组提交参数
binlog_group_commit_sync_delay = 1000  -- 延迟1ms
binlog_group_commit_sync_no_delay_count = 10  -- 或累积10个事务
```

---

### 145. 主从复制的原理？

```
┌─────────────────────────────────────────────────────────────────────────┐
│                         MySQL 主从复制原理                               │
├─────────────────────────────────────────────────────────────────────────┤
│                                                                         │
│  ┌─────────────────────── 整体架构 ─────────────────────────────────┐   │
│  │                                                                  │   │
│  │     ┌────────────────────────────────────────────────────────┐  │   │
│  │     │                     Master (主库)                      │  │   │
│  │     │  ┌──────────────┐                                     │  │   │
│  │     │  │ Client写入   │                                     │  │   │
│  │     │  └───────┬──────┘                                     │  │   │
│  │     │          │                                            │  │   │
│  │     │          ↓                                            │  │   │
│  │     │  ┌──────────────┐    ┌──────────────┐                │  │   │
│  │     │  │  数据变更     │ →  │  binlog      │                │  │   │
│  │     │  └──────────────┘    └───────┬──────┘                │  │   │
│  │     │                              │                        │  │   │
│  │     │                    ┌─────────┴─────────┐              │  │   │
│  │     │                    │  Binlog Dump线程  │              │  │   │
│  │     │                    │  (发送binlog)     │              │  │   │
│  │     │                    └─────────┬─────────┘              │  │   │
│  │     └──────────────────────────────┼─────────────────────────┘  │   │
│  │                                    │                            │   │
│  │                                    │ 网络传输                    │   │
│  │                                    ↓                            │   │
│  │     ┌──────────────────────────────────────────────────────┐   │   │
│  │     │                     Slave (从库)                      │   │   │
│  │     │                                                      │   │   │
│  │     │  ┌─────────────────────┐                             │   │   │
│  │     │  │    I/O Thread       │ ← 接收binlog                │   │   │
│  │     │  │  (IO线程)           │                             │   │   │
│  │     │  └──────────┬──────────┘                             │   │   │
│  │     │             │                                        │   │   │
│  │     │             ↓                                        │   │   │
│  │     │  ┌─────────────────────┐                             │   │   │
│  │     │  │   Relay Log         │ ← 中继日志                  │   │   │
│  │     │  │  (中继日志)          │                             │   │   │
│  │     │  └──────────┬──────────┘                             │   │   │
│  │     │             │                                        │   │   │
│  │     │             ↓                                        │   │   │
│  │     │  ┌─────────────────────┐                             │   │   │
│  │     │  │   SQL Thread        │ ← 重放SQL                   │   │   │
│  │     │  │  (SQL线程)          │                             │   │   │
│  │     │  └──────────┬──────────┘                             │   │   │
│  │     │             │                                        │   │   │
│  │     │             ↓                                        │   │   │
│  │     │  ┌─────────────────────┐                             │   │   │
│  │     │  │   从库数据           │                             │   │   │
│  │     │  └─────────────────────┘                             │   │   │
│  │     │                                                      │   │   │
│  │     └──────────────────────────────────────────────────────┘   │   │
│  │                                                                  │   │
│  └──────────────────────────────────────────────────────────────────┘   │
│                                                                         │
│  ┌─────────────────────── 三个核心线程 ─────────────────────────────┐   │
│  │                                                                  │   │
│  │  ┌────────────────────────────────────────────────────────────┐ │   │
│  │  │  1. Binlog Dump Thread (主库)                              │ │   │
│  │  │                                                            │ │   │
│  │  │  • 当从库连接时，主库创建此线程                             │ │   │
│  │  │  • 读取binlog内容发送给从库                                │ │   │
│  │  │  • 每个从库对应一个Dump线程                                │ │   │
│  │  └────────────────────────────────────────────────────────────┘ │   │
│  │                                                                  │   │
│  │  ┌────────────────────────────────────────────────────────────┐ │   │
│  │  │  2. I/O Thread (从库)                                      │ │   │
│  │  │                                                            │ │   │
│  │  │  • 连接主库，请求binlog                                    │ │   │
│  │  │  • 接收binlog并写入本地Relay Log                          │ │   │
│  │  │  • 记录已读取到的位置(master.info)                         │ │   │
│  │  └────────────────────────────────────────────────────────────┘ │   │
│  │                                                                  │   │
│  │  ┌────────────────────────────────────────────────────────────┐ │   │
│  │  │  3. SQL Thread (从库)                                      │ │   │
│  │  │                                                            │ │   │
│  │  │  • 读取Relay Log中的事件                                   │ │   │
│  │  │  • 解析并执行SQL语句                                       │ │   │
│  │  │  • 记录已执行位置(relay-log.info)                          │ │   │
│  │  └────────────────────────────────────────────────────────────┘ │   │
│  │                                                                  │   │
│  └──────────────────────────────────────────────────────────────────┘   │
│                                                                         │
│  ┌─────────────────────── 复制模式 ─────────────────────────────────┐   │
│  │                                                                  │   │
│  │  ┌─────────────────────────────────────────────────────────┐    │   │
│  │  │  异步复制 (默认)                                         │    │   │
│  │  │                                                         │    │   │
│  │  │  Master提交 → 返回客户端 → 异步发送给Slave              │    │   │
│  │  │                                                         │    │   │
│  │  │  优点: 性能最好                                         │    │   │
│  │  │  缺点: 可能丢失数据(主库宕机时binlog未传输)              │    │   │
│  │  └─────────────────────────────────────────────────────────┘    │   │
│  │                                                                  │   │
│  │  ┌─────────────────────────────────────────────────────────┐    │   │
│  │  │  半同步复制                                              │    │   │
│  │  │                                                         │    │   │
│  │  │  Master提交 → 等待至少一个Slave确认 → 返回客户端        │    │   │
│  │  │                                                         │    │   │
│  │  │  优点: 减少数据丢失风险                                  │    │   │
│  │  │  缺点: 有一定延迟                                        │    │   │
│  │  └─────────────────────────────────────────────────────────┘    │   │
│  │                                                                  │   │
│  │  ┌─────────────────────────────────────────────────────────┐    │   │
│  │  │  全同步复制 (Group Replication)                          │    │   │
│  │  │                                                         │    │   │
│  │  │  Master提交 → 等待所有Slave确认 → 返回客户端            │    │   │
│  │  │                                                         │    │   │
│  │  │  优点: 数据强一致                                        │    │   │
│  │  │  缺点: 性能最差                                          │    │   │
│  │  └─────────────────────────────────────────────────────────┘    │   │
│  │                                                                  │   │
│  └──────────────────────────────────────────────────────────────────┘   │
│                                                                         │
└─────────────────────────────────────────────────────────────────────────┘
```

```sql
-- 主库配置 (my.cnf)
[mysqld]
server-id = 1
log-bin = mysql-bin
binlog_format = ROW

-- 主库创建复制用户
CREATE USER 'repl'@'%' IDENTIFIED BY 'password';
GRANT REPLICATION SLAVE ON *.* TO 'repl'@'%';

-- 查看主库状态
SHOW MASTER STATUS;

-- 从库配置
[mysqld]
server-id = 2
relay-log = relay-bin
read_only = 1

-- 从库配置主库信息
CHANGE MASTER TO
    MASTER_HOST='192.168.1.100',
    MASTER_USER='repl',
    MASTER_PASSWORD='password',
    MASTER_LOG_FILE='mysql-bin.000001',
    MASTER_LOG_POS=154;

-- 启动从库复制
START SLAVE;

-- 查看从库状态
SHOW SLAVE STATUS\G
-- 关注: Slave_IO_Running, Slave_SQL_Running, Seconds_Behind_Master
```

---

### 146. 主从延迟如何解决？

```
┌─────────────────────────────────────────────────────────────────────────┐
│                         主从延迟问题与解决方案                            │
├─────────────────────────────────────────────────────────────────────────┤
│                                                                         │
│  ┌─────────────────────── 延迟产生原因 ─────────────────────────────┐   │
│  │                                                                  │   │
│  │  ┌────────────────────────────────────────────────────────────┐ │   │
│  │  │  1. 从库单线程回放                                         │ │   │
│  │  │     主库: 多线程并发写入                                   │ │   │
│  │  │     从库: SQL Thread单线程串行执行                         │ │   │
│  │  └────────────────────────────────────────────────────────────┘ │   │
│  │                                                                  │   │
│  │  ┌────────────────────────────────────────────────────────────┐ │   │
│  │  │  2. 从库机器性能差                                         │ │   │
│  │  │     CPU、IO、内存等资源不足                                │ │   │
│  │  └────────────────────────────────────────────────────────────┘ │   │
│  │                                                                  │   │
│  │  ┌────────────────────────────────────────────────────────────┐ │   │
│  │  │  3. 大事务                                                 │ │   │
│  │  │     大批量UPDATE/DELETE，从库执行时间长                    │ │   │
│  │  └────────────────────────────────────────────────────────────┘ │   │
│  │                                                                  │   │
│  │  ┌────────────────────────────────────────────────────────────┐ │   │
│  │  │  4. 从库有大量查询                                         │ │   │
│  │  │     SQL Thread与查询竞争资源                               │ │   │
│  │  └────────────────────────────────────────────────────────────┘ │   │
│  │                                                                  │   │
│  │  ┌────────────────────────────────────────────────────────────┐ │   │
│  │  │  5. 网络延迟                                               │ │   │
│  │  │     主从之间网络带宽不足或不稳定                           │ │   │
│  │  └────────────────────────────────────────────────────────────┘ │   │
│  │                                                                  │   │
│  └──────────────────────────────────────────────────────────────────┘   │
│                                                                         │
│  ┌─────────────────────── 解决方案 ─────────────────────────────────┐   │
│  │                                                                  │   │
│  │  ┌────────────────────────────────────────────────────────────┐ │   │
│  │  │  方案1: 并行复制 (MySQL 5.6+)                              │ │   │
│  │  │                                                            │ │   │
│  │  │  ┌─────────────────────────────────────────────────────┐  │ │   │
│  │  │  │  5.6: 按schema(库)并行                              │  │ │   │
│  │  │  │       不同库的事务可以并行执行                       │  │ │   │
│  │  │  │       slave_parallel_type = DATABASE                │  │ │   │
│  │  │  │                                                     │  │ │   │
│  │  │  │  5.7: 按组提交并行 (LOGICAL_CLOCK)                  │  │ │   │
│  │  │  │       同一组提交的事务可以并行执行                   │  │ │   │
│  │  │  │       slave_parallel_type = LOGICAL_CLOCK           │  │ │   │
│  │  │  │       slave_parallel_workers = 16                   │  │ │   │
│  │  │  │                                                     │  │ │   │
│  │  │  │  8.0: 基于WriteSet的并行                            │  │ │   │
│  │  │  │       不冲突的事务可以并行                          │  │ │   │
│  │  │  │       binlog_transaction_dependency_tracking=WRITESET│  │ │   │
│  │  │  └─────────────────────────────────────────────────────┘  │ │   │
│  │  └────────────────────────────────────────────────────────────┘ │   │
│  │                                                                  │   │
│  │  ┌────────────────────────────────────────────────────────────┐ │   │
│  │  │  方案2: 架构优化                                           │ │   │
│  │  │                                                            │ │   │
│  │  │  • 提升从库硬件配置                                        │ │   │
│  │  │  • 使用SSD硬盘                                             │ │   │
│  │  │  • 增加从库数量,分担查询压力                               │ │   │
│  │  │  • 使用ProxySQL/MyCat中间件做读写分离                      │ │   │
│  │  └────────────────────────────────────────────────────────────┘ │   │
│  │                                                                  │   │
│  │  ┌────────────────────────────────────────────────────────────┐ │   │
│  │  │  方案3: 业务优化                                           │ │   │
│  │  │                                                            │ │   │
│  │  │  • 避免大事务，拆分为小事务                                │ │   │
│  │  │  • 批量写入改为小批次多次执行                              │ │   │
│  │  │  • 非核心业务走异步                                        │ │   │
│  │  └────────────────────────────────────────────────────────────┘ │   │
│  │                                                                  │   │
│  │  ┌────────────────────────────────────────────────────────────┐ │   │
│  │  │  方案4: 强制走主库                                         │ │   │
│  │  │                                                            │ │   │
│  │  │  对于写后立即读的场景:                                     │ │   │
│  │  │  • 强制读主库                                              │ │   │
│  │  │  • 或者等待从库同步完成                                    │ │   │
│  │  │                                                            │ │   │
│  │  │  ┌───────────────────────────────────────────────────┐    │ │   │
│  │  │  │  // 写入后强制读主库                              │    │ │   │
│  │  │  │  insert();                                        │    │ │   │
│  │  │  │  // 设置hint或通过中间件路由到主库                │    │ │   │
│  │  │  │  @UseMaster                                       │    │ │   │
│  │  │  │  select();                                        │    │ │   │
│  │  │  └───────────────────────────────────────────────────┘    │ │   │
│  │  └────────────────────────────────────────────────────────────┘ │   │
│  │                                                                  │   │
│  │  ┌────────────────────────────────────────────────────────────┐ │   │
│  │  │  方案5: 半同步复制                                         │ │   │
│  │  │                                                            │ │   │
│  │  │  确保至少一个从库收到binlog后才返回                        │ │   │
│  │  │                                                            │ │   │
│  │  │  INSTALL PLUGIN rpl_semi_sync_master                      │ │   │
│  │  │      SONAME 'semisync_master.so';                         │ │   │
│  │  │  SET GLOBAL rpl_semi_sync_master_enabled = 1;             │ │   │
│  │  └────────────────────────────────────────────────────────────┘ │   │
│  │                                                                  │   │
│  └──────────────────────────────────────────────────────────────────┘   │
│                                                                         │
└─────────────────────────────────────────────────────────────────────────┘
```

```sql
-- 监控主从延迟
SHOW SLAVE STATUS\G
-- Seconds_Behind_Master: 延迟秒数

-- 配置并行复制 (从库my.cnf)
[mysqld]
slave_parallel_type = LOGICAL_CLOCK
slave_parallel_workers = 16
slave_preserve_commit_order = 1

-- MySQL 8.0 WriteSet并行
binlog_transaction_dependency_tracking = WRITESET
transaction_write_set_extraction = XXHASH64
```

---

### 147. 什么是GTID复制？

```
┌─────────────────────────────────────────────────────────────────────────┐
│                      GTID (全局事务标识符) 复制                          │
├─────────────────────────────────────────────────────────────────────────┤
│                                                                         │
│  ┌─────────────────────── GTID 概念 ────────────────────────────────┐   │
│  │                                                                  │   │
│  │  GTID = source_id : transaction_id                              │   │
│  │                                                                  │   │
│  │  示例: 3E11FA47-71CA-11E1-9E33-C80AA9429562:23                  │   │
│  │        ├─────────── server_uuid ──────────┤  ├─ 事务序号        │   │
│  │                                                                  │   │
│  │  特点:                                                          │   │
│  │  • 全局唯一标识每个事务                                         │   │
│  │  • 主从服务器共享相同的GTID                                     │   │
│  │  • 自动跳过已执行的GTID                                         │   │
│  │                                                                  │   │
│  └──────────────────────────────────────────────────────────────────┘   │
│                                                                         │
│  ┌─────────────────────── 传统复制 vs GTID复制 ─────────────────────┐   │
│  │                                                                  │   │
│  │  ┌────────────────────────────────────────────────────────────┐ │   │
│  │  │  传统复制 (基于位置)                                       │ │   │
│  │  │                                                            │ │   │
│  │  │  CHANGE MASTER TO                                          │ │   │
│  │  │      MASTER_HOST='...',                                    │ │   │
│  │  │      MASTER_LOG_FILE='mysql-bin.000003',  ← 文件名         │ │   │
│  │  │      MASTER_LOG_POS=1024;                 ← 位置偏移       │ │   │
│  │  │                                                            │ │   │
│  │  │  问题:                                                     │ │   │
│  │  │  • 主库切换后需要手动计算新的位置                          │ │   │
│  │  │  • 不同从库位置可能不同，切换复杂                          │ │   │
│  │  └────────────────────────────────────────────────────────────┘ │   │
│  │                                                                  │   │
│  │  ┌────────────────────────────────────────────────────────────┐ │   │
│  │  │  GTID复制                                                  │ │   │
│  │  │                                                            │ │   │
│  │  │  CHANGE MASTER TO                                          │ │   │
│  │  │      MASTER_HOST='...',                                    │ │   │
│  │  │      MASTER_AUTO_POSITION=1;   ← 自动定位!                 │ │   │
│  │  │                                                            │ │   │
│  │  │  优点:                                                     │ │   │
│  │  │  • 自动定位复制位置                                        │ │   │
│  │  │  • 主库切换简单                                            │ │   │
│  │  │  • 数据一致性保证更好                                      │ │   │
│  │  └────────────────────────────────────────────────────────────┘ │   │
│  │                                                                  │   │
│  └──────────────────────────────────────────────────────────────────┘   │
│                                                                         │
│  ┌─────────────────────── GTID工作原理 ─────────────────────────────┐   │
│  │                                                                  │   │
│  │   ┌───────────────── Master ─────────────────┐                  │   │
│  │   │                                          │                  │   │
│  │   │  事务提交时:                              │                  │   │
│  │   │  1. 分配唯一GTID                         │                  │   │
│  │   │  2. GTID写入binlog                       │                  │   │
│  │   │  3. 记录到gtid_executed集合              │                  │   │
│  │   │                                          │                  │   │
│  │   │  gtid_executed:                          │                  │   │
│  │   │  uuid1:1-100, uuid2:1-50                │                  │   │
│  │   │                                          │                  │   │
│  │   └────────────────────┬─────────────────────┘                  │   │
│  │                        │                                        │   │
│  │                        ↓ 发送binlog(含GTID)                     │   │
│  │                                                                  │   │
│  │   ┌───────────────── Slave ──────────────────┐                  │   │
│  │   │                                          │                  │   │
│  │   │  接收时:                                  │                  │   │
│  │   │  1. 检查GTID是否在gtid_executed中        │                  │   │
│  │   │  2. 如果已存在，跳过该事务               │                  │   │
│  │   │  3. 如果不存在，执行并记录GTID           │                  │   │
│  │   │                                          │                  │   │
│  │   │  gtid_executed:                          │                  │   │
│  │   │  uuid1:1-100, uuid2:1-50                │                  │   │
│  │   │                                          │                  │   │
│  │   └──────────────────────────────────────────┘                  │   │
│  │                                                                  │   │
│  └──────────────────────────────────────────────────────────────────┘   │
│                                                                         │
│  ┌─────────────────────── 主库切换示例 ─────────────────────────────┐   │
│  │                                                                  │   │
│  │                原主库故障                                        │   │
│  │                    ↓                                            │   │
│  │   ┌─────────────────────────────────────────────────────────┐   │   │
│  │   │  Master (宕机)    Slave1        Slave2                  │   │   │
│  │   │  GTID: 1-100      GTID: 1-98    GTID: 1-95              │   │   │
│  │   └─────────────────────────────────────────────────────────┘   │   │
│  │                                                                  │   │
│  │   选择Slave1为新主库 (GTID最大):                                 │   │
│  │   ┌─────────────────────────────────────────────────────────┐   │   │
│  │   │  -- Slave2 切换到 Slave1                                │   │   │
│  │   │  STOP SLAVE;                                            │   │   │
│  │   │  CHANGE MASTER TO                                        │   │   │
│  │   │      MASTER_HOST='slave1_ip',                           │   │   │
│  │   │      MASTER_AUTO_POSITION=1;  ← 自动定位到GTID:96        │   │   │
│  │   │  START SLAVE;                                            │   │   │
│  │   │  -- 自动补齐96,97,98这3个事务                           │   │   │
│  │   └─────────────────────────────────────────────────────────┘   │   │
│  │                                                                  │   │
│  └──────────────────────────────────────────────────────────────────┘   │
│                                                                         │
└─────────────────────────────────────────────────────────────────────────┘
```

```sql
-- 启用GTID (my.cnf)
[mysqld]
gtid_mode = ON
enforce_gtid_consistency = ON
log_bin = mysql-bin
log_slave_updates = ON

-- 查看GTID状态
SHOW GLOBAL VARIABLES LIKE '%gtid%';
SELECT @@GLOBAL.gtid_executed;

-- 配置GTID复制 (从库)
CHANGE MASTER TO
    MASTER_HOST='192.168.1.100',
    MASTER_USER='repl',
    MASTER_PASSWORD='password',
    MASTER_AUTO_POSITION=1;

START SLAVE;

-- 跳过某个GTID (谨慎使用)
SET GTID_NEXT='uuid:transaction_id';
BEGIN;
COMMIT;
SET GTID_NEXT='AUTOMATIC';
```

---

### 148. MySQL高可用方案有哪些？

```
┌─────────────────────────────────────────────────────────────────────────┐
│                         MySQL 高可用方案                                 │
├─────────────────────────────────────────────────────────────────────────┤
│                                                                         │
│  ┌─────────────────────── 方案1: 主从复制+VIP切换 ──────────────────┐   │
│  │                                                                  │   │
│  │   ┌────────────────────────────────────────────────────────────┐│   │
│  │   │                         VIP                                ││   │
│  │   │                          │                                 ││   │
│  │   │            ┌─────────────┼─────────────┐                   ││   │
│  │   │            │             │             │                   ││   │
│  │   │        ┌───┴───┐    ┌────┴────┐   ┌────┴────┐              ││   │
│  │   │        │Master │ →  │ Slave1  │   │ Slave2  │              ││   │
│  │   │        │(写)   │    │ (读)    │   │ (读)    │              ││   │
│  │   │        └───────┘    └─────────┘   └─────────┘              ││   │
│  │   │                                                            ││   │
│  │   │  工具: Keepalived, MHA                                     ││   │
│  │   │  特点: 简单，但切换可能有数据丢失                           ││   │
│  │   └────────────────────────────────────────────────────────────┘│   │
│  │                                                                  │   │
│  └──────────────────────────────────────────────────────────────────┘   │
│                                                                         │
│  ┌─────────────────────── 方案2: MHA (Master High Availability) ───┐   │
│  │                                                                  │   │
│  │   ┌────────────────────────────────────────────────────────────┐│   │
│  │   │                    MHA Manager                             ││   │
│  │   │                         │                                  ││   │
│  │   │         监控──────────────────────监控                     ││   │
│  │   │            │            │            │                     ││   │
│  │   │        ┌───┴───┐    ┌───┴───┐    ┌───┴───┐                ││   │
│  │   │        │Master │    │Slave1 │    │Slave2 │                ││   │
│  │   │        └───────┘    └───────┘    └───────┘                ││   │
│  │   │                                                            ││   │
│  │   │  故障切换流程:                                             ││   │
│  │   │  1. 检测Master故障                                        ││   │
│  │   │  2. 选举数据最新的Slave为新Master                         ││   │
│  │   │  3. 其他Slave从新Master同步差异数据                       ││   │
│  │   │  4. 切换VIP到新Master                                     ││   │
│  │   │                                                            ││   │
│  │   │  优点: 自动故障切换，尽量保证数据不丢失                    ││   │
│  │   └────────────────────────────────────────────────────────────┘│   │
│  │                                                                  │   │
│  └──────────────────────────────────────────────────────────────────┘   │
│                                                                         │
│  ┌─────────────────────── 方案3: MySQL Group Replication ──────────┐   │
│  │                                                                  │   │
│  │   ┌────────────────────────────────────────────────────────────┐│   │
│  │   │                                                            ││   │
│  │   │     ┌─────────┐      ┌─────────┐      ┌─────────┐         ││   │
│  │   │     │ Node1   │←────→│ Node2   │←────→│ Node3   │         ││   │
│  │   │     │ Primary │      │Secondary│      │Secondary│         ││   │
│  │   │     └─────────┘      └─────────┘      └─────────┘         ││   │
│  │   │           ↑               ↑               ↑               ││   │
│  │   │           └───────────────┴───────────────┘               ││   │
│  │   │                    Paxos协议通信                           ││   │
│  │   │                                                            ││   │
│  │   │  模式:                                                     ││   │
│  │   │  • 单主模式: 一个节点写，其他节点读                        ││   │
│  │   │  • 多主模式: 所有节点都可以写(需处理冲突)                  ││   │
│  │   │                                                            ││   │
│  │   │  优点: 强一致性，自动故障检测和切换                        ││   │
│  │   │  缺点: 性能损耗，对网络要求高                              ││   │
│  │   └────────────────────────────────────────────────────────────┘│   │
│  │                                                                  │   │
│  └──────────────────────────────────────────────────────────────────┘   │
│                                                                         │
│  ┌─────────────────────── 方案4: MySQL InnoDB Cluster ─────────────┐   │
│  │                                                                  │   │
│  │   ┌────────────────────────────────────────────────────────────┐│   │
│  │   │                                                            ││   │
│  │   │                    MySQL Router                            ││   │
│  │   │                    (代理层)                                ││   │
│  │   │                         │                                  ││   │
│  │   │         ┌───────────────┼───────────────┐                  ││   │
│  │   │         │               │               │                  ││   │
│  │   │     ┌───┴───┐      ┌────┴────┐     ┌────┴────┐            ││   │
│  │   │     │ Node1 │      │  Node2  │     │  Node3  │            ││   │
│  │   │     │Primary│      │Secondary│     │Secondary│            ││   │
│  │   │     └───────┘      └─────────┘     └─────────┘            ││   │
│  │   │           ↑              ↑              ↑                  ││   │
│  │   │           └──────────────┴──────────────┘                  ││   │
│  │   │                  Group Replication                        ││   │
│  │   │                                                            ││   │
│  │   │  组件:                                                     ││   │
│  │   │  • MySQL Server + Group Replication                       ││   │
│  │   │  • MySQL Router: 路由和负载均衡                           ││   │
│  │   │  • MySQL Shell: 管理工具                                  ││   │
│  │   │                                                            ││   │
│  │   │  优点: 官方方案，集成度高，易于管理                        ││   │
│  │   └────────────────────────────────────────────────────────────┘│   │
│  │                                                                  │   │
│  └──────────────────────────────────────────────────────────────────┘   │
│                                                                         │
│  ┌─────────────────────── 方案5: PXC (Percona XtraDB Cluster) ─────┐   │
│  │                                                                  │   │
│  │  基于Galera的多主集群                                           │   │
│  │  • 同步复制，强一致性                                           │   │
│  │  • 所有节点都可读写                                             │   │
│  │  • 自动故障检测和恢复                                           │   │
│  │                                                                  │   │
│  └──────────────────────────────────────────────────────────────────┘   │
│                                                                         │
│  ┌─────────────────────── 方案对比 ─────────────────────────────────┐   │
│  │                                                                  │   │
│  │  方案              │ 一致性  │ 性能  │ 复杂度 │ 数据丢失风险    │   │
│  │  ─────────────────────────────────────────────────────────────  │   │
│  │  主从+Keepalived   │ 弱      │ 高    │ 低     │ 高             │   │
│  │  MHA               │ 中      │ 高    │ 中     │ 低             │   │
│  │  Group Replication │ 强      │ 中    │ 中     │ 无             │   │
│  │  InnoDB Cluster    │ 强      │ 中    │ 低     │ 无             │   │
│  │  PXC/Galera        │ 强      │ 中    │ 高     │ 无             │   │
│  │                                                                  │   │
│  └──────────────────────────────────────────────────────────────────┘   │
│                                                                         │
└─────────────────────────────────────────────────────────────────────────┘
```

---

## 5.4 分库分表（7题）

### 149. 分库分表的策略有哪些？

```
┌─────────────────────────────────────────────────────────────────────────┐
│                          分库分表策略                                    │
├─────────────────────────────────────────────────────────────────────────┤
│                                                                         │
│  ┌─────────────────────── 垂直拆分 ─────────────────────────────────┐   │
│  │                                                                  │   │
│  │  ┌────────────────── 垂直分库 ──────────────────┐               │   │
│  │  │                                              │               │   │
│  │  │  按业务拆分到不同数据库                       │               │   │
│  │  │                                              │               │   │
│  │  │  ┌───────────┐                               │               │   │
│  │  │  │  单体DB   │                               │               │   │
│  │  │  │ ─────────│                               │               │   │
│  │  │  │ 用户表    │         拆分后                │               │   │
│  │  │  │ 订单表    │  ──────────────→              │               │   │
│  │  │  │ 商品表    │                               │               │   │
│  │  │  │ 支付表    │   ┌─────┐ ┌─────┐ ┌─────┐    │               │   │
│  │  │  └───────────┘   │用户DB│ │订单DB│ │商品DB│   │               │   │
│  │  │                   └─────┘ └─────┘ └─────┘    │               │   │
│  │  │                                              │               │   │
│  │  └──────────────────────────────────────────────┘               │   │
│  │                                                                  │   │
│  │  ┌────────────────── 垂直分表 ──────────────────┐               │   │
│  │  │                                              │               │   │
│  │  │  按列拆分,将大字段独立出去                    │               │   │
│  │  │                                              │               │   │
│  │  │  ┌──────────────────────┐                    │               │   │
│  │  │  │ article              │      拆分后        │               │   │
│  │  │  │ ─────────────────────│  ─────────→       │               │   │
│  │  │  │ id, title            │                    │               │   │
│  │  │  │ summary              │   ┌───────────┐   │               │   │
│  │  │  │ content (TEXT)  ←大  │   │article    │   │               │   │
│  │  │  │ create_time          │   │id,title   │   │               │   │
│  │  │  └──────────────────────┘   │summary    │   │               │   │
│  │  │                              └───────────┘   │               │   │
│  │  │                              ┌───────────┐   │               │   │
│  │  │                              │article_ext│   │               │   │
│  │  │                              │id,content │   │               │   │
│  │  │                              └───────────┘   │               │   │
│  │  │                                              │               │   │
│  │  └──────────────────────────────────────────────┘               │   │
│  │                                                                  │   │
│  └──────────────────────────────────────────────────────────────────┘   │
│                                                                         │
│  ┌─────────────────────── 水平拆分 ─────────────────────────────────┐   │
│  │                                                                  │   │
│  │  ┌────────────────── 水平分表 ──────────────────┐               │   │
│  │  │                                              │               │   │
│  │  │  同一数据库内，将数据分散到多个表              │               │   │
│  │  │                                              │               │   │
│  │  │  ┌───────────┐        ┌───────────┐         │               │   │
│  │  │  │ order     │        │ order_0   │         │               │   │
│  │  │  │ (1亿数据) │   →    │ order_1   │         │               │   │
│  │  │  └───────────┘        │ order_2   │         │               │   │
│  │  │                        │ ...       │         │               │   │
│  │  │                        │ order_63  │         │               │   │
│  │  │                        └───────────┘         │               │   │
│  │  │                                              │               │   │
│  │  └──────────────────────────────────────────────┘               │   │
│  │                                                                  │   │
│  │  ┌────────────────── 水平分库 ──────────────────┐               │   │
│  │  │                                              │               │   │
│  │  │  将数据分散到多个数据库实例                   │               │   │
│  │  │                                              │               │   │
│  │  │  ┌───────────┐    ┌─────────────────────┐   │               │   │
│  │  │  │   order   │    │  DB0    DB1    DB2  │   │               │   │
│  │  │  │ (1亿数据) │ →  │ ┌───┐  ┌───┐  ┌───┐│   │               │   │
│  │  │  └───────────┘    │ │o_0│  │o_0│  │o_0││   │               │   │
│  │  │                    │ │o_1│  │o_1│  │o_1││   │               │   │
│  │  │                    │ └───┘  └───┘  └───┘│   │               │   │
│  │  │                    └─────────────────────┘   │               │   │
│  │  │                                              │               │   │
│  │  └──────────────────────────────────────────────┘               │   │
│  │                                                                  │   │
│  └──────────────────────────────────────────────────────────────────┘   │
│                                                                         │
│  ┌─────────────────────── 分片算法 ─────────────────────────────────┐   │
│  │                                                                  │   │
│  │  ┌────────────────────────────────────────────────────────────┐ │   │
│  │  │  1. 取模分片: hash(key) % N                                │ │   │
│  │  │                                                            │ │   │
│  │  │     优点: 数据分布均匀                                     │ │   │
│  │  │     缺点: 扩容需要数据迁移                                 │ │   │
│  │  │                                                            │ │   │
│  │  │     order_id % 4 = 0 → table_0                            │ │   │
│  │  │     order_id % 4 = 1 → table_1                            │ │   │
│  │  │     order_id % 4 = 2 → table_2                            │ │   │
│  │  │     order_id % 4 = 3 → table_3                            │ │   │
│  │  └────────────────────────────────────────────────────────────┘ │   │
│  │                                                                  │   │
│  │  ┌────────────────────────────────────────────────────────────┐ │   │
│  │  │  2. 范围分片: 按ID/时间范围                                │ │   │
│  │  │                                                            │ │   │
│  │  │     优点: 扩容简单，只需增加新表                           │ │   │
│  │  │     缺点: 热点数据集中在最新分片                           │ │   │
│  │  │                                                            │ │   │
│  │  │     id 1-1000万    → table_0                              │ │   │
│  │  │     id 1000万-2000万 → table_1                            │ │   │
│  │  │     2024-01 数据   → table_202401                         │ │   │
│  │  └────────────────────────────────────────────────────────────┘ │   │
│  │                                                                  │   │
│  │  ┌────────────────────────────────────────────────────────────┐ │   │
│  │  │  3. 一致性哈希: 减少扩容时数据迁移                         │ │   │
│  │  │                                                            │ │   │
│  │  │     节点变化只影响相邻节点的数据                           │ │   │
│  │  └────────────────────────────────────────────────────────────┘ │   │
│  │                                                                  │   │
│  └──────────────────────────────────────────────────────────────────┘   │
│                                                                         │
└─────────────────────────────────────────────────────────────────────────┘
```

---

### 150. 如何选择分片键？

```
┌─────────────────────────────────────────────────────────────────────────┐
│                          分片键选择原则                                  │
├─────────────────────────────────────────────────────────────────────────┤
│                                                                         │
│  ┌─────────────────────── 核心原则 ─────────────────────────────────┐   │
│  │                                                                  │   │
│  │  ┌────────────────────────────────────────────────────────────┐ │   │
│  │  │  1. 数据分布均匀                                           │ │   │
│  │  │     避免数据倾斜，不能集中在某几个分片                      │ │   │
│  │  │                                                            │ │   │
│  │  │     ✗ 用status分片: 大量订单是"已完成"状态                 │ │   │
│  │  │     ✓ 用order_id分片: 数据均匀分布                         │ │   │
│  │  └────────────────────────────────────────────────────────────┘ │   │
│  │                                                                  │   │
│  │  ┌────────────────────────────────────────────────────────────┐ │   │
│  │  │  2. 查询尽量落在单个分片                                   │ │   │
│  │  │     分片键应该是常用查询条件                                │ │   │
│  │  │                                                            │ │   │
│  │  │     场景: 电商订单查询                                     │ │   │
│  │  │     ✓ 按user_id分片: "查询用户的订单"只需查一个分片        │ │   │
│  │  │     ✗ 按order_id分片: "查询用户的订单"需要查所有分片       │ │   │
│  │  └────────────────────────────────────────────────────────────┘ │   │
│  │                                                                  │   │
│  │  ┌────────────────────────────────────────────────────────────┐ │   │
│  │  │  3. 分片键值尽量不变                                       │ │   │
│  │  │     分片键更新会导致数据迁移                                │ │   │
│  │  │                                                            │ │   │
│  │  │     ✓ user_id: 用户ID不会变                                │ │   │
│  │  │     ✗ status: 状态会频繁变化                               │ │   │
│  │  └────────────────────────────────────────────────────────────┘ │   │
│  │                                                                  │   │
│  │  ┌────────────────────────────────────────────────────────────┐ │   │
│  │  │  4. 考虑业务扩展性                                         │ │   │
│  │  │     预留足够的分片空间                                      │ │   │
│  │  └────────────────────────────────────────────────────────────┘ │   │
│  │                                                                  │   │
│  └──────────────────────────────────────────────────────────────────┘   │
│                                                                         │
│  ┌─────────────────────── 常见场景分片键选择 ───────────────────────┐   │
│  │                                                                  │   │
│  │  ┌────────────────────────────────────────────────────────────┐ │   │
│  │  │  场景: 电商订单                                            │ │   │
│  │  │                                                            │ │   │
│  │  │  方案1: 按user_id分片                                      │ │   │
│  │  │  • 用户查自己订单: 单分片查询 ✓                            │ │   │
│  │  │  • 商家查订单: 需要跨分片 ✗                                │ │   │
│  │  │                                                            │ │   │
│  │  │  方案2: 按order_id分片                                     │ │   │
│  │  │  • 按订单号查: 单分片查询 ✓                                │ │   │
│  │  │  • 用户查自己订单: 需要跨分片 ✗                            │ │   │
│  │  │                                                            │ │   │
│  │  │  最佳方案: 基因法                                          │ │   │
│  │  │  order_id = timestamp + user_id后4位 + sequence           │ │   │
│  │  │  分片规则: user_id后4位 % 分片数                           │ │   │
│  │  │  • 按order_id查: 可从id中提取分片信息 ✓                    │ │   │
│  │  │  • 按user_id查: 直接计算分片 ✓                             │ │   │
│  │  └────────────────────────────────────────────────────────────┘ │   │
│  │                                                                  │   │
│  │  ┌────────────────────────────────────────────────────────────┐ │   │
│  │  │  场景: 日志/流水表                                         │ │   │
│  │  │                                                            │ │   │
│  │  │  推荐: 按时间范围分片                                      │ │   │
│  │  │  • 按月/按日分表: log_202401, log_202402                   │ │   │
│  │  │  • 查询通常带时间范围，可定位到具体分片                     │ │   │
│  │  │  • 历史数据归档简单                                        │ │   │
│  │  └────────────────────────────────────────────────────────────┘ │   │
│  │                                                                  │   │
│  │  ┌────────────────────────────────────────────────────────────┐ │   │
│  │  │  场景: 多租户SaaS                                          │ │   │
│  │  │                                                            │ │   │
│  │  │  推荐: 按tenant_id(租户ID)分片                             │ │   │
│  │  │  • 租户数据完全隔离                                        │ │   │
│  │  │  • 大租户可独立分片                                        │ │   │
│  │  └────────────────────────────────────────────────────────────┘ │   │
│  │                                                                  │   │
│  └──────────────────────────────────────────────────────────────────┘   │
│                                                                         │
└─────────────────────────────────────────────────────────────────────────┘
```

---

### 151. 分库分表后如何查询？

```
┌─────────────────────────────────────────────────────────────────────────┐
│                       分库分表后的查询方案                                │
├─────────────────────────────────────────────────────────────────────────┤
│                                                                         │
│  ┌─────────────────────── 带分片键查询 ─────────────────────────────┐   │
│  │                                                                  │   │
│  │   最佳情况: 查询条件包含分片键，直接路由到目标分片                 │   │
│  │                                                                  │   │
│  │   -- 分片键: user_id                                            │   │
│  │   SELECT * FROM orders WHERE user_id = 12345;                   │   │
│  │                                                                  │   │
│  │   ┌─────────────────────────────────────────────────────────┐   │   │
│  │   │        user_id = 12345                                  │   │   │
│  │   │              │                                          │   │   │
│  │   │              ↓ 分片计算: 12345 % 4 = 1                  │   │   │
│  │   │              │                                          │   │   │
│  │   │        ┌─────┴─────┐                                    │   │   │
│  │   │        │  DB1.orders_1  │ ← 只查这一个分片              │   │   │
│  │   │        └───────────────┘                                │   │   │
│  │   └─────────────────────────────────────────────────────────┘   │   │
│  │                                                                  │   │
│  └──────────────────────────────────────────────────────────────────┘   │
│                                                                         │
│  ┌─────────────────────── 不带分片键查询 ───────────────────────────┐   │
│  │                                                                  │   │
│  │   需要查询所有分片，性能较差                                     │   │
│  │                                                                  │   │
│  │   -- 按订单号查询 (分片键是user_id)                             │   │
│  │   SELECT * FROM orders WHERE order_id = 'ORD123456';            │   │
│  │                                                                  │   │
│  │   ┌─────────────────────────────────────────────────────────┐   │   │
│  │   │              order_id = 'ORD123456'                     │   │   │
│  │   │                      │                                  │   │   │
│  │   │        ┌─────────────┼─────────────┐                    │   │   │
│  │   │        ↓             ↓             ↓                    │   │   │
│  │   │    ┌───────┐    ┌───────┐    ┌───────┐                  │   │   │
│  │   │    │DB0    │    │DB1    │    │DB2    │ ← 广播到所有分片  │   │   │
│  │   │    └───────┘    └───────┘    └───────┘                  │   │   │
│  │   │        │             │             │                    │   │   │
│  │   │        └─────────────┼─────────────┘                    │   │   │
│  │   │                      ↓                                  │   │   │
│  │   │                   合并结果                               │   │   │
│  │   └─────────────────────────────────────────────────────────┘   │   │
│  │                                                                  │   │
│  │   解决方案:                                                      │   │
│  │   1. 建立映射表: order_id → user_id                             │   │
│  │   2. 使用基因法生成order_id (包含分片信息)                       │   │
│  │   3. 使用ES等搜索引擎做全局索引                                  │   │
│  │                                                                  │   │
│  └──────────────────────────────────────────────────────────────────┘   │
│                                                                         │
│  ┌─────────────────────── 分页查询 ─────────────────────────────────┐   │
│  │                                                                  │   │
│  │   SELECT * FROM orders ORDER BY create_time LIMIT 10000, 10;    │   │
│  │                                                                  │   │
│  │   问题: 需要从每个分片取10010条数据,合并排序后取10条             │   │
│  │                                                                  │   │
│  │   ┌─────────────────────────────────────────────────────────┐   │   │
│  │   │     分片0         分片1          分片2                  │   │   │
│  │   │       │             │              │                    │   │   │
│  │   │   取10010条     取10010条      取10010条                │   │   │
│  │   │       │             │              │                    │   │   │
│  │   │       └─────────────┼──────────────┘                    │   │   │
│  │   │                     ↓                                   │   │   │
│  │   │              合并排序30030条                            │   │   │
│  │   │                     ↓                                   │   │   │
│  │   │               取offset后的10条                          │   │   │
│  │   └─────────────────────────────────────────────────────────┘   │   │
│  │                                                                  │   │
│  │   优化方案:                                                      │   │
│  │   1. 禁止深度分页,使用游标分页                                   │   │
│  │      WHERE create_time > '2024-01-01' ORDER BY create_time      │   │
│  │      LIMIT 10                                                   │   │
│  │                                                                  │   │
│  │   2. 二次查询法                                                  │   │
│  │      第一次: 查各分片的max(create_time)在offset位置的值          │   │
│  │      第二次: 用这个值做条件查询                                  │   │
│  │                                                                  │   │
│  │   3. 使用ES做排序和分页                                         │   │
│  │                                                                  │   │
│  └──────────────────────────────────────────────────────────────────┘   │
│                                                                         │
│  ┌─────────────────────── 聚合查询 ─────────────────────────────────┐   │
│  │                                                                  │   │
│  │   SELECT COUNT(*), SUM(amount) FROM orders WHERE status = 1;    │   │
│  │                                                                  │   │
│  │   ┌─────────────────────────────────────────────────────────┐   │   │
│  │   │     分片0          分片1           分片2                 │   │   │
│  │   │  count=100      count=150       count=200               │   │   │
│  │   │  sum=10000      sum=15000       sum=20000               │   │   │
│  │   │       │             │               │                   │   │   │
│  │   │       └─────────────┼───────────────┘                   │   │   │
│  │   │                     ↓                                   │   │   │
│  │   │           合并: count=450, sum=45000                    │   │   │
│  │   └─────────────────────────────────────────────────────────┘   │   │
│  │                                                                  │   │
│  │   注意: AVG需要先SUM和COUNT,再计算                              │   │
│  │                                                                  │   │
│  └──────────────────────────────────────────────────────────────────┘   │
│                                                                         │
│  ┌─────────────────────── 跨分片JOIN ───────────────────────────────┐   │
│  │                                                                  │   │
│  │   尽量避免! 方案:                                                │   │
│  │   1. 应用层分次查询,内存中关联                                   │   │
│  │   2. 冗余字段,减少JOIN需求                                       │   │
│  │   3. 使用广播表(每个分片都有完整数据的小表)                       │   │
│  │   4. 绑定表(相同分片键的表放一起)                                │   │
│  │                                                                  │   │
│  └──────────────────────────────────────────────────────────────────┘   │
│                                                                         │
└─────────────────────────────────────────────────────────────────────────┘
```

---

### 152. 分布式事务如何处理？

```
┌─────────────────────────────────────────────────────────────────────────┐
│                         分库分表后的分布式事务                            │
├─────────────────────────────────────────────────────────────────────────┤
│                                                                         │
│  ┌─────────────────────── 方案1: XA事务 (强一致) ───────────────────┐   │
│  │                                                                  │   │
│  │   两阶段提交协议 (2PC)                                          │   │
│  │                                                                  │   │
│  │   ┌────────────────────────────────────────────────────────────┐│   │
│  │   │                  协调者(TM)                                ││   │
│  │   │                     │                                      ││   │
│  │   │     ┌───────────────┼───────────────┐                      ││   │
│  │   │     │               │               │                      ││   │
│  │   │  ┌──┴──┐         ┌──┴──┐         ┌──┴──┐                   ││   │
│  │   │  │DB0  │         │DB1  │         │DB2  │                   ││   │
│  │   │  │(RM) │         │(RM) │         │(RM) │                   ││   │
│  │   │  └─────┘         └─────┘         └─────┘                   ││   │
│  │   │                                                            ││   │
│  │   │  阶段1(Prepare): TM → 所有RM: "准备好了吗?"                 ││   │
│  │   │                  所有RM → TM: "Yes/No"                     ││   │
│  │   │                                                            ││   │
│  │   │  阶段2(Commit):  如果都Yes: TM → 所有RM: "提交"             ││   │
│  │   │                  如果有No:  TM → 所有RM: "回滚"             ││   │
│  │   └────────────────────────────────────────────────────────────┘│   │
│  │                                                                  │   │
│  │   缺点: 同步阻塞,性能差; 单点故障风险                           │   │
│  │                                                                  │   │
│  └──────────────────────────────────────────────────────────────────┘   │
│                                                                         │
│  ┌─────────────────────── 方案2: TCC (补偿事务) ────────────────────┐   │
│  │                                                                  │   │
│  │   Try-Confirm-Cancel 模式                                       │   │
│  │                                                                  │   │
│  │   ┌────────────────────────────────────────────────────────────┐│   │
│  │   │                                                            ││   │
│  │   │  Try阶段: 预留资源                                         ││   │
│  │   │    账户A: 冻结100元 (余额不变,冻结金额+100)                 ││   │
│  │   │    账户B: 预增100元 (余额不变,待增金额+100)                 ││   │
│  │   │                                                            ││   │
│  │   │  Confirm阶段: 确认执行 (Try全部成功)                       ││   │
│  │   │    账户A: 扣除冻结金额 (余额-100,冻结金额-100)              ││   │
│  │   │    账户B: 增加余额 (余额+100,待增金额-100)                  ││   │
│  │   │                                                            ││   │
│  │   │  Cancel阶段: 取消执行 (Try有失败)                          ││   │
│  │   │    账户A: 释放冻结金额 (冻结金额-100)                       ││   │
│  │   │    账户B: 释放待增金额 (待增金额-100)                       ││   │
│  │   │                                                            ││   │
│  │   └────────────────────────────────────────────────────────────┘│   │
│  │                                                                  │   │
│  │   优点: 性能好,无长时间锁                                       │   │
│  │   缺点: 业务侵入大,需要实现Try/Confirm/Cancel三个方法            │   │
│  │                                                                  │   │
│  └──────────────────────────────────────────────────────────────────┘   │
│                                                                         │
│  ┌─────────────────────── 方案3: 本地消息表 ────────────────────────┐   │
│  │                                                                  │   │
│  │   ┌────────────────────────────────────────────────────────────┐│   │
│  │   │                                                            ││   │
│  │   │   服务A                          服务B                     ││   │
│  │   │   ┌───────────────────┐                                   ││   │
│  │   │   │ BEGIN             │                                   ││   │
│  │   │   │ 1.执行本地业务     │                                   ││   │
│  │   │   │ 2.写入消息表       │                                   ││   │
│  │   │   │ COMMIT            │                                   ││   │
│  │   │   └────────┬──────────┘                                   ││   │
│  │   │            │                                               ││   │
│  │   │            ↓ 定时任务/MQ                                   ││   │
│  │   │                                                            ││   │
│  │   │            ┌────────────────────┐                         ││   │
│  │   │            │ 消费消息,执行业务    │                         ││   │
│  │   │            │ 更新消息状态为已处理 │                         ││   │
│  │   │            └────────────────────┘                         ││   │
│  │   │                                                            ││   │
│  │   └────────────────────────────────────────────────────────────┘│   │
│  │                                                                  │   │
│  │   特点: 最终一致性,可靠消息保证                                 │   │
│  │                                                                  │   │
│  └──────────────────────────────────────────────────────────────────┘   │
│                                                                         │
│  ┌─────────────────────── 方案4: Seata框架 ─────────────────────────┐   │
│  │                                                                  │   │
│  │   支持AT/TCC/SAGA/XA多种模式                                    │   │
│  │                                                                  │   │
│  │   AT模式 (自动补偿,业务无侵入):                                  │   │
│  │   ┌────────────────────────────────────────────────────────────┐│   │
│  │   │                                                            ││   │
│  │   │  1. 解析SQL,记录修改前镜像(beforeImage)                   ││   │
│  │   │  2. 执行SQL                                               ││   │
│  │   │  3. 记录修改后镜像(afterImage)                            ││   │
│  │   │  4. 生成undo_log                                          ││   │
│  │   │  5. 提交本地事务                                          ││   │
│  │   │                                                            ││   │
│  │   │  回滚时: 根据undo_log自动生成反向SQL                      ││   │
│  │   │                                                            ││   │
│  │   └────────────────────────────────────────────────────────────┘│   │
│  │                                                                  │   │
│  └──────────────────────────────────────────────────────────────────┘   │
│                                                                         │
│  ┌─────────────────────── 方案选择建议 ─────────────────────────────┐   │
│  │                                                                  │   │
│  │   场景                      │  推荐方案                         │   │
│  │   ─────────────────────────────────────────────────────────────│   │
│  │   强一致性要求高             │  XA/Seata AT                     │   │
│  │   高性能,可接受最终一致性    │  本地消息表/可靠消息              │   │
│  │   复杂业务,需要灵活控制      │  TCC/SAGA                        │   │
│  │   简单场景                   │  Seata AT (开箱即用)             │   │
│  │                                                                  │   │
│  └──────────────────────────────────────────────────────────────────┘   │
│                                                                         │
└─────────────────────────────────────────────────────────────────────────┘
```

---

### 153. 数据迁移如何做？

```
┌─────────────────────────────────────────────────────────────────────────┐
│                          分库分表数据迁移方案                             │
├─────────────────────────────────────────────────────────────────────────┤
│                                                                         │
│  ┌─────────────────────── 停机迁移 (简单但有业务影响) ──────────────┐   │
│  │                                                                  │   │
│  │   1. 停止应用服务                                               │   │
│  │   2. 导出旧库数据                                               │   │
│  │   3. 按分片规则导入新库                                         │   │
│  │   4. 验证数据                                                   │   │
│  │   5. 切换应用配置,重启服务                                      │   │
│  │                                                                  │   │
│  │   适用: 数据量小,可接受短暂停机                                 │   │
│  │                                                                  │   │
│  └──────────────────────────────────────────────────────────────────┘   │
│                                                                         │
│  ┌─────────────────────── 双写迁移 (不停机) ────────────────────────┐   │
│  │                                                                  │   │
│  │   ┌────────────────────────────────────────────────────────────┐│   │
│  │   │                                                            ││   │
│  │   │  阶段1: 双写 (同时写新旧库)                                ││   │
│  │   │                                                            ││   │
│  │   │   应用 ────┬───→ 旧库 (主)                                ││   │
│  │   │           └───→ 新分库 (同步写)                           ││   │
│  │   │                                                            ││   │
│  │   │  阶段2: 历史数据迁移                                       ││   │
│  │   │                                                            ││   │
│  │   │   旧库 ─────→ 迁移程序 ─────→ 新分库                      ││   │
│  │   │   (增量迁移,通过binlog或时间戳)                            ││   │
│  │   │                                                            ││   │
│  │   │  阶段3: 数据校验                                           ││   │
│  │   │                                                            ││   │
│  │   │   对比新旧库数据,确保一致                                  ││   │
│  │   │                                                            ││   │
│  │   │  阶段4: 切换读                                             ││   │
│  │   │                                                            ││   │
│  │   │   应用读 ─────→ 新分库                                    ││   │
│  │   │   应用写 ─────→ 新旧库双写                                ││   │
│  │   │                                                            ││   │
│  │   │  阶段5: 切换写,下线旧库                                    ││   │
│  │   │                                                            ││   │
│  │   │   应用 ─────→ 新分库 (读写都走新库)                       ││   │
│  │   │                                                            ││   │
│  │   └────────────────────────────────────────────────────────────┘│   │
│  │                                                                  │   │
│  └──────────────────────────────────────────────────────────────────┘   │
│                                                                         │
│  ┌─────────────────────── 迁移流程图 ───────────────────────────────┐   │
│  │                                                                  │   │
│  │   ┌─────────────────────────────────────────────────────────┐   │   │
│  │   │                                                         │   │   │
│  │   │    ┌───────┐                         ┌───────────────┐ │   │   │
│  │   │    │ 旧单库 │                         │    新分库     │ │   │   │
│  │   │    │       │                         │ ┌───┐ ┌───┐  │ │   │   │
│  │   │    │ order │ ───全量迁移──────────→  │ │DB0│ │DB1│  │ │   │   │
│  │   │    │       │                         │ └───┘ └───┘  │ │   │   │
│  │   │    │       │ ───增量同步(binlog)───→ │ ┌───┐ ┌───┐  │ │   │   │
│  │   │    │       │                         │ │DB2│ │DB3│  │ │   │   │
│  │   │    └───────┘                         │ └───┘ └───┘  │ │   │   │
│  │   │                                       └───────────────┘ │   │   │
│  │   │                                                         │   │   │
│  │   └─────────────────────────────────────────────────────────┘   │   │
│  │                                                                  │   │
│  └──────────────────────────────────────────────────────────────────┘   │
│                                                                         │
│  ┌─────────────────────── 常用迁移工具 ─────────────────────────────┐   │
│  │                                                                  │   │
│  │  • Canal: 阿里开源,解析binlog,实现增量同步                      │   │
│  │  • DataX: 阿里开源,离线数据同步工具                             │   │
│  │  • Debezium: 基于Kafka的CDC工具                                 │   │
│  │  • gh-ost: GitHub开源,在线DDL工具                               │   │
│  │  • pt-online-schema-change: Percona工具                         │   │
│  │                                                                  │   │
│  └──────────────────────────────────────────────────────────────────┘   │
│                                                                         │
└─────────────────────────────────────────────────────────────────────────┘
```

```java
/**
 * 双写迁移代码示例
 */
@Service
public class OrderService {

    @Autowired
    private OldOrderMapper oldOrderMapper;

    @Autowired
    private NewShardingOrderMapper newShardingOrderMapper;

    @Autowired
    private MigrationConfig migrationConfig;

    /**
     * 双写模式下的创建订单
     */
    @Transactional
    public void createOrder(Order order) {
        // 1. 写入旧库
        oldOrderMapper.insert(order);

        // 2. 同时写入新分库
        if (migrationConfig.isDoubleWriteEnabled()) {
            try {
                newShardingOrderMapper.insert(order);
            } catch (Exception e) {
                // 新库写入失败不影响主流程,记录日志后续补偿
                log.error("写入新库失败", e);
                compensationService.addTask(order);
            }
        }
    }

    /**
     * 切换后的读取
     */
    public Order getOrder(Long orderId, Long userId) {
        if (migrationConfig.isReadFromNewDb()) {
            // 从新分库读取
            return newShardingOrderMapper.selectById(orderId, userId);
        } else {
            // 从旧库读取
            return oldOrderMapper.selectById(orderId);
        }
    }
}
```

---

### 154. ShardingSphere的原理？

```
┌─────────────────────────────────────────────────────────────────────────┐
│                     ShardingSphere 架构与原理                            │
├─────────────────────────────────────────────────────────────────────────┤
│                                                                         │
│  ┌─────────────────────── 产品定位 ─────────────────────────────────┐   │
│  │                                                                  │   │
│  │   Apache ShardingSphere 是一套开源的分布式数据库中间件解决方案    │   │
│  │                                                                  │   │
│  │   三个产品:                                                      │   │
│  │   • ShardingSphere-JDBC: 轻量级Java框架,增强版JDBC              │   │
│  │   • ShardingSphere-Proxy: 数据库代理,支持任意语言               │   │
│  │   • ShardingSphere-Sidecar: Kubernetes云原生方案(规划中)        │   │
│  │                                                                  │   │
│  └──────────────────────────────────────────────────────────────────┘   │
│                                                                         │
│  ┌─────────────────────── 架构对比 ─────────────────────────────────┐   │
│  │                                                                  │   │
│  │   ShardingSphere-JDBC                ShardingSphere-Proxy       │   │
│  │   ┌────────────────────┐             ┌────────────────────┐     │   │
│  │   │     Application    │             │     Application    │     │   │
│  │   │  ┌──────────────┐  │             └─────────┬──────────┘     │   │
│  │   │  │ShardingSphere│  │                       │                │   │
│  │   │  │    JDBC      │  │                       ↓                │   │
│  │   │  └───────┬──────┘  │             ┌────────────────────┐     │   │
│  │   └──────────┼─────────┘             │ ShardingSphere-Proxy│    │   │
│  │              │                        │    (独立进程)       │    │   │
│  │              ↓                        └─────────┬──────────┘     │   │
│  │   ┌──────────────────────┐                     │                │   │
│  │   │  DB0  │  DB1  │  DB2 │                     ↓                │   │
│  │   └──────────────────────┘           ┌──────────────────────┐   │   │
│  │                                       │  DB0  │  DB1  │  DB2 │  │   │
│  │   优点: 无代理,性能高                  └──────────────────────┘   │   │
│  │   缺点: 只支持Java                                              │   │
│  │                                       优点: 语言无关,运维友好    │   │
│  │                                       缺点: 多一层网络开销       │   │
│  │                                                                  │   │
│  └──────────────────────────────────────────────────────────────────┘   │
│                                                                         │
│  ┌─────────────────────── SQL执行流程 ──────────────────────────────┐   │
│  │                                                                  │   │
│  │   ┌────────────────────────────────────────────────────────────┐│   │
│  │   │                                                            ││   │
│  │   │   SQL: SELECT * FROM t_order WHERE user_id = 100          ││   │
│  │   │                          │                                 ││   │
│  │   │                          ↓                                 ││   │
│  │   │   ┌──────────────────────────────────────────────────────┐││   │
│  │   │   │  1. SQL解析 (Parsing)                                │││   │
│  │   │   │     解析SQL,生成抽象语法树(AST)                       │││   │
│  │   │   │     提取: 表名=t_order, 条件=user_id=100             │││   │
│  │   │   └──────────────────────────────────────────────────────┘││   │
│  │   │                          │                                 ││   │
│  │   │                          ↓                                 ││   │
│  │   │   ┌──────────────────────────────────────────────────────┐││   │
│  │   │   │  2. SQL路由 (Routing)                                │││   │
│  │   │   │     根据分片规则计算目标数据源和表                    │││   │
│  │   │   │     user_id=100 → db1.t_order_2                      │││   │
│  │   │   └──────────────────────────────────────────────────────┘││   │
│  │   │                          │                                 ││   │
│  │   │                          ↓                                 ││   │
│  │   │   ┌──────────────────────────────────────────────────────┐││   │
│  │   │   │  3. SQL改写 (Rewriting)                              │││   │
│  │   │   │     将逻辑SQL改写为真实SQL                           │││   │
│  │   │   │     t_order → t_order_2                              │││   │
│  │   │   └──────────────────────────────────────────────────────┘││   │
│  │   │                          │                                 ││   │
│  │   │                          ↓                                 ││   │
│  │   │   ┌──────────────────────────────────────────────────────┐││   │
│  │   │   │  4. SQL执行 (Executing)                              │││   │
│  │   │   │     发送到对应数据源执行                              │││   │
```
