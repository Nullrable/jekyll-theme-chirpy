---
title: 并发编程：单核计算机如何通过交替执行实现并发
author: nhsoft.lsd
date: 2025-11-18
categories: [Java,并发编程]
pin: false
---

## 任务A 与任务B 在单核 CPU 上交替运行

```
时间线 →
┌────────────────────────────────────────────────────────────┐
│                单核CPU执行流程（通过时间片调度）             │
├────────────┬────────────┬────────────┬────────────┬────────────┤
│ 时间片1     │ 时间片2     │ 时间片3     │ 时间片4     │ 时间片5     │
│            │            │            │            │            │
│→ 任务A运行  │→ 任务B运行  │→ 任务A运行  │→ 任务B运行  │→ 任务A运行  │
│（执行计算） │（发起IO）   │（处理结果） │（继续IO）   │（结束）     │
└────────────┴────────────┴────────────┴────────────┴────────────┘

       ↑
      任务A/B 不是真并行，而是轮流在 CPU 上运行
```

---

## 步骤：任务A 与任务B 如何“并发调用资源”

### 场景假设：

* **任务A**：需要处理 CPU 密集型计算（如压缩图片）
* **任务B**：需要处理 IO（如从硬盘读取文件）

---

### 步骤说明：

#### 时间片1：任务A开始运行

* 操作系统调度任务A占用 CPU。
* 任务A执行图片压缩运算（CPU密集型）。

#### 时间片2：切换到任务B

* 操作系统中断任务A，保存上下文。
* 切换到任务B，让其开始执行。
* 任务B读取文件，可能发起一个 IO 请求。

#### 时间片3：任务A继续

* 操作系统切换回任务A，继续执行压缩。
* 此时任务B的 IO 正在等待数据返回。

#### 时间片4：任务B继续

* IO 完成，任务B被唤醒，继续处理数据。
* 操作系统再次切回任务B。

#### 时间片5：任务A运行结束

* 任务A完成所有计算，退出。
* CPU 下一个时间片可以调度新的任务。

---

## 关键点总结：

| 问题             | 答案                                         |
| -------------- | ------------------------------------------ |
| 单核如何并发？        | 操作系统在不同任务之间快速切换，靠“时间片+上下文切换”模拟并发           |
| CPU 是谁在控制任务切换？ | 操作系统内核调度器                                  |
| IO操作时CPU是否空闲？  | 操作系统会将任务阻塞并切换到其他任务，避免CPU浪费                 |
| 是真正并行吗？        | ❌ 不是。CPU 同一时间只能执行一个任务，但交替运行让人“看起来”同时执行多个任务 |

---

## 举例

就像你有一台投影仪（CPU）和两部电影（任务A/B），你每10秒换一部来放：

* 虽然投影仪一次只能播放一部电影，但你快速切换，观众觉得两部电影都在“播放”。
* 这就是单核并发的本质：**快速切换制造“同时”的假象。**

---

