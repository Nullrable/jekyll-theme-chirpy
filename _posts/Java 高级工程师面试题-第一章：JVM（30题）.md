# Java 高级工程师面试题 - 第一章：JVM（30题）

---

## 第一节：内存模型（1-8题）

---

### 问题 1：JVM运行时数据区域有哪些？各自作用是什么？

**答案：**

JVM运行时数据区域分为**线程私有**和**线程共享**两大类：

```
┌─────────────────────────────────────────────────────────────┐
│                    JVM 运行时数据区域                         │
├─────────────────────────────────────────────────────────────┤
│  ┌─────────────────────────────────────────────────────┐    │
│  │              线程共享区域                             │    │
│  │  ┌─────────────────┐  ┌─────────────────────────┐   │    │
│  │  │      堆 Heap     │  │   方法区 Method Area    │   │    │
│  │  │  (对象实例分配)   │  │  (类信息/常量/静态变量)  │   │    │
│  │  └─────────────────┘  └─────────────────────────┘   │    │
│  └─────────────────────────────────────────────────────┘    │
│  ┌─────────────────────────────────────────────────────┐    │
│  │              线程私有区域                             │    │
│  │  ┌───────────┐ ┌───────────┐ ┌───────────────────┐  │    │
│  │  │  程序计数器 │ │  虚拟机栈  │ │   本地方法栈      │  │    │
│  │  │    (PC)    │ │(Java方法) │ │  (Native方法)    │  │    │
│  │  └───────────┘ └───────────┘ └───────────────────┘  │    │
│  └─────────────────────────────────────────────────────┘    │
└─────────────────────────────────────────────────────────────┘
```

**各区域详解：**

| 区域 | 线程属性 | 作用 | 异常 |
|------|----------|------|------|
| **程序计数器** | 私有 | 记录当前线程执行的字节码行号，分支/循环/跳转/异常处理依赖它 | 无 |
| **虚拟机栈** | 私有 | 存储栈帧（局部变量表、操作数栈、动态链接、方法出口） | StackOverflowError / OOM |
| **本地方法栈** | 私有 | 为Native方法服务 | StackOverflowError / OOM |
| **堆** | 共享 | 存放对象实例，GC主要管理区域 | OOM |
| **方法区** | 共享 | 存储类信息、常量、静态变量、JIT编译后的代码 | OOM |

**适用场景：** 面试基础题，考察对JVM内存结构的整体理解

---

**追问：程序计数器为什么是唯一不会OOM的区域？**

**答案：**
1. **空间固定且极小**：只存储一个地址值（指向下一条指令），通常只有几个字节
2. **生命周期与线程绑定**：线程创建时分配，线程销毁时回收，不存在动态扩展
3. **JVM规范规定**：这是唯一一个没有规定任何OutOfMemoryError的区域
4. **执行Native方法时为空**：不需要额外空间

---

### 问题 2：堆和栈的区别是什么？

**答案：**

```
┌─────────────────────────────────────────────────────────────────┐
│                         堆 vs 栈 对比                            │
├─────────────────────────────────────────────────────────────────┤
│                                                                  │
│   栈 (Stack)                      堆 (Heap)                     │
│   ┌─────────────┐                ┌─────────────────────┐        │
│   │  栈帧3(当前) │                │  ┌───┐ ┌───┐ ┌───┐  │        │
│   ├─────────────┤                │  │Obj│ │Obj│ │Obj│  │        │
│   │   栈帧2     │                │  └───┘ └───┘ └───┘  │        │
│   ├─────────────┤                │  ┌───┐    ┌───┐     │        │
│   │   栈帧1     │                │  │Obj│    │Obj│     │        │
│   └─────────────┘                │  └───┘    └───┘     │        │
│   LIFO 后进先出                   │  无序存储，GC管理    │        │
│                                  └─────────────────────┘        │
└─────────────────────────────────────────────────────────────────┘
```

**核心区别对比：**

| 对比维度 | 栈（Stack） | 堆（Heap） |
|----------|-------------|------------|
| **存储内容** | 局部变量、方法参数、返回地址 | 对象实例、数组 |
| **线程属性** | 线程私有 | 线程共享 |
| **生命周期** | 方法结束自动释放 | GC回收 |
| **空间大小** | 较小（默认1MB） | 较大（可配置几GB） |
| **分配速度** | 快（指针移动） | 慢（需要找空闲内存） |
| **数据结构** | LIFO栈结构 | 无序 |
| **碎片问题** | 无 | 有（需GC整理） |
| **溢出异常** | StackOverflowError | OutOfMemoryError |

**代码示例：**

```java
public void method() {
    int a = 10;              // 栈：基本类型直接存值
    String s = "hello";      // 栈：存引用，堆：存字符串对象
    Object obj = new Object(); // 栈：存引用，堆：存Object实例
}
```

**适用场景：** 考察对内存分配的基本理解，是JVM入门级问题

---

**追问：基本类型一定在栈上吗？**

**答案：**

**不一定！** 要看具体场景：

```java
// 1. 局部变量 - 在栈上
public void test() {
    int a = 10;  // ✓ 栈上
}

// 2. 成员变量 - 在堆上（跟随对象）
public class Person {
    private int age = 20;  // ✓ 堆上（作为对象的一部分）
}

// 3. 静态变量 - 在方法区/元空间
public class Config {
    public static int count = 0;  // ✓ 方法区
}

// 4. 数组元素 - 在堆上
int[] arr = new int[10];  // 数组在堆上，元素也在堆上
```

---

### 问题 3：方法区和永久代、元空间的关系？

**答案：**

```
┌─────────────────────────────────────────────────────────────────┐
│                    方法区的演进历史                               │
├─────────────────────────────────────────────────────────────────┤
│                                                                  │
│  ┌──────────────────────────────────────────────────────────┐   │
│  │  方法区 (Method Area) - JVM规范定义的抽象概念              │   │
│  │  作用：存储类信息、常量、静态变量、JIT编译后代码            │   │
│  └──────────────────────────────────────────────────────────┘   │
│                           │                                      │
│            ┌──────────────┴──────────────┐                      │
│            ▼                             ▼                       │
│  ┌─────────────────────┐     ┌─────────────────────┐            │
│  │  JDK 7 及之前        │     │  JDK 8 及之后        │            │
│  │  永久代 PermGen      │     │  元空间 Metaspace   │            │
│  │  ┌───────────────┐  │     │  ┌───────────────┐  │            │
│  │  │ -XX:PermSize  │  │     │  │ 使用本地内存   │  │            │
│  │  │ -XX:MaxPermSize│ │     │  │ -XX:Metaspace │  │            │
│  │  │ 堆内存的一部分 │  │     │  │  Size        │  │            │
│  │  └───────────────┘  │     │  └───────────────┘  │            │
│  └─────────────────────┘     └─────────────────────┘            │
└─────────────────────────────────────────────────────────────────┘
```

**三者关系：**

| 概念 | 性质 | 说明 |
|------|------|------|
| **方法区** | JVM规范 | 抽象定义，规定了功能职责 |
| **永久代** | HotSpot实现 | JDK7及之前的具体实现，使用堆内存 |
| **元空间** | HotSpot实现 | JDK8及之后的实现，使用本地内存 |

**为什么要用元空间替代永久代？**

```
永久代的问题：
├── 1. 大小固定，容易OOM（类加载过多时）
├── 2. 字符串常量池在永久代，容易溢出
├── 3. 难以调优，参数设置复杂
└── 4. GC效率低，Full GC才会回收

元空间的优势：
├── 1. 使用本地内存，空间更大
├── 2. 字符串常量池移到堆中
├── 3. 类元数据按需分配，自动调整
└── 4. 减少Full GC频率
```

**适用场景：** 考察JVM版本演进知识，常见于追问

---

**追问：JDK 8中字符串常量池在哪里？**

**答案：**

```java
// JDK 6：字符串常量池在永久代
// JDK 7：字符串常量池移到堆中（永久代还在）
// JDK 8：字符串常量池在堆中，永久代变为元空间

String s1 = "hello";           // 字符串常量池（堆中）
String s2 = new String("hello"); // 堆中新对象
String s3 = s2.intern();       // 返回常量池中的引用

System.out.println(s1 == s3);  // true（都指向常量池）
System.out.println(s1 == s2);  // false（s2在堆中是新对象）
```

**移动到堆的好处：**
- 可以被正常GC回收，避免永久代OOM
- 享受堆的调优参数
- 减少永久代的内存压力

---

### 问题 4：直接内存是什么？如何使用？

**答案：**

**直接内存（Direct Memory）**是JVM堆外的内存，通过 `Native` 方法直接分配，不受JVM堆大小限制。

```
┌─────────────────────────────────────────────────────────────────┐
│                       JVM 内存布局                               │
├─────────────────────────────────────────────────────────────────┤
│                                                                  │
│   JVM 进程内存                                                   │
│   ┌─────────────────────────────────────────────────────────┐   │
│   │                    JVM 管理的内存                         │   │
│   │   ┌──────────┐  ┌──────────┐  ┌──────────┐              │   │
│   │   │    堆     │  │  方法区   │  │    栈    │              │   │
│   │   │  (Heap)  │  │(Metaspace)│  │ (Stack)  │              │   │
│   │   └──────────┘  └──────────┘  └──────────┘              │   │
│   └─────────────────────────────────────────────────────────┘   │
│                                                                  │
│   ┌─────────────────────────────────────────────────────────┐   │
│   │                   直接内存 (Direct Memory)                │   │
│   │            通过 Unsafe 或 DirectByteBuffer 分配           │   │
│   │                    不受 -Xmx 限制                         │   │
│   └─────────────────────────────────────────────────────────┘   │
│                                                                  │
└─────────────────────────────────────────────────────────────────┘
```

**使用方式：**

```java
// 方式1：通过 ByteBuffer 分配直接内存
ByteBuffer directBuffer = ByteBuffer.allocateDirect(1024 * 1024); // 1MB

// 方式2：通过 Unsafe 类（不推荐直接使用）
Unsafe unsafe = getUnsafe();
long address = unsafe.allocateMemory(1024 * 1024);
// 使用完必须手动释放
unsafe.freeMemory(address);
```

**直接内存 vs 堆内存：**

| 对比项 | 堆内存 | 直接内存 |
|--------|--------|----------|
| 分配速度 | 快 | 慢（系统调用） |
| 读写速度 | 需要拷贝 | 零拷贝，更快 |
| GC影响 | 受GC管理 | 不受GC直接管理 |
| 内存限制 | -Xmx限制 | -XX:MaxDirectMemorySize |
| 使用场景 | 普通对象 | NIO、大文件读写 |

**适用场景：** NIO相关面试，考察堆外内存理解

---

**追问：直接内存会导致OOM吗？如何排查？**

**答案：**

**会导致OOM！** 虽然直接内存不在堆中，但也受限于物理内存和 `-XX:MaxDirectMemorySize` 参数。

```java
// 可能导致直接内存OOM的场景
List<ByteBuffer> buffers = new ArrayList<>();
while (true) {
    // 不断分配直接内存
    buffers.add(ByteBuffer.allocateDirect(1024 * 1024 * 100)); // 100MB
}
// 抛出: java.lang.OutOfMemoryError: Direct buffer memory
```

**排查方法：**

```bash
# 1. JVM参数监控
-XX:MaxDirectMemorySize=256m  # 设置上限
-XX:+PrintGCDetails           # GC日志

# 2. 使用工具
jcmd <pid> VM.native_memory summary  # 查看本地内存

# 3. 代码检查
# 检查是否有 ByteBuffer.allocateDirect() 未释放
```

---

### 问题 5：对象在内存中的布局是怎样的？

**答案：**

HotSpot虚拟机中，对象在堆内存中的布局分为三部分：

```
┌─────────────────────────────────────────────────────────────────┐
│                      对象内存布局 (64位JVM)                       │
├─────────────────────────────────────────────────────────────────┤
│                                                                  │
│  ┌────────────────────────────────────────────────────────────┐ │
│  │                    对象头 (Object Header)                   │ │
│  │  ┌─────────────────────────────────────────────────────┐   │ │
│  │  │ Mark Word (8字节)                                    │   │ │
│  │  │ ┌───────────────────────────────────────────────┐   │   │ │
│  │  │ │ 哈希码 │ GC年龄 │ 锁状态 │ 线程ID │ Epoch │ ...  │   │   │ │
│  │  │ └───────────────────────────────────────────────┘   │   │ │
│  │  ├─────────────────────────────────────────────────────┤   │ │
│  │  │ Klass Pointer (4/8字节) - 指向类元数据                │   │ │
│  │  ├─────────────────────────────────────────────────────┤   │ │
│  │  │ 数组长度 (4字节) - 仅数组对象有                       │   │ │
│  │  └─────────────────────────────────────────────────────┘   │ │
│  ├────────────────────────────────────────────────────────────┤ │
│  │                    实例数据 (Instance Data)                 │ │
│  │  ┌─────────────────────────────────────────────────────┐   │ │
│  │  │ 父类字段 │ 本类字段 │ 按类型排列优化存储空间           │   │ │
│  │  └─────────────────────────────────────────────────────┘   │ │
│  ├────────────────────────────────────────────────────────────┤ │
│  │                    对齐填充 (Padding)                       │ │
│  │  ┌─────────────────────────────────────────────────────┐   │ │
│  │  │ 补齐到8字节的整数倍                                   │   │ │
│  │  └─────────────────────────────────────────────────────┘   │ │
│  └────────────────────────────────────────────────────────────┘ │
└─────────────────────────────────────────────────────────────────┘
```

**Mark Word 详细结构（64位）：**

| 锁状态 | 存储内容 | 标志位 |
|--------|----------|--------|
| 无锁 | hashcode(31) + age(4) + biased(1) | 01 |
| 偏向锁 | threadId(54) + epoch(2) + age(4) + biased(1) | 01 |
| 轻量级锁 | 指向栈中锁记录的指针(62) | 00 |
| 重量级锁 | 指向Monitor的指针(62) | 10 |
| GC标记 | 空 | 11 |

**代码验证（使用JOL工具）：**

```java
// 引入依赖：org.openjdk.jol:jol-core
public class ObjectLayoutDemo {
    public static void main(String[] args) {
        Object obj = new Object();
        System.out.println(ClassLayout.parseInstance(obj).toPrintable());
    }
}

// 输出示例（开启指针压缩）：
// OFFSET  SIZE   TYPE DESCRIPTION
//      0     4        (object header) mark word
//      4     4        (object header) mark word
//      8     4        (object header) klass pointer
//     12     4        (loss due to padding) 对齐填充
// Instance size: 16 bytes
```

**适用场景：** 深入理解synchronized锁升级、对象大小计算

---

**追问：一个Object对象占多少字节？**

**答案：**

```
开启指针压缩（默认）：
├── Mark Word: 8字节
├── Klass Pointer: 4字节（压缩后）
├── 实例数据: 0字节
├── 对齐填充: 4字节（补齐到16）
└── 总计: 16字节

关闭指针压缩：
├── Mark Word: 8字节
├── Klass Pointer: 8字节
├── 实例数据: 0字节
├── 对齐填充: 0字节
└── 总计: 16字节

// 验证
System.out.println(ObjectSizeCalculator.getObjectSize(new Object())); // 16
```

---

### 问题 6：对象的创建过程是怎样的？

**答案：**

```
┌─────────────────────────────────────────────────────────────────┐
│                      对象创建完整流程                            │
├─────────────────────────────────────────────────────────────────┤
│                                                                  │
│   new Object()                                                  │
│        │                                                        │
│        ▼                                                        │
│   ┌─────────────────────────────────────────┐                  │
│   │ 1. 类加载检查                            │                  │
│   │    检查类是否已加载、解析、初始化         │                  │
│   │    如果没有，先执行类加载过程             │                  │
│   └─────────────────────────────────────────┘                  │
│        │                                                        │
│        ▼                                                        │
│   ┌─────────────────────────────────────────┐                  │
│   │ 2. 分配内存                              │                  │
│   │    根据堆是否规整选择分配方式：           │                  │
│   │    • 指针碰撞（规整堆）                   │                  │
│   │    • 空闲列表（不规整堆）                 │                  │
│   └─────────────────────────────────────────┘                  │
│        │                                                        │
│        ▼                                                        │
│   ┌─────────────────────────────────────────┐                  │
│   │ 3. 处理并发安全                          │                  │
│   │    • CAS + 失败重试                      │                  │
│   │    • TLAB (Thread Local Allocation Buffer)│                 │
│   └─────────────────────────────────────────┘                  │
│        │                                                        │
│        ▼                                                        │
│   ┌─────────────────────────────────────────┐                  │
│   │ 4. 初始化零值                            │                  │
│   │    所有字段设为默认值(0/null/false)      │                  │
│   └─────────────────────────────────────────┘                  │
│        │                                                        │
│        ▼                                                        │
│   ┌─────────────────────────────────────────┐                  │
│   │ 5. 设置对象头                            │                  │
│   │    Mark Word, Klass Pointer等           │                  │
│   └─────────────────────────────────────────┘                  │
│        │                                                        │
│        ▼                                                        │
│   ┌─────────────────────────────────────────┐                  │
│   │ 6. 执行<init>方法                        │                  │
│   │    执行构造函数，真正初始化对象           │                  │
│   └─────────────────────────────────────────┘                  │
│        │                                                        │
│        ▼                                                        │
│   对象创建完成，返回引用                                         │
│                                                                  │
└─────────────────────────────────────────────────────────────────┘
```

**内存分配方式对比：**

| 分配方式 | 条件 | 原理 | 对应收集器 |
|----------|------|------|------------|
| **指针碰撞** | 堆内存规整 | 移动指针分割已用/未用区域 | Serial、ParNew |
| **空闲列表** | 堆内存不规整 | 维护列表记录可用内存块 | CMS |

**TLAB机制：**

```
┌─────────────────────────────────────────────────┐
│                    堆内存                        │
│  ┌─────────┐ ┌─────────┐ ┌─────────┐           │
│  │ Thread1 │ │ Thread2 │ │ Thread3 │           │
│  │  TLAB   │ │  TLAB   │ │  TLAB   │    ...    │
│  │  私有   │ │  私有   │ │  私有   │           │
│  └─────────┘ └─────────┘ └─────────┘           │
│                                                 │
│  每个线程预先分配一小块内存，分配对象时无需加锁   │
└─────────────────────────────────────────────────┘
```

**适用场景：** 理解对象创建的底层机制，与并发和GC知识关联

---

**追问：什么是逃逸分析？对象一定在堆上分配吗？**

**答案：**

**逃逸分析**是JIT编译器的优化技术，分析对象的作用域：

```java
// 未逃逸 - 可能在栈上分配
public void test() {
    Point p = new Point(1, 2);  // 对象只在方法内使用
    System.out.println(p.x + p.y);
}

// 方法逃逸 - 必须在堆上
public Point createPoint() {
    return new Point(1, 2);  // 对象被返回，逃出方法
}

// 线程逃逸 - 必须在堆上
public void test() {
    Point p = new Point(1, 2);
    new Thread(() -> System.out.println(p)).start();  // 被其他线程访问
}
```

**逃逸分析的优化：**

| 优化类型 | 说明 | 条件 |
|----------|------|------|
| **栈上分配** | 对象直接在栈帧中分配 | 对象未逃逸 |
| **标量替换** | 将对象拆解为基本类型变量 | 对象未逃逸 |
| **锁消除** | 去掉不必要的同步 | 对象未线程逃逸 |

```bash
# 开启逃逸分析（JDK 8默认开启）
-XX:+DoEscapeAnalysis
# 开启标量替换
-XX:+EliminateAllocations
```

---

### 问题 7：如何判断对象是否存活？

**答案：**

主要有两种算法：

```
┌─────────────────────────────────────────────────────────────────┐
│                     对象存活判断算法                              │
├─────────────────────────────────────────────────────────────────┤
│                                                                  │
│  方法一：引用计数法（JVM不使用）                                  │
│  ┌─────────────────────────────────────────────────────────┐    │
│  │  原理：对象被引用时计数+1，引用失效时-1，为0则可回收       │    │
│  │                                                          │    │
│  │  优点：实现简单，判断效率高                               │    │
│  │                                                          │    │
│  │  致命缺陷：无法解决循环引用问题                           │    │
│  │  ┌─────┐         ┌─────┐                                │    │
│  │  │  A  │────────▶│  B  │                                │    │
│  │  │ rc=1│◀────────│ rc=1│                                │    │
│  │  └─────┘         └─────┘                                │    │
│  │  A和B互相引用，但无外部引用，计数永远不为0                │    │
│  └─────────────────────────────────────────────────────────┘    │
│                                                                  │
│  方法二：可达性分析（JVM使用）                                    │
│  ┌─────────────────────────────────────────────────────────┐    │
│  │  原理：从GC Roots出发，遍历引用链，不可达对象即为垃圾      │    │
│  │                                                          │    │
│  │      GC Roots                                            │    │
│  │          │                                               │    │
│  │          ▼                                               │    │
│  │      ┌───────┐     ┌───────┐     ┌───────┐              │    │
│  │      │ Obj1  │────▶│ Obj2  │────▶│ Obj3  │  ✓ 存活      │    │
│  │      └───────┘     └───────┘     └───────┘              │    │
│  │                                                          │    │
│  │      ┌───────┐     ┌───────┐                            │    │
│  │      │ Obj4  │────▶│ Obj5  │  ✗ 不可达，可回收          │    │
│  │      └───────┘     └───────┘                            │    │
│  └─────────────────────────────────────────────────────────┘    │
│                                                                  │
└─────────────────────────────────────────────────────────────────┘
```

**GC Roots 包括：**

| GC Root 类型 | 说明 |
|--------------|------|
| 虚拟机栈引用的对象 | 栈帧中局部变量表引用的对象 |
| 方法区静态属性引用 | static修饰的引用类型变量 |
| 方法区常量引用 | final修饰的引用类型常量 |
| 本地方法栈JNI引用 | Native方法引用的对象 |
| 同步锁持有的对象 | synchronized锁定的对象 |
| JVM内部引用 | 基本类型Class对象、异常对象、类加载器等 |

**适用场景：** GC原理的基础问题，经常与垃圾回收器结合考察

---

**追问：对象不可达就一定会被回收吗？**

**答案：**

**不一定！** 对象有一次自救机会：

```
┌─────────────────────────────────────────────────────────────────┐
│                      对象回收的两次标记                          │
├─────────────────────────────────────────────────────────────────┤
│                                                                  │
│   对象不可达                                                     │
│        │                                                        │
│        ▼                                                        │
│   ┌─────────────────────────────────────────┐                  │
│   │ 第一次标记                               │                  │
│   │ 判断是否需要执行 finalize()              │                  │
│   └─────────────────────────────────────────┘                  │
│        │                                                        │
│        ├── 未覆盖finalize() ──▶ 直接回收                       │
│        │                                                        │
│        ├── finalize()已被调用过 ──▶ 直接回收                   │
│        │                                                        │
│        └── 需要执行finalize() ──▶ 放入F-Queue队列               │
│                                        │                        │
│                                        ▼                        │
│                               低优先级线程执行                   │
│                               finalize()方法                    │
│                                        │                        │
│        ┌───────────────────────────────┴────────────┐          │
│        │                                            │           │
│        ▼                                            ▼           │
│   finalize()中重新                            未建立引用         │
│   建立引用（自救成功）                          第二次标记        │
│        │                                            │           │
│        ▼                                            ▼           │
│   移出待回收集合                                  真正回收        │
│                                                                  │
└─────────────────────────────────────────────────────────────────┘
```

**代码示例：**

```java
public class FinalizeDemo {
    private static FinalizeDemo instance;

    @Override
    protected void finalize() throws Throwable {
        super.finalize();
        System.out.println("finalize执行，自救...");
        instance = this;  // 自救：重新建立引用
    }

    public static void main(String[] args) throws Exception {
        instance = new FinalizeDemo();

        // 第一次回收
        instance = null;
        System.gc();
        Thread.sleep(500);
        System.out.println(instance != null ? "存活" : "死亡");  // 存活

        // 第二次回收 - finalize只会执行一次
        instance = null;
        System.gc();
        Thread.sleep(500);
        System.out.println(instance != null ? "存活" : "死亡");  // 死亡
    }
}
```

> ⚠️ **注意**：`finalize()` 已被废弃，不推荐使用，应使用 `try-with-resources` 或 `Cleaner`

---

### 问题 8：强引用、软引用、弱引用、虚引用的区别？

**答案：**

```
┌─────────────────────────────────────────────────────────────────┐
│                      Java四种引用类型                            │
├─────────────────────────────────────────────────────────────────┤
│                                                                  │
│  引用强度：强引用 > 软引用 > 弱引用 > 虚引用                      │
│                                                                  │
│  ┌─────────────────────────────────────────────────────────┐    │
│  │ 强引用 (Strong Reference)                                │    │
│  │ Object obj = new Object();                               │    │
│  │ • 最常见的引用                                           │    │
│  │ • 只要强引用存在，GC绝不回收                             │    │
│  │ • 可能导致内存泄漏                                       │    │
│  └─────────────────────────────────────────────────────────┘    │
│                          │                                      │
│                          ▼ 内存不足时                            │
│  ┌─────────────────────────────────────────────────────────┐    │
│  │ 软引用 (Soft Reference)                                  │    │
│  │ SoftReference<Object> soft = new SoftReference<>(obj);   │    │
│  │ • 内存充足时不回收                                       │    │
│  │ • 内存不足时（OOM前）回收                                │    │
│  │ • 适合缓存场景                                           │    │
│  └─────────────────────────────────────────────────────────┘    │
│                          │                                      │
│                          ▼ GC时                                 │
│  ┌─────────────────────────────────────────────────────────┐    │
│  │ 弱引用 (Weak Reference)                                  │    │
│  │ WeakReference<Object> weak = new WeakReference<>(obj);   │    │
│  │ • 不管内存是否充足，GC时都会回收                         │    │
│  │ • 生命周期只到下次GC                                     │    │
│  │ • ThreadLocal使用弱引用                                  │    │
│  └─────────────────────────────────────────────────────────┘    │
│                          │                                      │
│                          ▼ 形同虚设                              │
│  ┌─────────────────────────────────────────────────────────┐    │
│  │ 虚引用 (Phantom Reference)                               │    │
│  │ PhantomReference<Object> phantom =                       │    │
│  │     new PhantomReference<>(obj, queue);                  │    │
│  │ • 无法通过虚引用获取对象                                 │    │
│  │ • 唯一作用：对象回收时收到系统通知                       │    │
│  │ • 必须配合ReferenceQueue使用                             │    │
│  └─────────────────────────────────────────────────────────┘    │
│                                                                  │
└─────────────────────────────────────────────────────────────────┘
```

**对比总结：**

| 引用类型 | 回收时机 | get()返回 | 使用场景 |
|----------|----------|-----------|----------|
| 强引用 | 不会回收 | 对象本身 | 正常使用 |
| 软引用 | 内存不足时 | 对象或null | 缓存 |
| 弱引用 | GC时 | 对象或null | ThreadLocal、WeakHashMap |
| 虚引用 | GC时 | 始终null | 追踪对象回收、堆外内存管理 |

**代码示例：**

```java
// 1. 软引用 - 缓存实现
public class SoftCache<K, V> {
    private Map<K, SoftReference<V>> cache = new HashMap<>();

    public void put(K key, V value) {
        cache.put(key, new SoftReference<>(value));
    }

    public V get(K key) {
        SoftReference<V> ref = cache.get(key);
        return ref != null ? ref.get() : null;  // 可能返回null
    }
}

// 2. 弱引用 - ThreadLocal原理
static class ThreadLocalMap {
    static class Entry extends WeakReference<ThreadLocal<?>> {
        Object value;
        Entry(ThreadLocal<?> k, Object v) {
            super(k);  // key是弱引用
            value = v;
        }
    }
}

// 3. 虚引用 - 监控对象回收
ReferenceQueue<Object> queue = new ReferenceQueue<>();
PhantomReference<Object> phantom = new PhantomReference<>(new Object(), queue);
System.gc();
Reference<?> ref = queue.poll();  // 对象被回收后，引用进入队列
```

**适用场景：** 缓存设计、ThreadLocal原理、NIO堆外内存管理

---

**追问：WeakHashMap的原理和使用场景？**

**答案：**

```java
// WeakHashMap的Entry继承WeakReference
private static class Entry<K,V> extends WeakReference<Object>
    implements Map.Entry<K,V> {
    V value;
    // key是弱引用，value是强引用
}

// 使用场景：缓存，key没有其他强引用时自动清理
WeakHashMap<Object, String> map = new WeakHashMap<>();
Object key = new Object();
map.put(key, "value");
System.out.println(map.size());  // 1

key = null;  // 移除强引用
System.gc();
Thread.sleep(100);
System.out.println(map.size());  // 0，Entry被自动清理
```

---

## 第二节：垃圾回收（9-18题）

---

### 问题 9：垃圾回收算法有哪些？各自的优缺点？

**答案：**

```
┌─────────────────────────────────────────────────────────────────┐
│                       垃圾回收算法                               │
├─────────────────────────────────────────────────────────────────┤
│                                                                  │
│  1. 标记-清除 (Mark-Sweep)                                      │
│  ┌──────────────────────────────────────────────────────────┐   │
│  │  回收前：[■][■][□][■][□][□][■][■][□][■]                  │   │
│  │            ↓  标记存活对象                                │   │
│  │  标记后：[■][■][□][■][□][□][■][■][□][■]                  │   │
│  │            ↓  清除未标记对象                               │   │
│  │  回收后：[■][■][ ][■][ ][ ][■][■][ ][■]  ← 内存碎片       │   │
│  └──────────────────────────────────────────────────────────┘   │
│                                                                  │
│  2. 标记-复制 (Mark-Copy)                                       │
│  ┌──────────────────────────────────────────────────────────┐   │
│  │  From区：[■][■][□][■][□][□][■]       To区：[           ] │   │
│  │              ↓  复制存活对象到To区                        │   │
│  │  From区：[             ]            To区：[■][■][■][■]   │   │
│  │              ↓  交换From和To                              │   │
│  │  内存连续，无碎片                                         │   │
│  └──────────────────────────────────────────────────────────┘   │
│                                                                  │
│  3. 标记-整理 (Mark-Compact)                                    │
│  ┌──────────────────────────────────────────────────────────┐   │
│  │  回收前：[■][■][□][■][□][□][■][■][□][■]                  │   │
│  │            ↓  标记存活对象                                │   │
│  │            ↓  整理：移动存活对象到一端                     │   │
│  │  回收后：[■][■][■][■][■][■][          ]  ← 无碎片        │   │
│  └──────────────────────────────────────────────────────────┘   │
│                                                                  │
└─────────────────────────────────────────────────────────────────┘
```

**算法对比：**

| 算法 | 优点 | 缺点 | 适用场景 |
|------|------|------|----------|
| **标记-清除** | 实现简单 | 内存碎片、效率不高 | CMS老年代 |
| **标记-复制** | 无碎片、效率高 | 空间浪费50% | 新生代（存活率低） |
| **标记-整理** | 无碎片、空间利用高 | 移动对象成本高 | 老年代（存活率高） |

**实际应用组合：**

```
┌────────────────────────────────────────┐
│              分代收集                   │
├────────────────────────────────────────┤
│  新生代（对象存活率低）                  │
│  └── 标记-复制算法                      │
│      Eden:Survivor = 8:1:1             │
│      只浪费10%空间                      │
│                                        │
│  老年代（对象存活率高）                  │
│  └── 标记-清除 或 标记-整理             │
│      CMS用标记-清除                    │
│      Serial Old用标记-整理             │
└────────────────────────────────────────┘
```

**适用场景：** GC基础知识，必考题

---

**追问：为什么新生代用复制算法而不是标记整理？**

**答案：**

1. **存活率低**：新生代98%对象朝生夕死，复制的对象很少
2. **效率更高**：只需遍历存活对象，不需要遍历整个堆
3. **内存连续**：复制完成后内存天然连续，分配效率高
4. **空间换时间**：Survivor区设计（8:1:1）只浪费10%空间

---

### 问题 10：什么是分代收集？为什么要分代？

**答案：**

```
┌─────────────────────────────────────────────────────────────────┐
│                         堆内存分代结构                           │
├─────────────────────────────────────────────────────────────────┤
│                                                                  │
│  ┌────────────────────────────────────────────────────────────┐ │
│  │                      新生代 (Young Generation)              │ │
│  │                         1/3 堆空间                          │ │
│  │  ┌─────────────────┐ ┌─────────┐ ┌─────────┐              │ │
│  │  │      Eden       │ │   S0    │ │   S1    │              │ │
│  │  │       8         │ │    1    │ │    1    │              │ │
│  │  │   新对象分配     │ │Survivor │ │Survivor │              │ │
│  │  └─────────────────┘ └─────────┘ └─────────┘              │ │
│  │            │              │            ▲                   │ │
│  │            └──── Minor GC ─┴───────────┘                   │ │
│  └────────────────────────────────────────────────────────────┘ │
│                            │                                     │
│                            │ 年龄达到阈值(默认15)                 │
│                            ▼ 或Survivor放不下                    │
│  ┌────────────────────────────────────────────────────────────┐ │
│  │                      老年代 (Old Generation)                │ │
│  │                         2/3 堆空间                          │ │
│  │  ┌──────────────────────────────────────────────────────┐  │ │
│  │  │     长期存活对象 / 大对象 / Survivor放不下的对象       │  │ │
│  │  │                                                       │  │ │
│  │  │                    Major GC / Full GC                 │  │ │
│  │  └──────────────────────────────────────────────────────┘  │ │
│  └────────────────────────────────────────────────────────────┘ │
│                                                                  │
└─────────────────────────────────────────────────────────────────┘
```

**为什么要分代？**

**基于"弱分代假说"和"强分代假说"：**

| 假说 | 内容 | 设计决策 |
|------|------|----------|
| 弱分代假说 | 绝大多数对象都是朝生夕死 | 新生代用复制算法，频繁GC |
| 强分代假说 | 熬过多次GC的对象难以消亡 | 老年代单独管理，减少GC频率 |
| 跨代引用假说 | 跨代引用相对同代引用极少 | 记忆集避免全堆扫描 |

**分代的好处：**

```java
// 不分代的问题
1. 每次GC都扫描整个堆 → 效率低
2. 所有对象用同一种算法 → 不是最优
3. 频繁Full GC → STW时间长

// 分代后的优化
1. Minor GC只扫描新生代 → 快速（几十ms）
2. 不同代用最适合的算法 → 效率最优
3. 大部分GC是Minor GC → 减少停顿
```

**对象晋升老年代的条件：**

1. **年龄达到阈值**：默认15（`-XX:MaxTenuringThreshold`）
2. **Survivor空间不足**：Minor GC后存活对象超过Survivor一半
3. **大对象直接进入**：超过阈值直接分配老年代（`-XX:PretenureSizeThreshold`）
4. **动态年龄判断**：相同年龄对象总大小超过Survivor一半，该年龄及以上对象晋升

**适用场景：** GC策略选择的理论基础

---

**追问：什么是跨代引用？如何处理？**

**答案：**

```
跨代引用场景：
┌─────────────────────────────────────────────┐
│  老年代                                      │
│  ┌─────────┐                                │
│  │  OldObj │──────引用─────┐               │
│  └─────────┘               │               │
└────────────────────────────│───────────────┘
                             ▼
┌────────────────────────────────────────────┐
│  新生代                                     │
│  ┌─────────┐                               │
│  │ YoungObj│  ← 如果只扫描新生代，会漏掉    │
│  └─────────┘    这个跨代引用，错误回收      │
└────────────────────────────────────────────┘

解决方案：记忆集 (Remembered Set)
┌─────────────────────────────────────────────┐
│  老年代                                      │
│  ┌─────────┐     ┌─────────────────────┐   │
│  │  OldObj │     │ Card Table (卡表)   │   │
│  └─────────┘     │ 记录哪些老年代区域   │   │
│      │           │ 有指向新生代的引用   │   │
│      ▼           └─────────────────────┘   │
└─────────────────────────────────────────────┘

Minor GC时：
1. 扫描新生代 GC Roots
2. 扫描卡表中标记为脏的老年代区域
3. 避免扫描整个老年代
```

---

### 问题 11：Minor GC、Major GC、Full GC的区别？

**答案：**

```
┌─────────────────────────────────────────────────────────────────┐
│                         GC类型对比                               │
├─────────────────────────────────────────────────────────────────┤
│                                                                  │
│  ┌────────────────────────────────────────────────────────────┐ │
│  │  Minor GC (Young GC)                                        │ │
│  │  ├── 范围：只回收新生代                                      │ │
│  │  ├── 触发：Eden区满                                         │ │
│  │  ├── 频率：高（秒级）                                        │ │
│  │  ├── 速度：快（几ms ~ 几十ms）                              │ │
│  │  └── 特点：会触发STW，但时间短                               │ │
│  └────────────────────────────────────────────────────────────┘ │
│                                                                  │
│  ┌────────────────────────────────────────────────────────────┐ │
│  │  Major GC (Old GC)                                          │ │
│  │  ├── 范围：只回收老年代                                      │ │
│  │  ├── 触发：老年代空间不足                                    │ │
│  │  ├── 特点：只有CMS收集器有单独的Old GC                       │ │
│  │  └── 注意：很多时候Major GC和Full GC混用                    │ │
│  └────────────────────────────────────────────────────────────┘ │
│                                                                  │
│  ┌────────────────────────────────────────────────────────────┐ │
│  │  Full GC                                                     │ │
│  │  ├── 范围：整个堆 + 方法区/元空间                            │ │
│  │  ├── 频率：低                                                │ │
│  │  ├── 速度：慢（几百ms ~ 几秒）                               │ │
│  │  └── 影响：STW时间长，需要尽量避免                           │ │
│  └────────────────────────────────────────────────────────────┘ │
│                                                                  │
│  ┌────────────────────────────────────────────────────────────┐ │
│  │  Mixed GC (G1特有)                                          │ │
│  │  ├── 范围：整个新生代 + 部分老年代                           │ │
│  │  ├── 特点：G1收集器独有                                      │ │
│  │  └── 目标：在可控时间内回收最有价值的Region                  │ │
│  └────────────────────────────────────────────────────────────┘ │
│                                                                  │
└─────────────────────────────────────────────────────────────────┘
```

**触发Full GC的条件：**

| 触发条件 | 说明 |
|----------|------|
| 老年代空间不足 | 大对象、长期存活对象填满老年代 |
| 方法区/元空间不足 | 类元数据过多 |
| 显式调用System.gc() | 建议JVM执行Full GC（可能被忽略） |
| Minor GC晋升失败 | 老年代没有足够空间容纳晋升对象 |
| CMS并发失败 | 并发标记期间老年代被填满 |

**适用场景：** GC调优时需要区分不同GC类型

---

**追问：如何减少Full GC的频率？**

**答案：**

```java
// 1. 合理设置堆大小
-Xms4g -Xmx4g  // 初始和最大堆一致，避免动态扩展

// 2. 调整新生代比例
-XX:NewRatio=2  // 老年代:新生代 = 2:1
-Xmn2g          // 直接设置新生代大小

// 3. 调整晋升年龄
-XX:MaxTenuringThreshold=15  // 增大晋升年龄

// 4. 避免大对象
-XX:PretenureSizeThreshold=1m  // 超过1M直接进老年代

// 5. 选择合适的收集器
-XX:+UseG1GC  // G1通过Mixed GC避免Full GC

// 6. 代码层面
- 避免频繁创建大对象
- 及时释放不用的引用
- 使用对象池复用对象
```

---

### 问题 12：CMS收集器的工作原理和优缺点？

**答案：**

**CMS（Concurrent Mark Sweep）** 是以最短停顿时间为目标的老年代收集器。

```
┌─────────────────────────────────────────────────────────────────┐
│                    CMS 收集过程 (4个阶段)                        │
├─────────────────────────────────────────────────────────────────┤
│                                                                  │
│  用户线程     ═══════════════════════════════════════════════   │
│                    ║          ║                   ║             │
│                    ║ STW      ║                   ║ STW         │
│                    ▼          ▼                   ▼             │
│  ┌──────────┐ ┌─────────┐ ┌───────────────┐ ┌─────────────┐    │
│  │ 初始标记  │ │ 并发标记 │ │   重新标记    │ │  并发清除   │    │
│  │Initial   │ │Concurrent│ │   Remark     │ │ Concurrent  │    │
│  │ Mark     │ │  Mark    │ │              │ │   Sweep     │    │
│  └──────────┘ └─────────┘ └───────────────┘ └─────────────┘    │
│       │            │              │               │             │
│       │            │              │               │             │
│   标记GC Roots   从GC Roots     修正并发标记     清除未标记      │
│   直接关联对象   遍历对象图      期间变动的对象   的对象          │
│       │            │              │               │             │
│   STW很短      与用户线程      STW较短        与用户线程        │
│               并发执行                        并发执行          │
│                                                                  │
└─────────────────────────────────────────────────────────────────┘

时间线：
├── 初始标记 ──┤──────── 并发标记 ────────┤── 重新标记 ──┤── 并发清除 ──┤
     STW短              并发                 STW较短         并发
```

**四个阶段详解：**

| 阶段 | STW | 说明 | 耗时 |
|------|-----|------|------|
| 初始标记 | ✓ | 标记GC Roots直接关联的对象 | 很短 |
| 并发标记 | ✗ | 从GC Roots遍历整个对象图 | 最长 |
| 重新标记 | ✓ | 修正并发标记期间变动的对象（增量更新） | 较短 |
| 并发清除 | ✗ | 清除未标记的对象 | 较长 |

**CMS的优缺点：**

| 优点 | 缺点 |
|------|------|
| 并发收集，低停顿 | CPU敏感，并发阶段占用CPU资源 |
| 适合响应时间敏感的应用 | 无法处理浮动垃圾 |
| | 内存碎片问题（标记-清除算法） |
| | 并发失败会触发Serial Old |

**浮动垃圾问题：**

```
┌─────────────────────────────────────────────┐
│  并发标记阶段：                              │
│                                             │
│  已标记存活 ──┐      新产生的垃圾            │
│              │      （浮动垃圾）             │
│  用户线程    │  →   只能等下次GC回收         │
│  同时运行    │                              │
│              └─ 同时用户线程产生新垃圾       │
│                 这些垃圾本次无法回收          │
└─────────────────────────────────────────────┘
```

**适用场景：** 对响应时间敏感的应用，如Web服务

---

**追问：什么是CMS的并发失败（Concurrent Mode Failure）？**

**答案：**

```
并发失败场景：
┌────────────────────────────────────────────────────────────────┐
│                                                                │
│   CMS并发清除                         用户线程                 │
│        │                                  │                    │
│        ▼                                  ▼                    │
│   正在清除老年代    ←── 同时 ──→    需要分配新对象到老年代     │
│                                           │                    │
│                                           ▼                    │
│                                    老年代空间不足！             │
│                                           │                    │
│                                           ▼                    │
│                              Concurrent Mode Failure           │
│                                           │                    │
│                                           ▼                    │
│                              退化为 Serial Old 收集            │
│                              (单线程，STW时间很长)              │
│                                                                │
└────────────────────────────────────────────────────────────────┘

解决方案：
-XX:CMSInitiatingOccupancyFraction=70  // 老年代70%时触发CMS
-XX:+UseCMSCompactAtFullCollection     // Full GC后整理内存
-XX:CMSFullGCsBeforeCompaction=5       // 5次Full GC后整理一次
```

---

### 问题 13：G1收集器的工作原理？

**答案：**

**G1（Garbage First）** 是面向服务端的收集器，JDK 9后的默认收集器。

```
┌─────────────────────────────────────────────────────────────────┐
│                    G1 内存布局 (Region)                          │
├─────────────────────────────────────────────────────────────────┤
│                                                                  │
│  传统分代：                                                      │
│  ┌────────────────────────┬────────────────────────────────┐    │
│  │       新生代           │            老年代              │    │
│  │   (连续的一大块)       │       (连续的一大块)           │    │
│  └────────────────────────┴────────────────────────────────┘    │
│                                                                  │
│  G1分区：                                                        │
│  ┌────┬────┬────┬────┬────┬────┬────┬────┬────┬────┐           │
│  │ E  │ S  │ O  │ E  │ O  │ H  │ O  │ E  │ S  │ O  │           │
│  ├────┼────┼────┼────┼────┼────┼────┼────┼────┼────┤           │
│  │ O  │ E  │ O  │ O  │ E  │ H  │ O  │ O  │ E  │ O  │           │
│  ├────┼────┼────┼────┼────┼────┼────┼────┼────┼────┤           │
│  │ E  │ O  │ E  │ O  │ S  │    │ O  │ E  │ O  │ E  │           │
│  └────┴────┴────┴────┴────┴────┴────┴────┴────┴────┘           │
│                                                                  │
│  E = Eden    S = Survivor    O = Old    H = Humongous           │
│                                                                  │
│  • 堆被划分为2048个大小相等的Region（1MB~32MB）                   │
│  • 每个Region可以是Eden、Survivor、Old或Humongous                │
│  • 大对象直接分配到Humongous区                                   │
│  • Region可以动态变化角色                                        │
│                                                                  │
└─────────────────────────────────────────────────────────────────┘
```

**G1工作流程：**

```
┌─────────────────────────────────────────────────────────────────┐
│                      G1 收集过程                                 │
├─────────────────────────────────────────────────────────────────┤
│                                                                  │
│  Young GC（新生代收集）                                          │
│  ┌──────────────────────────────────────────────────────────┐   │
│  │ • 所有Eden Region被清空                                   │   │
│  │ • 存活对象复制到Survivor或Old Region                      │   │
│  │ • STW，但因为只处理部分Region，时间可控                   │   │
│  └──────────────────────────────────────────────────────────┘   │
│                                                                  │
│  Mixed GC（混合收集）                                            │
│  ┌──────────────────────────────────────────────────────────┐   │
│  │ 1. 初始标记 (STW)  - 标记GC Roots直接关联的对象           │   │
│  │        │                                                  │   │
│  │        ▼                                                  │   │
│  │ 2. 并发标记 - 从GC Roots遍历对象图                        │   │
│  │        │                                                  │   │
│  │        ▼                                                  │   │
│  │ 3. 最终标记 (STW) - 处理SATB记录的引用变更                │   │
│  │        │                                                  │   │
│  │        ▼                                                  │   │
│  │ 4. 筛选回收 (STW) - 选择回收价值高的Region优先回收        │   │
│  │        │                                                  │   │
│  │        ▼                                                  │   │
│  │    复制存活对象到新Region，清空被回收的Region             │   │
│  └──────────────────────────────────────────────────────────┘   │
│                                                                  │
└─────────────────────────────────────────────────────────────────┘
```

**G1的核心优势：**

| 特性 | 说明 |
|------|------|
| **可预测停顿** | 通过 `-XX:MaxGCPauseMillis` 设置目标停顿时间 |
| **Region设计** | 避免全堆扫描，只处理部分Region |
| **Garbage First** | 优先回收垃圾最多的Region |
| **复制算法** | 每次GC都整理内存，无碎片 |
| **并发标记** | 减少STW时间 |

**G1参数配置：**

```bash
-XX:+UseG1GC                    # 启用G1
-XX:MaxGCPauseMillis=200        # 目标停顿时间200ms
-XX:G1HeapRegionSize=4m         # Region大小
-XX:InitiatingHeapOccupancyPercent=45  # 堆占用45%触发并发标记
```

**适用场景：** 大堆（6GB以上）、对延迟敏感的应用

---

**追问：G1的SATB是什么？**

**答案：**

**SATB（Snapshot At The Beginning）** 是G1并发标记时使用的技术：

```
问题：并发标记期间，用户线程可能修改引用关系

三色标记：
┌────────────────────────────────────────────────────────────────┐
│  白色：尚未访问                                                 │
│  灰色：已访问，但其引用的对象尚未全部访问                        │
│  黑色：已访问，其引用的对象也已全部访问                          │
└────────────────────────────────────────────────────────────────┘

漏标问题：
1. 并发标记时，黑色对象(A)新增了对白色对象(C)的引用
2. 同时灰色对象(B)删除了对C的引用
3. 扫描完成后，C未被标记，但实际是存活的 → 漏标

SATB解决方案：
┌────────────────────────────────────────────────────────────────┐
│  在并发标记开始时，创建一个"快照"                                │
│  任何引用被删除时，将旧引用记录到SATB队列                        │
│  最终标记阶段，处理SATB队列中的引用                              │
│  可能产生浮动垃圾，但保证不漏标                                  │
└────────────────────────────────────────────────────────────────┘
```

---

### 问题 14：ZGC的特点和原理？

**答案：**

**ZGC** 是JDK 11引入的低延迟垃圾收集器，目标是任意堆大小下停顿时间不超过10ms。

```
┌─────────────────────────────────────────────────────────────────┐
│                       ZGC 核心特性                               │
├─────────────────────────────────────────────────────────────────┤
│                                                                  │
│  ┌────────────────────────────────────────────────────────────┐ │
│  │  关键特性                                                   │ │
│  │  • 停顿时间 < 10ms（不随堆大小增长）                        │ │
│  │  • 支持TB级别堆内存                                         │ │
│  │  • 停顿时间与存活对象数量无关                               │ │
│  │  • 停顿时间与堆大小无关                                     │ │
│  └────────────────────────────────────────────────────────────┘ │
│                                                                  │
│  ┌────────────────────────────────────────────────────────────┐ │
│  │  核心技术                                                   │ │
│  │                                                             │ │
│  │  1. 着色指针 (Colored Pointers)                             │ │
│  │  ┌────────────────────────────────────────────────────┐    │ │
│  │  │  64位指针结构：                                     │    │ │
│  │  │  ┌────────┬────┬────┬────┬────┬────────────────┐  │    │ │
│  │  │  │ unused │ M0 │ M1 │ Rem│ Fin│    地址(42位)   │  │    │ │
│  │  │  │ (16位) │(1) │(1) │(1) │(1) │                 │  │    │ │
│  │  │  └────────┴────┴────┴────┴────┴────────────────┘  │    │ │
│  │  │  • M0/M1：标记位，用于标记存活对象                  │    │ │
│  │  │  • Remapped：重映射位                              │    │ │
│  │  │  • Finalizable：是否需要finalize                   │    │ │
│  │  └────────────────────────────────────────────────────┘    │ │
│  │                                                             │ │
│  │  2. 读屏障 (Load Barrier)                                   │ │
│  │  ┌────────────────────────────────────────────────────┐    │ │
│  │  │  Object obj = field;  // 读取引用时触发             │    │ │
│  │  │  if (isInvalid(obj)) {                              │    │ │
│  │  │      obj = relocate(obj);  // 重定位对象            │    │ │
│  │  │      field = obj;          // 更新引用              │    │ │
│  │  │  }                                                  │    │ │
│  │  └────────────────────────────────────────────────────┘    │ │
│  │                                                             │ │
│  │  3. 内存多重映射                                            │ │
│  │     同一物理内存映射到多个虚拟地址                          │ │
│  │                                                             │ │
│  └────────────────────────────────────────────────────────────┘ │
│                                                                  │
└─────────────────────────────────────────────────────────────────┘
```

**ZGC回收流程：**

```
┌──────────────────────────────────────────────────────────────────┐
│                        ZGC 工作阶段                               │
├──────────────────────────────────────────────────────────────────┤
│                                                                   │
│  用户线程    ════════════════════════════════════════════════    │
│                    │              │               │               │
│                    ▼              ▼               ▼               │
│              ┌──────────┐   ┌──────────┐   ┌──────────┐          │
│              │初始标记   │   │ 再标记   │   │初始转移   │          │
│              │ (STW)    │   │ (STW)    │   │ (STW)    │          │
│              │ <1ms     │   │ <1ms     │   │ <1ms     │          │
│              └──────────┘   └──────────┘   └──────────┘          │
│                    │              │               │               │
│  GC线程      ══════╪══════════════╪═══════════════╪══════════    │
│                    ▼              ▼               ▼               │
│              ┌──────────┐   ┌──────────┐   ┌──────────┐          │
│              │ 并发标记  │   │并发预处理 │   │ 并发转移  │          │
│              │          │   │          │   │          │          │
│              └──────────┘   └──────────┘   └──────────┘          │
│                                                                   │
│  STW阶段只做很少的工作，绝大部分工作与用户线程并发执行              │
│                                                                   │
└──────────────────────────────────────────────────────────────────┘
```

**ZGC vs G1 vs CMS：**

| 特性 | CMS | G1 | ZGC |
|------|-----|----|----|
| 最大停顿 | 几百ms | 200ms可控 | <10ms |
| 最大堆 | ~32GB | ~64GB | TB级 |
| 吞吐量 | 高 | 较高 | 稍低 |
| 内存碎片 | 有 | 无 | 无 |
| JDK版本 | 被废弃 | JDK9默认 | JDK15生产可用 |

**启用ZGC：**

```bash
# JDK 11-14
-XX:+UnlockExperimentalVMOptions -XX:+UseZGC

# JDK 15+
-XX:+UseZGC
```

**适用场景：** 超大堆、极低延迟要求的应用（金融交易、实时系统）

---

**追问：ZGC为什么能做到这么低的停顿？**

**答案：**

1. **着色指针**：GC信息存储在指针中，无需额外的Mark Bitmap
2. **读屏障**：对象转移时无需STW，读取时自动修正指针
3. **并发转移**：对象复制与应用程序并发执行
4. **无分代**：不区分新老代，统一管理（JDK 21引入分代ZGC）

---

### 问题 15：如何选择合适的垃圾收集器？

**答案：**

```
┌─────────────────────────────────────────────────────────────────┐
│                    垃圾收集器选择指南                            │
├─────────────────────────────────────────────────────────────────┤
│                                                                  │
│  应用场景分析                                                    │
│        │                                                        │
│        ├─── 延迟敏感型（Web服务、交互应用）                      │
│        │         │                                              │
│        │         ├── 堆 < 4GB ───────▶ ParNew + CMS            │
│        │         ├── 堆 4-8GB ──────▶ G1                       │
│        │         └── 堆 > 8GB ──────▶ G1 / ZGC                 │
│        │                                                        │
│        ├─── 吞吐量优先（批处理、科学计算）                       │
│        │         │                                              │
│        │         └── Parallel Scavenge + Parallel Old          │
│        │                                                        │
│        └─── 极低延迟（<10ms）                                   │
│                  │                                              │
│                  └── ZGC / Shenandoah                          │
│                                                                  │
└─────────────────────────────────────────────────────────────────┘
```

**收集器组合对照表：**

| 场景 | 新生代 | 老年代 | 特点 |
|------|--------|--------|------|
| **默认组合** | Parallel Scavenge | Parallel Old | 吞吐量优先 |
| **低延迟** | ParNew | CMS | 响应时间优先 |
| **大堆/均衡** | G1 | G1 | 可控停顿 |
| **超低延迟** | ZGC | ZGC | <10ms停顿 |
| **单核/小堆** | Serial | Serial Old | 简单高效 |

**选择决策树：**

```
                    堆大小
                      │
        ┌─────────────┼─────────────┐
        ▼             ▼             ▼
     < 100MB       100MB-6GB      > 6GB
        │             │             │
        ▼             ▼             ▼
     Serial      ┌────┴────┐       G1
                 │         │       或
           吞吐量优先  延迟优先    ZGC
                 │         │
                 ▼         ▼
            Parallel   G1/CMS
```

**JDK版本推荐：**

| JDK版本 | 推荐收集器 | 说明 |
|---------|------------|------|
| JDK 8 | ParNew+CMS / G1 | CMS仍是主流选择 |
| JDK 11 | G1 | G1成熟，CMS开始废弃 |
| JDK 17+ | G1 / ZGC | ZGC可用于生产 |
| JDK 21+ | G1 / 分代ZGC | 分代ZGC性能更好 |

**适用场景：** 架构设计、JVM调优方案选择

---

**追问：什么场景下不建议使用G1？**

**答案：**

1. **小堆内存（<4GB）**：G1的Region管理开销在小堆上不划算
2. **内存敏感应用**：G1有额外的记忆集开销（约10%-20%）
3. **吞吐量极致要求**：Parallel GC吞吐量更高
4. **JDK版本较老**：JDK 8的G1还不够成熟

---

### 问题 16：什么情况下会触发Full GC？

**答案：**

```
┌─────────────────────────────────────────────────────────────────┐
│                    触发 Full GC 的场景                           │
├─────────────────────────────────────────────────────────────────┤
│                                                                  │
│  1. 老年代空间不足                                               │
│  ┌─────────────────────────────────────────────────────────┐    │
│  │  • 大对象直接进入老年代                                  │    │
│  │  • 长期存活对象晋升                                      │    │
│  │  • 代码创建大量长生命周期对象                            │    │
│  └─────────────────────────────────────────────────────────┘    │
│                                                                  │
│  2. 方法区/元空间不足                                           │
│  ┌─────────────────────────────────────────────────────────┐    │
│  │  • 加载大量类（动态代理、反射、CGLib）                   │    │
│  │  • 元空间设置过小                                        │    │
│  └─────────────────────────────────────────────────────────┘    │
│                                                                  │
│  3. Minor GC 晋升失败                                           │
│  ┌─────────────────────────────────────────────────────────┐    │
│  │  • Survivor区放不下存活对象                              │    │
│  │  • 老年代空间不足以容纳晋升对象                          │    │
│  │  • 触发担保失败（Handle Promotion Failure）              │    │
│  └─────────────────────────────────────────────────────────┘    │
│                                                                  │
│  4. 显式调用 System.gc()                                        │
│  ┌─────────────────────────────────────────────────────────┐    │
│  │  • 代码中调用 System.gc()                                │    │
│  │  • 使用 jmap -histo:live 触发                            │    │
│  │  • 注意：可以用 -XX:+DisableExplicitGC 禁用              │    │
│  └─────────────────────────────────────────────────────────┘    │
│                                                                  │
│  5. CMS 并发失败                                                │
│  ┌─────────────────────────────────────────────────────────┐    │
│  │  • 并发标记期间老年代被填满                              │    │
│  │  • 退化为 Serial Old，STW时间大幅增加                    │    │
│  └─────────────────────────────────────────────────────────┘    │
│                                                                  │
│  6. 堆dump或jmap操作                                            │
│  ┌─────────────────────────────────────────────────────────┐    │
│  │  • jmap -dump:live 会触发Full GC                         │    │
│  │  • 线上慎用                                              │    │
│  └─────────────────────────────────────────────────────────┘    │
│                                                                  │
└─────────────────────────────────────────────────────────────────┘
```

**担保机制详解：**

```
Minor GC 前的担保检查：
┌────────────────────────────────────────────────────────────────┐
│                                                                │
│   检查老年代最大可用连续空间 > 新生代所有对象总空间？          │
│                          │                                     │
│            ┌─────────────┼─────────────┐                      │
│            ▼                           ▼                       │
│           是                          否                       │
│            │                           │                       │
│            ▼                           ▼                       │
│       直接Minor GC            是否允许担保失败？                │
│                            (-XX:HandlePromotionFailure)        │
│                                        │                       │
│                          ┌─────────────┼─────────────┐        │
│                          ▼                           ▼         │
│                        允许                        不允许      │
│                          │                           │         │
│                          ▼                           ▼         │
│                 老年代可用空间 >                   Full GC     │
│                 历次晋升平均大小？                              │
│                          │                                     │
│            ┌─────────────┼─────────────┐                      │
│            ▼                           ▼                       │
│           是                          否                       │
│            │                           │                       │
│            ▼                           ▼                       │
│       冒险Minor GC                  Full GC                    │
│                                                                │
└────────────────────────────────────────────────────────────────┘
```

**适用场景：** GC调优、线上问题排查

---

**追问：如何监控Full GC？**

**答案：**

```bash
# 1. JVM参数打印GC日志
-XX:+PrintGCDetails
-XX:+PrintGCDateStamps
-Xloggc:/path/to/gc.log

# 2. JDK 9+统一日志
-Xlog:gc*:file=gc.log:time,level,tags

# 3. 命令行工具
jstat -gcutil <pid> 1000  # 每秒输出GC统计

# 4. 监控指标
- Full GC次数
- Full GC平均耗时
- Full GC频率（次/小时）

# 5. 告警阈值建议
- Full GC频率 > 1次/小时 → 警告
- Full GC频率 > 1次/10分钟 → 严重
- Full GC耗时 > 1秒 → 严重
```

---

### 问题 17：内存泄漏和内存溢出的区别？常见场景？

**答案：**

```
┌─────────────────────────────────────────────────────────────────┐
│               内存泄漏 vs 内存溢出                               │
├─────────────────────────────────────────────────────────────────┤
│                                                                  │
│  内存泄漏 (Memory Leak)                                         │
│  ┌─────────────────────────────────────────────────────────┐    │
│  │  定义：对象不再使用，但GC无法回收（仍被引用）             │    │
│  │                                                          │    │
│  │  ┌─────┐    ┌─────┐    ┌─────┐    ┌─────┐              │    │
│  │  │泄漏1│    │泄漏2│    │泄漏3│    │泄漏n│  ...          │    │
│  │  └─────┘    └─────┘    └─────┘    └─────┘              │    │
│  │      │          │          │          │                │    │
│  │      └──────────┴──────────┴──────────┘                │    │
│  │                     │                                   │    │
│  │                     ▼                                   │    │
│  │        随时间累积，最终导致内存溢出                      │    │
│  │                                                          │    │
│  │  特点：渐进式，难以察觉，排查困难                        │    │
│  └─────────────────────────────────────────────────────────┘    │
│                                                                  │
│  内存溢出 (Out Of Memory)                                       │
│  ┌─────────────────────────────────────────────────────────┐    │
│  │  定义：申请内存时，堆空间不足以分配                       │    │
│  │                                                          │    │
│  │  ┌───────────────────────────────────────┐              │    │
│  │  │              堆内存 (已满)              │              │    │
│  │  │  ┌───┐┌───┐┌───┐┌───┐┌───┐┌───┐┌───┐ │              │    │
│  │  │  │obj││obj││obj││obj││obj││obj││obj│ │              │    │
│  │  │  └───┘└───┘└───┘└───┘└───┘└───┘└───┘ │              │    │
│  │  └───────────────────────────────────────┘              │    │
│  │                     │                                   │    │
│  │          new Object() → OOM!                            │    │
│  │                                                          │    │
│  │  特点：突发性，系统崩溃，明确的错误信息                  │    │
│  └─────────────────────────────────────────────────────────┘    │
│                                                                  │
│  关系：内存泄漏积累到一定程度 → 导致内存溢出                    │
│                                                                  │
└─────────────────────────────────────────────────────────────────┘
```

**常见内存泄漏场景：**

```java
// 1. 静态集合类持有引用
public class LeakDemo {
    private static List<Object> list = new ArrayList<>();

    public void add(Object obj) {
        list.add(obj);  // 对象被静态集合引用，永远不会回收
    }
}

// 2. 未关闭的资源
public void readFile() {
    InputStream is = new FileInputStream("file.txt");
    // 忘记 is.close()，资源泄漏
}

// 3. ThreadLocal未清理
ThreadLocal<byte[]> threadLocal = new ThreadLocal<>();
threadLocal.set(new byte[1024 * 1024]);  // 1MB
// 线程池场景下，线程复用导致ThreadLocal不被清理
// 忘记 threadLocal.remove()

// 4. 监听器/回调未注销
button.addActionListener(listener);
// 组件销毁时忘记 button.removeActionListener(listener)

// 5. 内部类持有外部类引用
public class Outer {
    private byte[] data = new byte[1024 * 1024];

    class Inner {
        // 内部类隐式持有外部类引用
        // 如果Inner对象长期存活，Outer对象也无法回收
    }
}

// 6. 缓存未设置过期
Map<String, Object> cache = new HashMap<>();
cache.put("key", bigObject);  // 缓存没有淘汰策略，持续增长

// 7. 连接池连接未归还
Connection conn = dataSource.getConnection();
// 忘记 conn.close() 或 conn归还池
```

**常见OOM类型：**

| OOM类型 | 原因 | 解决方案 |
|---------|------|----------|
| Java heap space | 堆内存不足 | 增大-Xmx / 检查内存泄漏 |
| Metaspace | 元空间不足（类太多） | 增大元空间 / 检查动态类生成 |
| GC overhead limit exceeded | GC频繁但回收很少 | 检查内存泄漏 |
| Direct buffer memory | 直接内存不足 | 增大直接内存限制 |
| Unable to create native thread | 线程数过多 | 减少线程数 / 增大栈空间 |

**适用场景：** 线上故障排查，是高频面试题

---

**追问：如何区分是内存泄漏还是堆设置过小？**

**答案：**

```
分析方法：
┌────────────────────────────────────────────────────────────────┐
│  1. 观察GC日志和监控                                           │
│     • 内存使用持续增长，Full GC后仍然很高 → 内存泄漏           │
│     • Full GC后内存能降下来，但很快又满 → 可能堆设置过小       │
│                                                                │
│  2. dump堆内存分析                                             │
│     jmap -dump:live,format=b,file=heap.hprof <pid>            │
│                                                                │
│     • 发现大量相同类型对象且不应该存在 → 内存泄漏              │
│     • 对象分布正常，只是量大 → 堆设置过小                      │
│                                                                │
│  3. 对比多次dump                                               │
│     • 某类对象持续增长 → 泄漏                                  │
│     • 对象数量稳定 → 正常                                      │
└────────────────────────────────────────────────────────────────┘
```

---

### 问题 18：如何排查内存泄漏问题？

**答案：**

```
┌─────────────────────────────────────────────────────────────────┐
│                   内存泄漏排查流程                               │
├─────────────────────────────────────────────────────────────────┤
│                                                                  │
│  Step 1: 发现问题                                               │
│  ┌─────────────────────────────────────────────────────────┐    │
│  │  • 监控发现内存持续增长                                  │    │
│  │  • Full GC频繁                                           │    │
│  │  • 最终OOM                                               │    │
│  └─────────────────────────────────────────────────────────┘    │
│                          │                                      │
│                          ▼                                      │
│  Step 2: 初步分析                                               │
│  ┌─────────────────────────────────────────────────────────┐    │
│  │  # 查看GC情况                                            │    │
│  │  jstat -gcutil <pid> 1000                                │    │
│  │                                                          │    │
│  │  # 查看堆内存对象统计                                    │    │
│  │  jmap -histo <pid> | head -20                            │    │
│  │                                                          │    │
│  │  # 观察对象数量变化，多次执行对比                        │    │
│  └─────────────────────────────────────────────────────────┘    │
│                          │                                      │
│                          ▼                                      │
│  Step 3: dump堆内存                                             │
│  ┌─────────────────────────────────────────────────────────┐    │
│  │  # 生成堆dump文件                                        │    │
│  │  jmap -dump:live,format=b,file=heap.hprof <pid>          │    │
│  │                                                          │    │
│  │  # 或OOM时自动dump                                       │    │
│  │  -XX:+HeapDumpOnOutOfMemoryError                         │    │
│  │  -XX:HeapDumpPath=/path/to/dump                          │    │
│  └─────────────────────────────────────────────────────────┘    │
│                          │                                      │
│                          ▼                                      │
│  Step 4: 分析dump文件                                           │
│  ┌─────────────────────────────────────────────────────────┐    │
│  │  工具选择：                                               │    │
│  │  • MAT (Eclipse Memory Analyzer)                         │    │
│  │  • VisualVM                                              │    │
│  │  • JProfiler                                             │    │
│  │  • Arthas                                                │    │
│  │                                                          │    │
│  │  分析重点：                                               │    │
│  │  1. Dominator Tree - 找出占用最大的对象                  │    │
│  │  2. Histogram - 查看对象数量分布                         │    │
│  │  3. Leak Suspects - 自动分析泄漏嫌疑                     │    │
│  │  4. GC Roots - 分析对象被谁引用                          │    │
│  └─────────────────────────────────────────────────────────┘    │
│                          │                                      │
│                          ▼                                      │
│  Step 5: 定位代码                                               │
│  ┌─────────────────────────────────────────────────────────┐    │
│  │  根据GC Roots引用链，找到代码位置                        │    │
│  │                                                          │    │
│  │  GC Roots → StaticField → HashMap → Entry → 泄漏对象    │    │
│  │                                                          │    │
│  │  常见泄漏点：                                             │    │
│  │  • 静态集合                                               │    │
│  │  • 缓存没有淘汰策略                                       │    │
│  │  • 监听器未注销                                           │    │
│  │  • ThreadLocal未清理                                     │    │
│  └─────────────────────────────────────────────────────────┘    │
│                                                                  │
└─────────────────────────────────────────────────────────────────┘
```

**MAT分析示例：**

```
1. 打开heap.hprof文件

2. 查看 Leak Suspects Report
   自动分析可疑的泄漏点

3. 打开 Dominator Tree
   查看占用内存最大的对象
   ┌──────────────────────────────────────────┐
   │ Class Name                    │ Size     │
   ├──────────────────────────────────────────┤
   │ java.util.HashMap             │ 500 MB   │ ← 可疑
   │ com.example.UserCache         │ 300 MB   │ ← 可疑
   │ ...                           │ ...      │
   └──────────────────────────────────────────┘

4. 右键 → Path to GC Roots → exclude weak references
   查看对象的引用链，找到是谁持有引用

5. 定位代码位置，修复泄漏
```

**Arthas在线分析：**

```bash
# 进入Arthas
java -jar arthas-boot.jar

# 查看堆内存对象
heapdump /tmp/dump.hprof

# 查看某个对象的引用
vmtool --action getInstances --className com.example.LeakObject --limit 10

# 查看对象属性
ognl '@com.example.Cache@map.size()'
```

**适用场景：** 线上故障排查，高级工程师必备技能

---

**追问：生产环境dump会有什么影响？如何降低影响？**

**答案：**

```
影响：
1. dump过程会触发Full GC（如果使用live参数）
2. 大堆dump时间长，期间STW
3. 占用磁盘空间（堆多大dump就多大）

降低影响的方法：
1. 去掉live参数：jmap -dump:format=b,file=heap.hprof <pid>
   • 不触发Full GC，但dump文件更大

2. 使用gcore（Linux）：
   gcore <pid>  # 生成core dump，不STW
   再用jmap转换

3. 分流后dump：
   从负载均衡摘除节点后再dump

4. 使用Arthas的heapdump：
   可以只dump存活对象，更灵活

5. 预防性配置：
   -XX:+HeapDumpOnOutOfMemoryError
   在OOM时自动dump，不需要人工介入
```

---

## 第三节：类加载机制（19-24题）

---

### 问题 19：类加载的过程是怎样的？

**答案：**

```
┌─────────────────────────────────────────────────────────────────┐
│                       类加载完整过程                             │
├─────────────────────────────────────────────────────────────────┤
│                                                                  │
│  .class文件                                                     │
│       │                                                         │
│       ▼                                                         │
│  ┌─────────────────────────────────────────────────────────┐    │
│  │  1. 加载 (Loading)                                       │    │
│  │  ┌─────────────────────────────────────────────────┐    │    │
│  │  │  • 通过类全限定名获取二进制字节流                │    │    │
│  │  │  • 将字节流转化为方法区的运行时数据结构          │    │    │
│  │  │  • 在堆中生成 java.lang.Class 对象               │    │    │
│  │  └─────────────────────────────────────────────────┘    │    │
│  └─────────────────────────────────────────────────────────┘    │
│       │                                                         │
│       ▼                                                         │
│  ┌─────────────────────────────────────────────────────────┐    │
│  │  2. 链接 (Linking)                                       │    │
│  │  ┌─────────────────────────────────────────────────┐    │    │
│  │  │  2.1 验证 (Verification)                         │    │    │
│  │  │      • 文件格式验证（魔数CAFEBABE）              │    │    │
│  │  │      • 元数据验证（语义分析）                    │    │    │
│  │  │      • 字节码验证（数据流和控制流）              │    │    │
│  │  │      • 符号引用验证                              │    │    │
│  │  └─────────────────────────────────────────────────┘    │    │
│  │  ┌─────────────────────────────────────────────────┐    │    │
│  │  │  2.2 准备 (Preparation)                          │    │    │
│  │  │      • 为类变量分配内存                          │    │    │
│  │  │      • 设置类变量初始值（零值）                  │    │    │
│  │  │      • static int a = 10; → a = 0（此阶段）     │    │    │
│  │  │      • static final int b = 10; → b = 10       │    │    │
│  │  └─────────────────────────────────────────────────┘    │    │
│  │  ┌─────────────────────────────────────────────────┐    │    │
│  │  │  2.3 解析 (Resolution)                           │    │    │
│  │  │      • 将符号引用转为直接引用                    │    │    │
│  │  │      • 类或接口的解析                            │    │    │
│  │  │      • 字段解析                                  │    │    │
│  │  │      • 方法解析                                  │    │    │
│  │  └─────────────────────────────────────────────────┘    │    │
│  └─────────────────────────────────────────────────────────┘    │
│       │                                                         │
│       ▼                                                         │
│  ┌─────────────────────────────────────────────────────────┐    │
│  │  3. 初始化 (Initialization)                              │    │
│  │  ┌─────────────────────────────────────────────────┐    │    │
│  │  │  • 执行类构造器 <clinit>() 方法                  │    │    │
│  │  │  • 静态变量赋值 + 静态代码块                     │    │    │
│  │  │  • static int a = 10; → a = 10（此阶段）        │    │    │
│  │  │  • 父类的 <clinit>() 先执行                      │    │    │
│  │  └─────────────────────────────────────────────────┘    │    │
│  └─────────────────────────────────────────────────────────┘    │
│       │                                                         │
│       ▼                                                         │
│  类可以被使用                                                   │
│                                                                  │
└─────────────────────────────────────────────────────────────────┘
```

**代码示例理解：**

```java
public class ClassLoadDemo {
    // 准备阶段：value = 0
    // 初始化阶段：value = 100
    private static int value = 100;

    // 编译时常量，准备阶段就赋值
    private static final int CONSTANT = 200;

    // 运行时常量，初始化阶段赋值
    private static final String NAME = new String("test");

    static {
        System.out.println("静态代码块执行");
    }
}

// clinit方法伪代码：
<clinit>() {
    value = 100;
    NAME = new String("test");
    System.out.println("静态代码块执行");
}
```

**类初始化时机（有且仅有6种）：**

| 场景 | 说明 |
|------|------|
| new、getstatic、putstatic、invokestatic | 创建实例、读写静态字段、调用静态方法 |
| 反射调用 | Class.forName()、newInstance()等 |
| 初始化子类时 | 父类未初始化则先初始化父类 |
| 主类 | 包含main()方法的类 |
| MethodHandle | 动态语言支持 |
| default方法 | 接口有default方法，实现类初始化时 |

**适用场景：** 理解类加载机制、static关键字、单例模式

---

**追问：下面代码输出什么？**

```java
class Parent {
    static int a = 1;
    static { System.out.println("Parent static block"); }
}

class Child extends Parent {
    static int b = 2;
    static { System.out.println("Child static block"); }
}

public class Test {
    public static void main(String[] args) {
        System.out.println(Child.a);  // 只访问父类静态变量
    }
}
```

**答案：**

```
输出：
Parent static block
1

原因：
• 访问子类静态字段时，如果该字段定义在父类，只会初始化父类
• 不会触发子类的初始化
• 这是"被动引用"，不是子类的主动使用
```

---

### 问题 20：双亲委派模型是什么？为什么需要？

**答案：**

```
┌─────────────────────────────────────────────────────────────────┐
│                       双亲委派模型                               │
├─────────────────────────────────────────────────────────────────┤
│                                                                  │
│  类加载请求                                                     │
│       │                                                         │
│       ▼                                                         │
│  ┌─────────────────────────────────────────────────────────┐    │
│  │              Bootstrap ClassLoader                       │    │
│  │              启动类加载器 (C++实现)                       │    │
│  │              加载：JAVA_HOME/lib                         │    │
│  │              如：rt.jar、resources.jar                   │    │
│  └─────────────────────────────────────────────────────────┘    │
│       ▲                   │                                     │
│       │ 委派              │ 加载失败                            │
│       │                   ▼                                     │
│  ┌─────────────────────────────────────────────────────────┐    │
│  │              Extension ClassLoader                       │    │
│  │              扩展类加载器                                 │    │
│  │              加载：JAVA_HOME/lib/ext                     │    │
│  │              或 java.ext.dirs 指定目录                   │    │
│  └─────────────────────────────────────────────────────────┘    │
│       ▲                   │                                     │
│       │ 委派              │ 加载失败                            │
│       │                   ▼                                     │
│  ┌─────────────────────────────────────────────────────────┐    │
│  │              Application ClassLoader                     │    │
│  │              应用类加载器                                 │    │
│  │              加载：classpath                             │    │
│  │              用户类的默认加载器                           │    │
│  └─────────────────────────────────────────────────────────┘    │
│       ▲                   │                                     │
│       │ 委派              │ 加载失败                            │
│       │                   ▼                                     │
│  ┌─────────────────────────────────────────────────────────┐    │
│  │              Custom ClassLoader                          │    │
│  │              自定义类加载器                               │    │
│  │              用户自定义加载逻辑                           │    │
│  └─────────────────────────────────────────────────────────┘    │
│                                                                  │
│  工作流程：                                                      │
│  1. 收到加载请求，先委派给父加载器                               │
│  2. 父加载器继续向上委派，直到Bootstrap                          │
│  3. 如果父加载器无法加载，子加载器才尝试自己加载                 │
│                                                                  │
└─────────────────────────────────────────────────────────────────┘
```

**源码实现：**

```java
protected Class<?> loadClass(String name, boolean resolve) throws ClassNotFoundException {
    synchronized (getClassLoadingLock(name)) {
        // 1. 检查类是否已加载
        Class<?> c = findLoadedClass(name);
        if (c == null) {
            try {
                // 2. 委派给父加载器
                if (parent != null) {
                    c = parent.loadClass(name, false);
                } else {
                    c = findBootstrapClassOrNull(name);
                }
            } catch (ClassNotFoundException e) {
                // 父加载器无法加载
            }

            if (c == null) {
                // 3. 父加载器无法加载，自己尝试加载
                c = findClass(name);
            }
        }
        if (resolve) {
            resolveClass(c);
        }
        return c;
    }
}
```

**为什么需要双亲委派？**

| 原因 | 说明 |
|------|------|
| **安全性** | 防止核心类被篡改（无法自定义java.lang.String） |
| **避免重复加载** | 父加载器加载过的类不会再加载 |
| **保证类的唯一性** | 同一个类只会被加载一次 |
| **层次清晰** | 核心类由核心加载器加载，保持层次分明 |

**验证双亲委派：**

```java
// 尝试自定义java.lang.String
public class String {
    public static void main(String[] args) {
        System.out.println("自定义String");
    }
}

// 运行结果：
// 错误：在类 java.lang.String 中找不到 main 方法
// 因为Bootstrap加载了JDK的String，自定义的String不会被加载
```

**适用场景：** 类加载机制的核心概念，理解框架原理的基础

---

**追问：JDK 9的模块化对类加载有什么影响？**

**答案：**

```
JDK 9 之前（三层）：
Bootstrap → Extension → Application

JDK 9 之后（三层，但Extension被Platform替代）：
Bootstrap → Platform → Application

变化：
1. Extension ClassLoader → Platform ClassLoader
2. rt.jar被拆分为多个模块
3. 类加载器可以具有名称
4. 模块化带来更细粒度的访问控制

// 获取类加载器
ClassLoader.getPlatformClassLoader();  // JDK 9+
```

---

### 问题 21：如何打破双亲委派模型？（续）

**自定义类加载器示例：**

```java
public class MyClassLoader extends ClassLoader {

    private String classPath;

    public MyClassLoader(String classPath) {
        this.classPath = classPath;
    }

    @Override
    protected Class<?> findClass(String name) throws ClassNotFoundException {
        try {
            // 1. 读取class文件的字节数组
            byte[] classData = loadClassData(name);
            if (classData == null) {
                throw new ClassNotFoundException();
            }
            // 2. 调用defineClass将字节数组转换为Class对象
            return defineClass(name, classData, 0, classData.length);
        } catch (IOException e) {
            throw new ClassNotFoundException(name, e);
        }
    }

    private byte[] loadClassData(String className) throws IOException {
        String path = classPath + File.separator
                    + className.replace('.', File.separatorChar) + ".class";
        try (InputStream is = new FileInputStream(path);
             ByteArrayOutputStream baos = new ByteArrayOutputStream()) {
            byte[] buffer = new byte[1024];
            int len;
            while ((len = is.read(buffer)) != -1) {
                baos.write(buffer, 0, len);
            }
            return baos.toByteArray();
        }
    }

    // 打破双亲委派：重写loadClass方法
    @Override
    protected Class<?> loadClass(String name, boolean resolve)
            throws ClassNotFoundException {
        synchronized (getClassLoadingLock(name)) {
            Class<?> c = findLoadedClass(name);
            if (c == null) {
                // 对于自定义路径下的类，直接自己加载，不委派给父加载器
                if (name.startsWith("com.myapp")) {
                    c = findClass(name);
                } else {
                    // 其他类仍然遵循双亲委派
                    c = super.loadClass(name, resolve);
                }
            }
            if (resolve) {
                resolveClass(c);
            }
            return c;
        }
    }
}

// 使用示例
public class Test {
    public static void main(String[] args) throws Exception {
        MyClassLoader loader = new MyClassLoader("/custom/classes");
        Class<?> clazz = loader.loadClass("com.myapp.MyClass");
        Object instance = clazz.newInstance();
        System.out.println(instance.getClass().getClassLoader()); // MyClassLoader
    }
}
```

**典型的打破双亲委派场景：**

```
┌─────────────────────────────────────────────────────────────────┐
│                  打破双亲委派的典型场景                          │
├─────────────────────────────────────────────────────────────────┤
│                                                                  │
│  1. SPI机制 (JDBC、JNDI等)                                      │
│  ┌─────────────────────────────────────────────────────────┐    │
│  │  问题：                                                  │    │
│  │  • java.sql.Driver 由 Bootstrap 加载                    │    │
│  │  • MySQL驱动实现类由 Application 加载                   │    │
│  │  • 父加载器无法看到子加载器加载的类                     │    │
│  │                                                          │    │
│  │  解决：线程上下文类加载器                                │    │
│  │  Thread.currentThread().getContextClassLoader()         │    │
│  └─────────────────────────────────────────────────────────┘    │
│                                                                  │
│  2. Tomcat Web容器                                              │
│  ┌─────────────────────────────────────────────────────────┐    │
│  │  需求：                                                  │    │
│  │  • 不同Web应用使用不同版本的同一个库                    │    │
│  │  • 应用之间类隔离                                        │    │
│  │                                                          │    │
│  │  实现：每个Web应用独立的WebAppClassLoader                │    │
│  │  优先加载Web应用自己的类                                 │    │
│  └─────────────────────────────────────────────────────────┘    │
│                                                                  │
│  3. 热部署/热替换                                               │
│  ┌─────────────────────────────────────────────────────────┐    │
│  │  需求：不重启应用的情况下更新代码                        │    │
│  │                                                          │    │
│  │  实现：                                                  │    │
│  │  • 创建新的类加载器加载新版本的类                       │    │
│  │  • 卸载旧的类加载器                                     │    │
│  │  • 同一个类被不同类加载器加载是不同的Class             │    │
│  └─────────────────────────────────────────────────────────┘    │
│                                                                  │
└─────────────────────────────────────────────────────────────────┘
```

**适用场景：** 理解Tomcat、Spring等框架的类加载机制

---

**追问：同一个类被不同类加载器加载，是同一个Class吗？**

**答案：**

```java
// 不是同一个Class！
// 类的唯一性 = 类全限定名 + 类加载器

MyClassLoader loader1 = new MyClassLoader("/path1");
MyClassLoader loader2 = new MyClassLoader("/path2");

Class<?> clazz1 = loader1.loadClass("com.example.User");
Class<?> clazz2 = loader2.loadClass("com.example.User");

System.out.println(clazz1 == clazz2);  // false

// 这也是为什么热部署可以实现：
// 新建类加载器加载新类，旧类加载器及其加载的类被GC回收

// 但这会导致instanceof判断问题：
Object obj = clazz1.newInstance();
System.out.println(obj instanceof com.example.User);  // 可能是false
// 因为当前上下文的User类可能由不同加载器加载
```

---

### 问题 22：Tomcat的类加载机制是怎样的？

**答案：**

```
┌─────────────────────────────────────────────────────────────────┐
│                    Tomcat 类加载器结构                           │
├─────────────────────────────────────────────────────────────────┤
│                                                                  │
│                  ┌─────────────────────┐                        │
│                  │ Bootstrap ClassLoader│                        │
│                  │     (JVM核心类)      │                        │
│                  └──────────┬──────────┘                        │
│                             │                                    │
│                  ┌──────────▼──────────┐                        │
│                  │Extension ClassLoader │                        │
│                  │    (JVM扩展类)       │                        │
│                  └──────────┬──────────┘                        │
│                             │                                    │
│                  ┌──────────▼──────────┐                        │
│                  │Application ClassLoader│                       │
│                  │   (classpath类)      │                        │
│                  └──────────┬──────────┘                        │
│                             │                                    │
│  ════════════════ Tomcat 类加载器 ═══════════════════════════   │
│                             │                                    │
│                  ┌──────────▼──────────┐                        │
│                  │   Common ClassLoader │                        │
│                  │ $CATALINA_HOME/lib   │                        │
│                  │ Tomcat和所有Web应用共享│                       │
│                  └──────────┬──────────┘                        │
│                             │                                    │
│            ┌────────────────┼────────────────┐                  │
│            │                │                │                   │
│   ┌────────▼────────┐  ┌───▼────┐   ┌───────▼───────┐          │
│   │Catalina ClassLoader│ │Server │   │Shared ClassLoader│        │
│   │  Tomcat自身类    │  │ClassLoader│ │  所有Web应用共享 │        │
│   │  对Web应用不可见  │  │        │   │                │          │
│   └─────────────────┘  └────────┘   └───────┬───────┘          │
│                                              │                   │
│                           ┌──────────────────┼────────────────┐ │
│                           │                  │                │  │
│                  ┌────────▼────────┐  ┌─────▼─────┐          │  │
│                  │ WebApp1 ClassLoader│ │WebApp2 ClassLoader│   │  │
│                  │  /WEB-INF/classes │ │ /WEB-INF/classes │    │  │
│                  │  /WEB-INF/lib     │ │ /WEB-INF/lib     │    │  │
│                  └─────────────────┘  └─────────────────┘     │  │
│                                                                  │
└─────────────────────────────────────────────────────────────────┘
```

**WebAppClassLoader的特殊加载顺序：**

```
┌─────────────────────────────────────────────────────────────────┐
│              WebAppClassLoader 类加载顺序                        │
├─────────────────────────────────────────────────────────────────┤
│                                                                  │
│   加载请求                                                       │
│       │                                                         │
│       ▼                                                         │
│   1. 从缓存中查找已加载的类                                      │
│       │                                                         │
│       ▼                                                         │
│   2. 如果没有，检查JVM核心类（防止覆盖）                         │
│       │                                                         │
│       ▼                                                         │
│   3. 从当前Web应用的 /WEB-INF/classes 加载  ← 优先自己加载！    │
│       │                                                         │
│       ▼                                                         │
│   4. 从当前Web应用的 /WEB-INF/lib/*.jar 加载                    │
│       │                                                         │
│       ▼                                                         │
│   5. 委派给父加载器（Common/Shared）                             │
│       │                                                         │
│       ▼                                                         │
│   6. 都找不到，抛出 ClassNotFoundException                      │
│                                                                  │
│   注意：这打破了双亲委派！先自己加载，再委派父加载器              │
│                                                                  │
└─────────────────────────────────────────────────────────────────┘
```

**为什么Tomcat要这样设计？**

| 设计目的 | 实现方式 |
|----------|----------|
| **Web应用隔离** | 每个应用独立的WebAppClassLoader |
| **同库不同版本** | WebApp1可用Spring 4，WebApp2可用Spring 5 |
| **安全性** | Catalina类对Web应用不可见 |
| **共享节省内存** | Common/Shared目录的类共享 |
| **热部署支持** | 重新创建WebAppClassLoader |

**配置示例：**

```xml
<!-- conf/catalina.properties -->
<!-- 配置共享类路径 -->
shared.loader=${catalina.base}/shared/lib/*.jar

<!-- 配置服务器类路径 -->
server.loader=${catalina.home}/server/lib/*.jar
```

**适用场景：** Web容器原理、多应用部署问题排查

---

**追问：如果Web应用和Tomcat的lib目录有同一个jar包，用哪个？**

**答案：**

```
默认情况下：用Web应用自己的（/WEB-INF/lib）

原因：WebAppClassLoader优先从自己的目录加载

但可以通过配置改变：
<Context>
    <!-- 设置为true时，恢复标准双亲委派 -->
    <Loader delegate="true"/>
</Context>

delegate="true"时的加载顺序：
1. Bootstrap → 2. Extension → 3. Application →
4. Common → 5. WebApp（先委派，后自己）

delegate="false"（默认）时的加载顺序：
1. Bootstrap → 2. Extension → 3. WebApp →
4. Common（先自己，后委派）
```

---

### 问题 23：SPI机制如何打破双亲委派？

**答案：**

**SPI（Service Provider Interface）** 是一种服务发现机制，典型应用如JDBC驱动加载。

```
┌─────────────────────────────────────────────────────────────────┐
│                    SPI 的问题与解决                              │
├─────────────────────────────────────────────────────────────────┤
│                                                                  │
│  问题描述：                                                      │
│  ┌─────────────────────────────────────────────────────────┐    │
│  │                                                          │    │
│  │   Bootstrap ClassLoader                                  │    │
│  │   ┌─────────────────────────┐                           │    │
│  │   │ java.sql.Driver (接口)  │                           │    │
│  │   │ java.sql.DriverManager  │                           │    │
│  │   └───────────┬─────────────┘                           │    │
│  │               │ 需要加载                                 │    │
│  │               ▼                                          │    │
│  │   Application ClassLoader                                │    │
│  │   ┌─────────────────────────┐                           │    │
│  │   │ com.mysql.cj.jdbc.Driver│                           │    │
│  │   │    (MySQL实现类)        │  ← Bootstrap看不到！      │    │
│  │   └─────────────────────────┘                           │    │
│  │                                                          │    │
│  │   按双亲委派：父加载器无法使用子加载器加载的类            │    │
│  └─────────────────────────────────────────────────────────┘    │
│                                                                  │
│  解决方案：线程上下文类加载器                                   │
│  ┌─────────────────────────────────────────────────────────┐    │
│  │                                                          │    │
│  │   DriverManager (Bootstrap加载)                          │    │
│  │         │                                                │    │
│  │         │ 获取线程上下文类加载器                         │    │
│  │         │ Thread.currentThread().getContextClassLoader() │    │
│  │         ▼                                                │    │
│  │   得到 Application ClassLoader                           │    │
│  │         │                                                │    │
│  │         │ 使用它加载                                     │    │
│  │         ▼                                                │    │
│  │   com.mysql.cj.jdbc.Driver 加载成功！                    │    │
│  │                                                          │    │
│  └─────────────────────────────────────────────────────────┘    │
│                                                                  │
└─────────────────────────────────────────────────────────────────┘
```

**SPI加载源码分析（ServiceLoader）：**

```java
// java.util.ServiceLoader
public static <S> ServiceLoader<S> load(Class<S> service) {
    // 获取线程上下文类加载器
    ClassLoader cl = Thread.currentThread().getContextClassLoader();
    return ServiceLoader.load(service, cl);
}

// 加载过程
private S nextService() {
    String cn = nextName;
    Class<?> c = null;
    try {
        // 使用线程上下文类加载器加载实现类
        c = Class.forName(cn, false, loader);
    } catch (ClassNotFoundException x) {
        // ...
    }
    // ...
}
```

**JDBC驱动加载流程：**

```java
// 1. 应用代码
Connection conn = DriverManager.getConnection(url, user, password);

// 2. DriverManager静态代码块（Bootstrap加载器加载）
static {
    loadInitialDrivers();  // 加载驱动
}

// 3. loadInitialDrivers方法
private static void loadInitialDrivers() {
    // 使用ServiceLoader加载
    ServiceLoader<Driver> loadedDrivers = ServiceLoader.load(Driver.class);
    // ServiceLoader.load内部使用线程上下文类加载器

    // 遍历META-INF/services/java.sql.Driver文件中的实现类
    Iterator<Driver> driversIterator = loadedDrivers.iterator();
    while(driversIterator.hasNext()) {
        driversIterator.next();  // 加载驱动实现类
    }
}

// 4. MySQL驱动的SPI配置
// jar包中：META-INF/services/java.sql.Driver
// 文件内容：com.mysql.cj.jdbc.Driver
```

**SPI配置文件结构：**

```
mysql-connector-java.jar
├── com/mysql/cj/jdbc/Driver.class
└── META-INF/services/
    └── java.sql.Driver          ← 文件名是接口全限定名
        内容：com.mysql.cj.jdbc.Driver  ← 实现类全限定名
```

**适用场景：** 理解JDBC、日志框架、Dubbo等框架的SPI机制

---

**追问：SPI和API有什么区别？**

**答案：**

```
┌────────────────────────────────────────────────────────────────┐
│                      API vs SPI                                │
├────────────────────────────────────────────────────────────────┤
│                                                                │
│  API (Application Programming Interface)                       │
│  ┌──────────────────────────────────────────────────────────┐ │
│  │  调用方：应用程序                                         │ │
│  │  实现方：框架/库                                          │ │
│  │                                                           │ │
│  │  应用程序 ──调用──▶ 框架提供的接口                       │ │
│  │                                                           │ │
│  │  例：List list = new ArrayList();                        │ │
│  │      list.add("item");  // 调用JDK提供的API             │ │
│  └──────────────────────────────────────────────────────────┘ │
│                                                                │
│  SPI (Service Provider Interface)                              │
│  ┌──────────────────────────────────────────────────────────┐ │
│  │  调用方：框架                                             │ │
│  │  实现方：应用程序/第三方                                  │ │
│  │                                                           │ │
│  │  框架 ──调用──▶ 应用程序实现的接口                       │ │
│  │                                                           │ │
│  │  例：JDBC框架调用MySQL驱动实现的Driver接口               │ │
│  │      框架定义接口，第三方提供实现                        │ │
│  └──────────────────────────────────────────────────────────┘ │
│                                                                │
│  本质区别：                                                    │
│  • API是框架给用户用的                                        │
│  • SPI是框架让用户扩展的                                      │
│                                                                │
└────────────────────────────────────────────────────────────────┘
```

---

### 问题 24：热部署的原理是什么？

**答案：**

```
┌─────────────────────────────────────────────────────────────────┐
│                       热部署原理                                 │
├─────────────────────────────────────────────────────────────────┤
│                                                                  │
│  核心思想：利用不同类加载器加载同一个类是不同Class的特性          │
│                                                                  │
│  ┌─────────────────────────────────────────────────────────┐    │
│  │                                                          │    │
│  │   时间T1：                                               │    │
│  │   ┌──────────────┐        ┌─────────────┐              │    │
│  │   │ClassLoader_V1│──加载──▶│ MyClass_V1  │              │    │
│  │   └──────────────┘        └─────────────┘              │    │
│  │                                                          │    │
│  │   时间T2：代码更新，需要热部署                            │    │
│  │   ┌──────────────┐        ┌─────────────┐              │    │
│  │   │ClassLoader_V2│──加载──▶│ MyClass_V2  │ ← 新版本    │    │
│  │   └──────────────┘        └─────────────┘              │    │
│  │                                                          │    │
│  │   ClassLoader_V1及其加载的类变为垃圾，等待GC              │    │
│  │                                                          │    │
│  └─────────────────────────────────────────────────────────┘    │
│                                                                  │
│  热部署流程：                                                    │
│  ┌─────────────────────────────────────────────────────────┐    │
│  │  1. 检测到文件变化（通过WatchService或轮询）             │    │
│  │  2. 创建新的类加载器                                     │    │
│  │  3. 用新类加载器加载修改后的类                           │    │
│  │  4. 创建新类的实例替换旧实例                             │    │
│  │  5. 旧类加载器和旧类等待GC回收                           │    │
│  └─────────────────────────────────────────────────────────┘    │
│                                                                  │
└─────────────────────────────────────────────────────────────────┘
```

**简单的热部署实现：**

```java
public class HotDeployDemo {

    private static Object serviceInstance;
    private static MyClassLoader currentLoader;

    public static void main(String[] args) throws Exception {
        // 启动文件监控
        startFileWatcher();

        // 初始加载
        reload();

        // 模拟调用服务
        while (true) {
            invokeService();
            Thread.sleep(3000);
        }
    }

    // 热加载方法
    public static void reload() throws Exception {
        // 创建新的类加载器
        MyClassLoader newLoader = new MyClassLoader("/path/to/classes");

        // 用新加载器加载类
        Class<?> clazz = newLoader.loadClass("com.example.MyService");

        // 创建新实例
        Object newInstance = clazz.newInstance();

        // 替换旧实例
        serviceInstance = newInstance;

        // 旧的类加载器会被GC回收
        currentLoader = newLoader;

        System.out.println("热部署完成！");
    }

    // 文件监控
    public static void startFileWatcher() {
        new Thread(() -> {
            try {
                WatchService watchService = FileSystems.getDefault().newWatchService();
                Path path = Paths.get("/path/to/classes");
                path.register(watchService, StandardWatchEventKinds.ENTRY_MODIFY);

                while (true) {
                    WatchKey key = watchService.take();
                    for (WatchEvent<?> event : key.pollEvents()) {
                        if (event.context().toString().endsWith(".class")) {
                            System.out.println("检测到类文件变化，开始热部署...");
                            reload();
                        }
                    }
                    key.reset();
                }
            } catch (Exception e) {
                e.printStackTrace();
            }
        }).start();
    }

    public static void invokeService() throws Exception {
        // 通过反射调用服务方法
        Method method = serviceInstance.getClass().getMethod("execute");
        method.invoke(serviceInstance);
    }
}
```

**热部署的限制：**

| 限制 | 说明 |
|------|------|
| 不能修改类结构 | 新增/删除方法、字段可能导致问题 |
| 静态变量丢失 | 新类加载器加载的类，静态变量重新初始化 |
| 内存泄漏风险 | 旧类加载器如果被引用，无法GC |
| 第三方库兼容性 | 某些库可能缓存Class，导致问题 |

**常用热部署方案：**

| 方案 | 特点 |
|------|------|
| Spring DevTools | 使用两个类加载器，重启速度快 |
| JRebel | 商业方案，支持更广泛的热部署场景 |
| DCEVM | 修改JVM，支持更激进的热替换 |
| Arthas redefine | 基于Instrumentation，运行时修改类 |

**适用场景：** 开发环境热部署、理解容器热部署原理

---

**追问：Spring DevTools热部署原理是什么？**

**答案：**

```
Spring DevTools 双类加载器机制：
┌────────────────────────────────────────────────────────────────┐
│                                                                │
│  ┌────────────────────────────────────────────────────────┐   │
│  │  Base ClassLoader                                       │   │
│  │  • 加载不变的第三方jar（Spring、MyBatis等）             │   │
│  │  • 重启时不重新加载                                     │   │
│  └────────────────────────────────────────────────────────┘   │
│                                                                │
│  ┌────────────────────────────────────────────────────────┐   │
│  │  Restart ClassLoader                                    │   │
│  │  • 加载用户自己的类（src/main/java）                    │   │
│  │  • 检测到变化时，丢弃并重建                             │   │
│  └────────────────────────────────────────────────────────┘   │
│                                                                │
│  优势：                                                        │
│  只重新加载变化的用户类，第三方库不需要重新加载                │
│  比完整重启快很多（通常1-2秒）                                 │
│                                                                │
└────────────────────────────────────────────────────────────────┘
```

---

## 第四节：JVM调优（25-30题）

---

### 问题 25：常用的JVM参数有哪些？

**答案：**

```
┌─────────────────────────────────────────────────────────────────┐
│                      常用 JVM 参数分类                           │
├─────────────────────────────────────────────────────────────────┤
│                                                                  │
│  一、内存设置                                                    │
│  ┌─────────────────────────────────────────────────────────┐    │
│  │  -Xms2g              # 初始堆大小 2GB                    │    │
│  │  -Xmx2g              # 最大堆大小 2GB（建议和Xms相同）   │    │
│  │  -Xmn512m            # 新生代大小 512MB                  │    │
│  │  -Xss256k            # 线程栈大小 256KB                  │    │
│  │  -XX:MetaspaceSize=256m    # 元空间初始大小              │    │
│  │  -XX:MaxMetaspaceSize=256m # 元空间最大大小              │    │
│  │  -XX:MaxDirectMemorySize=1g # 直接内存最大值             │    │
│  └─────────────────────────────────────────────────────────┘    │
│                                                                  │
│  二、垃圾收集器选择                                             │
│  ┌─────────────────────────────────────────────────────────┐    │
│  │  -XX:+UseSerialGC           # Serial + Serial Old       │    │
│  │  -XX:+UseParallelGC         # Parallel Scavenge+Parallel Old│ │
│  │  -XX:+UseParNewGC           # ParNew (配合CMS)           │    │
│  │  -XX:+UseConcMarkSweepGC    # CMS                        │    │
│  │  -XX:+UseG1GC               # G1收集器                   │    │
│  │  -XX:+UseZGC                # ZGC (JDK 11+)              │    │
│  │  -XX:+UseShenandoahGC       # Shenandoah                 │    │
│  └─────────────────────────────────────────────────────────┘    │
│                                                                  │
│  三、GC日志                                                     │
│  ┌─────────────────────────────────────────────────────────┐    │
│  │  # JDK 8                                                 │    │
│  │  -XX:+PrintGCDetails                                     │    │
│  │  -XX:+PrintGCDateStamps                                  │    │
│  │  -XX:+PrintGCTimeStamps                                  │    │
│  │  -Xloggc:/path/to/gc.log                                 │    │
│  │  -XX:+UseGCLogFileRotation                               │    │
│  │  -XX:NumberOfGCLogFiles=5                                │    │
│  │  -XX:GCLogFileSize=10M                                   │    │
│  │                                                          │    │
│  │  # JDK 9+ 统一日志                                       │    │
│  │  -Xlog:gc*:file=gc.log:time,level,tags:filecount=5,filesize=10m │
│  └─────────────────────────────────────────────────────────┘    │
│                                                                  │
│  四、OOM时dump                                                  │
│  ┌─────────────────────────────────────────────────────────┐    │
│  │  -XX:+HeapDumpOnOutOfMemoryError                         │    │
│  │  -XX:HeapDumpPath=/path/to/dump                          │    │
│  │  -XX:OnOutOfMemoryError="sh /scripts/restart.sh"         │    │
│  └─────────────────────────────────────────────────────────┘    │
│                                                                  │
│  五、G1参数                                                     │
│  ┌─────────────────────────────────────────────────────────┐    │
│  │  -XX:MaxGCPauseMillis=200   # 目标停顿时间200ms          │    │
│  │  -XX:G1HeapRegionSize=4m    # Region大小                 │    │
│  │  -XX:InitiatingHeapOccupancyPercent=45 # 触发并发标记阈值│    │
│  │  -XX:G1ReservePercent=10    # 预留空间防止晋升失败       │    │
│  └─────────────────────────────────────────────────────────┘    │
│                                                                  │
│  六、其他重要参数                                               │
│  ┌─────────────────────────────────────────────────────────┐    │
│  │  -XX:+DisableExplicitGC     # 禁用System.gc()            │    │
│  │  -XX:+UseCompressedOops     # 压缩指针（默认开启）       │    │
│  │  -XX:MaxTenuringThreshold=15 # 晋升老年代的年龄阈值      │    │
│  │  -XX:PretenureSizeThreshold=1m # 大对象直接进老年代      │    │
│  │  -XX:SurvivorRatio=8        # Eden:Survivor比例          │    │
│  └─────────────────────────────────────────────────────────┘    │
│                                                                  │
└─────────────────────────────────────────────────────────────────┘
```

**生产环境推荐配置模板：**

```bash
# JDK 8 + G1
java -server \
  -Xms4g -Xmx4g \
  -XX:+UseG1GC \
  -XX:MaxGCPauseMillis=200 \
  -XX:+HeapDumpOnOutOfMemoryError \
  -XX:HeapDumpPath=/logs/dump \
  -XX:+PrintGCDetails \
  -XX:+PrintGCDateStamps \
  -Xloggc:/logs/gc.log \
  -jar app.jar

# JDK 11+
java -server \
  -Xms4g -Xmx4g \
  -XX:+UseG1GC \
  -XX:MaxGCPauseMillis=200 \
  -XX:+HeapDumpOnOutOfMemoryError \
  -XX:HeapDumpPath=/logs/dump \
  -Xlog:gc*:file=/logs/gc.log:time,level,tags:filecount=5,filesize=50m \
  -jar app.jar
```

**适用场景：** JVM调优、应用部署配置

---

**追问：为什么建议 -Xms 和 -Xmx 设置成一样？**

**答案：**

```
原因：
1. 避免堆动态扩展带来的性能开销
   • 堆扩展可能触发Full GC
   • 扩展需要向OS申请内存，有开销

2. 避免堆收缩
   • GC后JVM可能归还内存给OS
   • 下次需要时又要重新申请

3. 服务稳定性
   • 启动时就分配足够内存，避免运行时OOM
   • 内存使用可预测

4. 便于监控
   • 已用/最大堆比例更有意义
   • 不会因为堆大小变化导致监控指标波动

例外情况：
• 开发环境可以不同（节省资源）
• 容器环境可能需要动态调整
```

---

### 问题 26：如何进行GC日志分析？

**答案：**

```
┌─────────────────────────────────────────────────────────────────┐
│                       GC 日志分析                                │
├─────────────────────────────────────────────────────────────────┤
│                                                                  │
│  一、开启GC日志                                                 │
│  ┌─────────────────────────────────────────────────────────┐    │
│  │  # JDK 8                                                 │    │
│  │  -XX:+PrintGCDetails -XX:+PrintGCDateStamps              │    │
│  │  -Xloggc:/path/gc.log                                    │    │
│  │                                                          │    │
│  │  # JDK 11+                                               │    │
│  │  -Xlog:gc*:file=gc.log:time,level,tags                   │    │
│  └─────────────────────────────────────────────────────────┘    │
│                                                                  │
│  二、Minor GC日志解读                                           │
│  ┌─────────────────────────────────────────────────────────┐    │
│  │                                                          │    │
│  │  2024-01-15T10:30:45.123+0800: 1.234:                    │    │
│  │  [GC (Allocation Failure)                                │    │
│  │   [PSYoungGen: 65536K->8192K(76288K)]                    │    │
│  │   65536K->16384K(251392K), 0.0156789 secs]               │    │
│  │  [Times: user=0.05 sys=0.01, real=0.02 secs]             │    │
│  │                                                          │    │
│  │  解析：                                                  │    │
│  │  ┌──────────────────────────────────────────────────┐   │    │
│  │  │ 时间戳: 2024-01-15T10:30:45.123                  │   │    │
│  │  │ JVM启动后时间: 1.234秒                           │   │    │
│  │  │ GC原因: Allocation Failure（分配失败）           │   │    │
│  │  │ 新生代: 65536K → 8192K (容量76288K)             │   │    │
│  │  │ 整个堆: 65536K → 16384K (容量251392K)           │   │    │
│  │  │ GC耗时: 0.0156789秒 ≈ 15.6ms                    │   │    │
│  │  │ user: 用户态CPU时间                             │   │    │
│  │  │ sys: 内核态CPU时间                              │   │    │
│  │  │ real: 实际墙钟时间（STW时间）                   │   │    │
│  │  └──────────────────────────────────────────────────┘   │    │
│  └─────────────────────────────────────────────────────────┘    │
│                                                                  │
│  三、Full GC日志解读                                            │
│  ┌─────────────────────────────────────────────────────────┐    │
│  │                                                          │    │
│  │  2024-01-15T10:35:12.456+0800: 5.678:                    │    │
│  │  [Full GC (Metadata GC Threshold)                        │    │
│  │   [PSYoungGen: 8192K->0K(76288K)]                        │    │
│  │   [ParOldGen: 16384K->12288K(175104K)]                   │    │
│  │   24576K->12288K(251392K),                               │    │
│  │   [Metaspace: 20480K->20480K(1067008K)],                 │    │
│  │   0.1234567 secs]                                        │    │
│  │                                                          │    │
│  │  解析：                                                  │    │
│  │  ┌──────────────────────────────────────────────────┐   │    │
│  │  │ GC原因: Metadata GC Threshold（元空间触发）      │   │    │
│  │  │ 新生代: 8192K → 0K（全部清空或晋升）            │   │    │
│  │  │ 老年代: 16384K → 12288K                         │   │    │
│  │  │ 元空间: 20480K → 20480K（未回收）               │   │    │
│  │  │ Full GC耗时: 123ms（较长！需要关注）            │   │    │
│  │  └──────────────────────────────────────────────────┘   │    │
│  └─────────────────────────────────────────────────────────┘    │
│                                                                  │
└─────────────────────────────────────────────────────────────────┘
```

**关键指标分析：**

| 指标 | 计算方式 | 健康标准 |
|------|----------|----------|
| Minor GC频率 | 统计单位时间Minor GC次数 | 几秒一次正常 |
| Minor GC耗时 | 每次GC的real时间 | < 50ms |
| Full GC频率 | 统计单位时间Full GC次数 | < 1次/小时 |
| Full GC耗时 | 每次Full GC的real时间 | < 1秒 |
| GC吞吐量 | 1 - GC时间/总时间 | > 95% |
| 内存回收效率 | 回收后内存/回收前内存 | 应该明显降低 |

**GC日志分析工具：**

```bash
# 1. GCViewer（图形化）
java -jar gcviewer.jar gc.log

# 2. GCEasy（在线分析）
https://gceasy.io/  # 上传日志文件

# 3. jstat（命令行实时）
jstat -gcutil <pid> 1000

# 输出示例：
#  S0     S1     E      O      M     CCS    YGC     YGCT    FGC    FGCT     GCT
# 0.00  50.00  30.00  45.00  95.00  92.00    10    0.150     1    0.200   0.350

# S0/S1: Survivor区使用率
# E: Eden区使用率
# O: 老年代使用率
# M: 元空间使用率
# YGC/YGCT: Young GC次数/时间
# FGC/FGCT: Full GC次数/时间
```

**适用场景：** GC问题排查、性能调优

---

**追问：GC日志中user、sys、real时间有什么关系？**

**答案：**

```
user: 用户态CPU时间（所有GC线程的总和）
sys:  内核态CPU时间（系统调用等）
real: 实际墙钟时间（真实流逝的时间，即STW时间）

关系分析：
┌────────────────────────────────────────────────────────────────┐
│                                                                │
│  1. 并行GC时：user + sys > real                               │
│     例：user=0.20 sys=0.02 real=0.05                          │
│     说明：4个GC线程并行工作，总CPU时间是real的4倍多           │
│                                                                │
│  2. 串行GC时：user + sys ≈ real                               │
│     例：user=0.05 sys=0.01 real=0.06                          │
│     说明：单线程GC，时间基本相等                               │
│                                                                │
│  3. 异常情况：real >> user + sys                              │
│     例：user=0.05 sys=0.01 real=2.00                          │
│     可能原因：                                                 │
│     • IO阻塞（swap内存交换）                                  │
│     • CPU资源不足（被其他进程抢占）                           │
│     • 需要重点排查！                                          │
│                                                                │
└────────────────────────────────────────────────────────────────┘
```

---

### 问题 27：JVM性能监控工具有哪些？

**答案：**

```
┌─────────────────────────────────────────────────────────────────┐
│                    JVM 监控工具全景                              │
├─────────────────────────────────────────────────────────────────┤
│                                                                  │
│  一、JDK自带命令行工具                                          │
│  ┌─────────────────────────────────────────────────────────┐    │
│  │  工具        │ 作用                                      │    │
│  │  ──────────────────────────────────────────────────────  │    │
│  │  jps        │ 查看Java进程                               │    │
│  │  jstat      │ 监控GC、类加载、JIT编译等统计信息          │    │
│  │  jinfo      │ 查看/修改JVM参数                           │    │
│  │  jmap       │ 生成堆dump、查看堆统计信息                 │    │
│  │  jstack     │ 生成线程dump、排查死锁                     │    │
│  │  jhat       │ 分析堆dump（已废弃，用MAT替代）            │    │
│  │  jcmd       │ 综合诊断命令（推荐）                       │    │
│  └─────────────────────────────────────────────────────────┘    │
│                                                                  │
│  二、JDK自带图形化工具                                          │
│  ┌─────────────────────────────────────────────────────────┐    │
│  │  jconsole   │ 基础监控（内存、线程、类、MBean）          │    │
│  │  jvisualvm  │ 功能更强（性能分析、快照、插件支持）       │    │
│  │  jmc        │ Java Mission Control（飞行记录器）         │    │
│  └─────────────────────────────────────────────────────────┘    │
│                                                                  │
│  三、第三方工具                                                 │
│  ┌─────────────────────────────────────────────────────────┐    │
│  │  Arthas     │ 阿里开源，在线诊断神器                     │    │
│  │  MAT        │ Eclipse Memory Analyzer，堆分析专家        │    │
│  │  JProfiler  │ 商业工具，性能分析全面                     │    │
│  │  YourKit    │ 商业工具，性能分析                         │    │
│  │  async-profiler │ 低开销火焰图分析器                     │    │
│  └─────────────────────────────────────────────────────────┘    │
│                                                                  │
└─────────────────────────────────────────────────────────────────┘
```

**常用命令示例：**

```bash
# ========== jps - 查看Java进程 ==========
jps -l         # 显示完整类名
jps -v         # 显示JVM参数

# 输出示例：
# 12345 com.example.Application
# 12346 org.apache.catalina.startup.Bootstrap

# ========== jstat - 监控统计信息 ==========
jstat -gcutil <pid> 1000 10   # 每秒输出1次，共10次

# 常用选项：
# -gc          GC堆统计
# -gcutil      GC统计百分比
# -gccause     GC原因
# -class       类加载统计
# -compiler    JIT编译统计

# ========== jinfo - 查看/修改参数 ==========
jinfo -flags <pid>            # 查看所有JVM参数
jinfo -flag MaxHeapSize <pid> # 查看单个参数
jinfo -flag +PrintGC <pid>    # 动态开启参数（部分参数支持）

# ========== jmap - 堆内存分析 ==========
jmap -heap <pid>              # 查看堆配置和使用情况
jmap -histo <pid>             # 对象统计（按类分组）
jmap -histo:live <pid>        # 只统计存活对象（会触发Full GC）
jmap -dump:format=b,file=heap.hprof <pid>  # 生成堆dump

# ========== jstack - 线程分析 ==========
jstack <pid>                  # 输出线程栈
jstack -l <pid>               # 包含锁信息
jstack -F <pid>               # 强制输出（进程无响应时）

# ========== jcmd - 综合诊断（推荐） ==========
jcmd <pid> help               # 查看支持的命令
jcmd <pid> VM.flags           # 查看JVM参数
jcmd <pid> GC.heap_info       # 堆信息
jcmd <pid> GC.run             # 触发GC
jcmd <pid> Thread.print       # 线程栈
jcmd <pid> VM.native_memory summary  # 本地内存（需开启NMT）
```

**Arthas常用命令：**

```bash
# 安装和启动
curl -O https://arthas.aliyun.com/arthas-boot.jar
java -jar arthas-boot.jar

# 常用命令
dashboard          # 仪表盘（线程、内存、GC等）
thread             # 线程列表
thread -n 3        # 最忙的3个线程
thread -b          # 查找死锁
jvm                # JVM信息
heapdump /tmp/dump.hprof  # 生成堆dump

# 方法级诊断
watch com.example.Service method "{params,returnObj}" -n 5
trace com.example.Service method  # 方法调用链路
stack com.example.Service method  # 方法调用栈

# 在线修改
redefine /tmp/MyClass.class  # 热更新类
```

**适用场景：** 线上问题诊断、性能分析

---

**追问：生产环境应该使用哪些监控指标？**

**答案：**

```
核心监控指标：
┌────────────────────────────────────────────────────────────────┐
│  类别          │ 指标                    │ 告警阈值            │
│  ─────────────────────────────────────────────────────────────│
│  内存          │ 堆使用率                │ > 80% 警告          │
│                │ 老年代使用率            │ > 85% 警告          │
│                │ 元空间使用率            │ > 90% 警告          │
│  ─────────────────────────────────────────────────────────────│
│  GC            │ Young GC频率            │ > 10次/秒 关注      │
│                │ Young GC平均耗时        │ > 50ms 关注         │
│                │ Full GC频率             │ > 1次/10分钟 严重   │
│                │ Full GC耗时             │ > 1秒 严重          │
│  ─────────────────────────────────────────────────────────────│
│  线程          │ 线程总数                │ 根据业务设定        │
│                │ BLOCKED线程数           │ > 0 需要关注        │
│                │ 死锁检测                │ 存在即严重          │
│  ─────────────────────────────────────────────────────────────│
│  类加载        │ 已加载类数              │ 持续增长需关注      │
│                │ 卸载类数                │ 正常应该很少        │
└────────────────────────────────────────────────────────────────┘

监控工具选择：
• 实时监控：Prometheus + Grafana
• 日志分析：ELK
• APM：SkyWalking、Pinpoint
• 告警：钉钉/飞书/企微机器人
```

---

### 问题 28：如何定位CPU过高问题？

**答案：**

```
┌─────────────────────────────────────────────────────────────────┐
│                   CPU 过高排查流程                               │
├─────────────────────────────────────────────────────────────────┤
│                                                                  │
│  Step 1: 找到CPU高的Java进程                                    │
│  ┌─────────────────────────────────────────────────────────┐    │
│  │  top -c                                                  │    │
│  │                                                          │    │
│  │  PID   USER  %CPU  %MEM  COMMAND                        │    │
│  │  12345 app   150%  25%   java -jar app.jar    ← 找到它  │    │
│  └─────────────────────────────────────────────────────────┘    │
│                          │                                      │
│                          ▼                                      │
│  Step 2: 找到CPU高的线程                                        │
│  ┌─────────────────────────────────────────────────────────┐    │
│  │  # 方法1：top -H                                         │    │
│  │  top -Hp 12345                                           │    │
│  │                                                          │    │
│  │  PID   %CPU  COMMAND                                    │    │
│  │  12346 98%   java          ← 线程ID（十进制）           │    │
│  │  12347 45%   java                                       │    │
│  │                                                          │    │
│  │  # 方法2：ps命令                                         │    │
│  │  ps -mp 12345 -o THREAD,tid,time | sort -rn | head -10  │    │
│  └─────────────────────────────────────────────────────────┘    │
│                          │                                      │
│                          ▼                                      │
│  Step 3: 转换线程ID为十六进制                                   │
│  ┌─────────────────────────────────────────────────────────┐    │
│  │  printf "%x\n" 12346                                     │    │
│  │  输出：303a    ← 十六进制线程ID                         │    │
│  └─────────────────────────────────────────────────────────┘    │
│                          │                                      │
│                          ▼                                      │
│  Step 4: 导出线程栈并查找                                       │
│  ┌─────────────────────────────────────────────────────────┐    │
│  │  jstack 12345 > thread_dump.txt                          │    │
│  │                                                          │    │
│  │  # 搜索十六进制线程ID                                    │    │
│  │  grep -A 30 "nid=0x303a" thread_dump.txt                 │    │
│  │                                                          │    │
│  │  "Thread-1" #123 prio=5 os_prio=0 tid=0x... nid=0x303a   │    │
│  │     java.lang.Thread.State: RUNNABLE                     │    │
│  │        at com.example.Service.calculate(Service.java:100) │   │
│  │        at com.example.Controller.handle(Controller.java:50)│  │
│  │        ...                                                │    │
│  │                                                          │    │
│  │  ↑ 找到问题代码位置！                                    │    │
│  └─────────────────────────────────────────────────────────┘    │
│                                                                  │
└─────────────────────────────────────────────────────────────────┘
```

**一键脚本：**

```bash
#!/bin/bash
# show-busy-java-threads.sh

# 参数：Java进程PID
PID=$1

# 获取最忙的5个线程
busy_threads=$(ps -mp $PID -o THREAD,tid,time | sort -rn | head -6 | tail -5)

# 导出线程栈
jstack $PID > /tmp/jstack_$PID.txt

echo "=== CPU最高的线程 ==="
echo "$busy_threads"
echo ""
echo "=== 线程栈信息 ==="

# 遍历并显示每个线程的栈
echo "$busy_threads" | awk '{print $8}' | while read tid; do
    hex_tid=$(printf "%x" $tid)
    echo "--- Thread $tid (0x$hex_tid) ---"
    grep -A 30 "nid=0x$hex_tid" /tmp/jstack_$PID.txt
    echo ""
done
```

**使用Arthas排查（更简单）：**

```bash
# 进入Arthas
java -jar arthas-boot.jar

# 查看最忙的线程
thread -n 3

# 输出示例：
# "Thread-1" Id=123 cpuUsage=95% deltaTime=950ms time=12345ms RUNNABLE
#     at com.example.Service.calculate(Service.java:100)
#     at com.example.Controller.handle(Controller.java:50)

# 直接定位到代码位置！
```

**常见CPU高的原因：**

| 原因 | 现象 | 解决方案 |
|------|------|----------|
| 死循环 | 某线程持续100% | 修复代码逻辑 |
| 频繁GC | GC线程CPU高 | JVM调优 |
| 正则回溯 | 字符串处理CPU高 | 优化正则表达式 |
| 序列化 | 序列化操作CPU高 | 使用高效序列化库 |
| 加密解密 | 安全相关CPU高 | 优化算法或硬件加速 |
| 无限递归 | 很快StackOverflow | 修复递归终止条件 |

**适用场景：** 线上性能问题排查，高频面试题

---

**追问：如果CPU不高但应用响应慢，怎么排查？**

**答案：**

```
CPU不高但响应慢的原因：
┌────────────────────────────────────────────────────────────────┐
│  1. 线程阻塞                                                   │
│     jstack查看BLOCKED/WAITING状态的线程                        │
│     thread -b  # Arthas查看阻塞线程                           │
│                                                                │
│  2. 锁竞争                                                     │
│     jstack -l 查看锁信息                                       │
│     grep -A5 "waiting to lock" thread_dump.txt                 │
│                                                                │
│  3. IO等待（数据库、网络、文件）                               │
│     iostat -x 1  # 查看磁盘IO                                  │
│     netstat -anp | grep ESTABLISHED  # 查看网络连接            │
│     慢SQL日志分析                                               │
│                                                                │
│  4. 外部依赖慢                                                 │
│     trace命令追踪调用链路                                       │
│     skywalking/zipkin查看分布式链路                            │
│                                                                │
│  5. GC停顿                                                     │
│     查看GC日志，关注STW时间                                     │
│                                                                │
│  6. 线程池打满                                                 │
│     查看线程数，是否在队列中排队                               │
└────────────────────────────────────────────────────────────────┘
```

---

### 问题 29：如何设置合理的堆大小？

**答案：**

```
┌─────────────────────────────────────────────────────────────────┐
│                    堆大小设置原则                                │
├─────────────────────────────────────────────────────────────────┤
│                                                                  │
│  一、基本原则                                                   │
│  ┌─────────────────────────────────────────────────────────┐    │
│  │  1. 不要超过物理内存的 70-80%                            │    │
│  │     留给OS、堆外内存、其他进程                           │    │
│  │                                                          │    │
│  │  2. 32位JVM最大约 1.5-2GB                                │    │
│  │     64位JVM理论无限制，实际看物理内存                    │    │
│  │                                                          │    │
│  │  3. -Xms = -Xmx                                          │    │
│  │     避免动态扩展开销                                     │    │
│  │                                                          │    │
│  │  4. 新生代大小：整个堆的 1/3 到 1/2                      │    │
│  │     太小：Minor GC频繁                                   │    │
│  │     太大：老年代空间不足，Full GC频繁                    │    │
│  └─────────────────────────────────────────────────────────┘    │
│                                                                  │
│  二、根据应用类型设置                                           │
│  ┌─────────────────────────────────────────────────────────┐    │
│  │                                                          │    │
│  │  高吞吐量应用（批处理、计算）                            │    │
│  │  • 更大的堆（8GB+）                                      │    │
│  │  • 更大的新生代                                          │    │
│  │  • 较长的GC停顿可接受                                    │    │
│  │                                                          │    │
│  │  低延迟应用（Web服务、交易）                             │    │
│  │  • 中等大小的堆（4-8GB）                                 │    │
│  │  • 使用G1/ZGC                                            │    │
│  │  • 关注GC停顿时间                                        │    │
│  │                                                          │    │
│  │  内存敏感应用（容器、大量实例）                          │    │
│  │  • 较小的堆                                              │    │
│  │  • 关注GC吞吐量                                          │    │
│  │                                                          │    │
│  └─────────────────────────────────────────────────────────┘    │
│                                                                  │
└─────────────────────────────────────────────────────────────────┘
```

**计算方法：**

```
方法1：基于Full GC后存活对象大小

步骤：
1. 在生产环境或压测环境运行应用
2. 触发Full GC后，观察老年代使用量
3. 假设Full GC后老年代使用200MB（存活对象）

推荐配置：
┌────────────────────────────────────────────────────────────────┐
│  区域         │ 大小                    │ 计算方式             │
│  ─────────────────────────────────────────────────────────────│
│  老年代       │ 600MB - 800MB          │ 存活对象 × 3~4       │
│  新生代       │ 300MB - 400MB          │ 存活对象 × 1.5~2     │
│  总堆大小     │ 900MB - 1200MB         │ 老年代 + 新生代      │
│  元空间       │ 256MB                  │ 根据类数量调整       │
└────────────────────────────────────────────────────────────────┘


方法2：基于QPS和对象生命周期

假设：
• QPS = 1000
• 每个请求创建 10KB 临时对象
• 请求处理时间 100ms

计算：
每秒产生对象 = 1000 × 10KB = 10MB/秒
100ms内存活对象 = 10MB × 0.1 = 1MB

新生代应该能容纳多次请求周期的对象：
新生代 >= 10MB × 10秒 = 100MB（至少10秒才触发一次Minor GC）
实际建议：512MB - 1GB
```

**容器环境特殊考虑：**

```bash
# Docker/K8s 环境

# 问题：JVM可能看到宿主机内存，而不是容器限制
# JDK 8u191+ / JDK 10+ 默认支持容器感知

# 推荐配置（使用比例而非固定值）
-XX:InitialRAMPercentage=70
-XX:MaxRAMPercentage=70
-XX:MinRAMPercentage=70

# 或者明确设置
-Xms512m -Xmx512m

# 容器建议：
# 1. 容器内存限制 = JVM堆 + 堆外 + OS预留
# 2. 例：容器2GB，JVM堆1.2GB，堆外200MB，OS预留600MB
```

**适用场景：** JVM调优、容器部署

---

**追问：堆设置过大有什么问题？**

**答案：**

```
堆过大的问题：
┌────────────────────────────────────────────────────────────────┐
│  1. GC停顿时间长                                               │
│     堆越大，Full GC遍历对象越多，STW时间越长                   │
│     10GB堆的Full GC可能需要几十秒                              │
│                                                                │
│  2. 启动时间长                                                 │
│     JVM需要初始化整个堆空间                                    │
│     大堆启动可能需要几十秒                                     │
│                                                                │
│  3. 浪费资源                                                   │
│     如果应用用不了那么多内存                                   │
│     占用资源影响其他应用                                       │
│                                                                │
│  4. GC频率低但冲击大                                           │
│     内存充足时GC很少触发                                       │
│     一旦触发，停顿时间很长                                     │
│                                                                │
│  解决方案：                                                    │
│  • 使用G1/ZGC，可控停顿时间                                   │
│  • 合理设置，不是越大越好                                      │
│  • 监控GC情况，根据实际调整                                    │
└────────────────────────────────────────────────────────────────┘
```

---

### 问题 30：线上OOM问题如何排查？

**答案：**

```
┌─────────────────────────────────────────────────────────────────┐
│                    OOM 排查完整流程                              │
├─────────────────────────────────────────────────────────────────┤
│                                                                  │
│  Step 0: 预防配置（事前准备）                                   │
│  ┌─────────────────────────────────────────────────────────┐    │
│  │  # JVM启动参数必须配置！                                 │    │
│  │  -XX:+HeapDumpOnOutOfMemoryError                         │    │
│  │  -XX:HeapDumpPath=/logs/heapdump/                        │    │
│  │  -XX:OnOutOfMemoryError="sh /scripts/alert.sh"           │    │
│  │                                                          │    │
│  │  # GC日志                                                │    │
│  │  -Xlog:gc*:file=/logs/gc.log:time,level,tags             │    │
│  └─────────────────────────────────────────────────────────┘    │
│                          │                                      │
│                          ▼                                      │
│  Step 1: 确定OOM类型                                           │
│  ┌─────────────────────────────────────────────────────────┐    │
│  │  查看错误日志，确定是哪种OOM                             │    │
│  │                                                          │    │
│  │  java.lang.OutOfMemoryError: Java heap space            │    │
│  │  → 堆内存不足                                            │    │
│  │                                                          │    │
│  │  java.lang.OutOfMemoryError: Metaspace                  │    │
│  │  → 元空间不足（加载类太多）                              │    │
│  │                                                          │    │
│  │  java.lang.OutOfMemoryError: GC overhead limit exceeded │    │
│  │  → GC频繁但回收很少                                      │    │
│  │                                                          │    │
│  │  java.lang.OutOfMemoryError: Direct buffer memory       │    │
│  │  → 直接内存不足                                          │    │
│  │                                                          │    │
│  │  java.lang.OutOfMemoryError: Unable to create new thread│    │
│  │  → 线程数过多                                            │    │
│  └─────────────────────────────────────────────────────────┘    │
│                          │                                      │
│                          ▼                                      │
│  Step 2: 获取堆dump文件                                        │
│  ┌─────────────────────────────────────────────────────────┐    │
│  │  # 方式1：自动生成（推荐，需要事先配置）                 │    │
│  │  查看 -XX:HeapDumpPath 配置的目录                        │    │
│  │                                                          │    │
│  │  # 方式2：手动生成（进程还活着时）                       │    │
│  │  jmap -dump:live,format=b,file=heap.hprof <pid>          │    │
│  │                                                          │    │
│  │  # 方式3：使用jcmd                                       │    │
│  │  jcmd <pid> GC.heap_dump /path/heap.hprof                │    │
│  └─────────────────────────────────────────────────────────┘    │
│                          │                                      │
│                          ▼                                      │
│  Step 3: 分析堆dump                                            │
│  ┌─────────────────────────────────────────────────────────┐    │
│  │  工具：MAT (Eclipse Memory Analyzer)                     │    │
│  │                                                          │    │
│  │  1. 打开 Leak Suspects Report                           │    │
│  │     查看自动分析的泄漏嫌疑对象                           │    │
│  │                                                          │    │
│  │  2. 查看 Dominator Tree                                 │    │
│  │     找出占用内存最大的对象                               │    │
│  │                                                          │    │
│  │  3. 查看 Histogram                                      │    │
│  │     按类统计对象数量和大小                               │    │
│  │                                                          │    │
│  │  4. 选择可疑对象 → Path to GC Roots                     │    │
│  │     查看对象被谁引用，为什么无法回收                     │    │
│  └─────────────────────────────────────────────────────────┘    │
│                          │                                      │
│                          ▼                                      │
│  Step 4: 定位代码问题                                          │
│  ┌─────────────────────────────────────────────────────────┐    │
│  │  根据GC Roots引用链，找到代码位置                        │    │
│  │                                                          │    │
│  │  常见问题代码模式：                                      │    │
│  │  • 静态集合不断添加数据                                  │    │
│  │  • 缓存没有淘汰策略                                      │    │
│  │  • ThreadLocal未清理                                     │    │
│  │  • 监听器/回调未注销                                     │    │
│  │  • 资源（连接、流）未关闭                                │    │
│  │  • 大SQL查询结果未分页                                   │    │
│  └─────────────────────────────────────────────────────────┘    │
│                                                                  │
└─────────────────────────────────────────────────────────────────┘
```

**MAT分析示例：**

```
1. 打开堆dump文件

2. Leak Suspects Report 输出：
┌────────────────────────────────────────────────────────────────┐
│  Problem Suspect 1                                             │
│  ────────────────────────────────────────────────────────────  │
│  One instance of "java.util.HashMap" loaded by "<system>"      │
│  occupies 512,000,000 (85.5%) bytes.                          │
│                                                                │
│  The memory is accumulated in one instance of                  │
│  "java.util.HashMap$Node[]"                                    │
│                                                                │
│  Keywords: java.util.HashMap                                   │
│            com.example.cache.UserCache                         │
│                                                                │
│  ↑ 提示UserCache中的HashMap占用了大量内存                     │
└────────────────────────────────────────────────────────────────┘

3. 查看 Path to GC Roots:
GC Root: Thread → UserCache (static) → HashMap → Entry[]
↓
说明：UserCache类的静态变量持有HashMap，导致无法回收

4. 查看代码：
public class UserCache {
    // 问题：静态Map不断增长，没有淘汰策略
    private static Map<Long, User> cache = new HashMap<>();

    public void addUser(User user) {
        cache.put(user.getId(), user);  // 只进不出！
    }
}

5. 修复：
// 方案1：使用WeakHashMap
// 方案2：使用Caffeine/Guava Cache设置过期
// 方案3：定时清理
```

**不同OOM类型的排查重点：**

| OOM类型 | 排查重点 | 常见原因 |
|---------|----------|----------|
| Java heap space | 堆dump分析 | 内存泄漏、堆设置过小 |
| Metaspace | 类加载分析 | 动态代理、反射、CGLib |
| GC overhead | GC日志分析 | 内存泄漏导致GC频繁 |
| Direct buffer | 堆外内存分析 | NIO ByteBuffer未释放 |
| Unable to create thread | 线程dump | 线程泄漏、ulimit限制 |

**适用场景：** 生产环境故障排查，高级工程师必备技能

---

**追问：如果没有配置HeapDumpOnOutOfMemoryError，OOM后进程已经挂了，怎么办？**

**答案：**

```
补救措施：
┌────────────────────────────────────────────────────────────────┐
│  1. 检查是否有core dump                                        │
│     • 某些OS配置下会生成core dump                              │
│     • 可以从core dump提取堆信息                                │
│     ulimit -c unlimited  # 开启core dump                       │
│                                                                │
│  2. 分析GC日志                                                 │
│     • 如果有GC日志，分析OOM前的内存变化趋势                    │
│     • 找到内存持续增长的时间点                                 │
│                                                                │
│  3. 分析应用日志                                               │
│     • 结合业务日志，分析OOM前在执行什么操作                    │
│     • 关联时间点，找可疑代码                                   │
│                                                                │
│  4. 代码Review                                                 │
│     • 检查常见内存泄漏模式                                     │
│     • 使用静态代码分析工具                                     │
│                                                                │
│  5. 复现问题                                                   │
│     • 在测试环境复现                                           │
│     • 配置好dump参数后压测                                     │
│                                                                │
│  6. 预防措施                                                   │
│     • 立即配置HeapDumpOnOutOfMemoryError                       │
│     • 等下次OOM时分析                                          │
│                                                                │
│  教训：                                                        │
│  生产环境必须配置 -XX:+HeapDumpOnOutOfMemoryError             │
│  这是血泪教训！                                                │
└────────────────────────────────────────────────────────────────┘
```

---

# 第一章 JVM 总结

| 知识点 | 核心内容 | 重要程度 |
|--------|----------|----------|
| 内存模型 | 运行时数据区域、对象布局、引用类型 | ⭐⭐⭐⭐⭐ |
| 垃圾回收 | GC算法、分代收集、CMS/G1/ZGC | ⭐⭐⭐⭐⭐ |
| 类加载 | 加载过程、双亲委派、热部署 | ⭐⭐⭐⭐ |
| JVM调优 | 参数配置、GC日志、性能监控、OOM排查 | ⭐⭐⭐⭐⭐ |

---

