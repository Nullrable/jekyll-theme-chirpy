---
title: Java 高级工程师面试题 - 第二章 - 并发与多线程
author: nhsoft.lsd
date: 2026-01-14
categories: [Java]
pin: false
---

# 第二章：并发与多线程

## 2.1 线程基础（8题）

### 31. 线程的生命周期和状态转换？

```
┌─────────────────────────────────────────────────────────────────┐
│                        线程生命周期                              │
├─────────────────────────────────────────────────────────────────┤
│                                                                 │
│   ┌─────┐  start()  ┌──────────┐                               │
│   │ NEW │──────────▶│ RUNNABLE │◀─────────────────┐            │
│   └─────┘           └────┬─────┘                  │            │
│                          │                        │            │
│          ┌───────────────┼───────────────┐       │            │
│          ▼               ▼               ▼       │            │
│   ┌──────────┐    ┌──────────┐    ┌──────────┐   │            │
│   │ BLOCKED  │    │ WAITING  │    │  TIMED   │   │            │
│   │ 等待锁   │    │ 无限等待 │    │ WAITING  │   │            │
│   └────┬─────┘    └────┬─────┘    └────┬─────┘   │            │
│        │               │               │         │            │
│        └───────────────┴───────────────┴─────────┘            │
│                          │                                     │
│                          ▼                                     │
│                    ┌────────────┐                              │
│                    │ TERMINATED │                              │
│                    └────────────┘                              │
└─────────────────────────────────────────────────────────────────┘
```

| 状态 | 触发条件 |
|------|----------|
| **NEW** | new Thread()，未调用start() |
| **RUNNABLE** | 调用start()，包含Ready和Running |
| **BLOCKED** | 等待synchronized锁 |
| **WAITING** | wait()、join()、LockSupport.park() |
| **TIMED_WAITING** | sleep(n)、wait(n)、join(n) |
| **TERMINATED** | run()执行完毕或异常退出 |

---

### 32. 创建线程有哪几种方式？

```java
// 1. 继承Thread
class MyThread extends Thread {
    public void run() { /* 任务 */ }
}

// 2. 实现Runnable（推荐）
new Thread(() -> { /* 任务 */ }).start();

// 3. 实现Callable（有返回值）
FutureTask<String> task = new FutureTask<>(() -> "result");
new Thread(task).start();
String result = task.get();

// 4. 线程池（最推荐）
ExecutorService pool = Executors.newFixedThreadPool(4);
pool.submit(() -> { /* 任务 */ });
```

**对比**：
| 方式 | 返回值 | 异常处理 | 资源复用 |
|------|--------|----------|----------|
| Thread | ❌ | ❌ | ❌ |
| Runnable | ❌ | ❌ | ✅ |
| Callable | ✅ | ✅ | ✅ |
| 线程池 | ✅ | ✅ | ✅✅ |

---

### 33. sleep()和wait()的区别？

```
┌────────────────┬─────────────────────┬─────────────────────┐
│     对比项     │      sleep()        │       wait()        │
├────────────────┼─────────────────────┼─────────────────────┤
│     所属类     │      Thread         │       Object        │
├────────────────┼─────────────────────┼─────────────────────┤
│    释放锁      │        ❌ 不释放     │       ✅ 释放       │
├────────────────┼─────────────────────┼─────────────────────┤
│    使用位置    │       任意位置       │    synchronized块   │
├────────────────┼─────────────────────┼─────────────────────┤
│    唤醒方式    │      时间到自动      │   notify/notifyAll  │
├────────────────┼─────────────────────┼─────────────────────┤
│    用途        │       暂停执行       │      线程通信       │
└────────────────┴─────────────────────┴─────────────────────┘
```

```java
// sleep - 不释放锁
synchronized(lock) {
    Thread.sleep(1000);  // 持有锁睡眠
}

// wait - 释放锁
synchronized(lock) {
    lock.wait();  // 释放锁，进入等待
}
```

---

### 34. 为什么wait()必须在同步块中调用？

**核心原因：避免Lost Wake-Up问题**

```java
// ❌ 错误：不在同步块中
if (条件不满足) {
    // 此时另一线程修改条件并notify，但当前线程还没wait
    obj.wait();  // 永远等待，错过唤醒信号
}

// ✅ 正确：在同步块中
synchronized (obj) {
    while (条件不满足) {  // 用while防止虚假唤醒
        obj.wait();
    }
}
```

```
┌─────────────────────────────────────────────────────────────┐
│                   Lost Wake-Up 问题                         │
├─────────────────────────────────────────────────────────────┤
│                                                             │
│   线程A                          线程B                      │
│     │                              │                        │
│     │  1.检查条件(不满足)          │                        │
│     │         ←───── 切换 ─────→   │                        │
│     │                              │ 2.修改条件             │
│     │                              │ 3.notify() ─→ 无人等待 │
│     │         ←───── 切换 ─────→   │                        │
│     │  4.wait() ─→ 永远等待        │                        │
│     ▼                              ▼                        │
│                                                             │
└─────────────────────────────────────────────────────────────┘
```

---

### 35. yield()和join()的作用？

```java
// yield() - 让出CPU，重新竞争
Thread.yield();  // 提示调度器，当前线程愿意让出CPU
// 注意：只是提示，调度器可忽略；不释放锁

// join() - 等待线程结束
Thread t = new Thread(() -> doWork());
t.start();
t.join();  // 主线程等待t执行完毕
t.join(1000);  // 最多等1秒
```

```
┌──────────────────────────────────────────────────────┐
│                    join() 原理                        │
├──────────────────────────────────────────────────────┤
│                                                      │
│   Main Thread          Thread-t                      │
│       │                    │                         │
│       │   t.start()        │                         │
│       ├───────────────────▶│                         │
│       │                    │ 执行任务                 │
│       │   t.join()         │                         │
│       │─ ─ ─ ─ ─ ─ wait ─ ─│                         │
│       │                    │                         │
│       │                    │ 执行完毕                 │
│       │◀──── notify ───────│                         │
│       │                    ▼                         │
│       │ 继续执行                                      │
│       ▼                                              │
└──────────────────────────────────────────────────────┘
```

---

### 36. 线程中断机制是怎样的？

```java
// 中断相关方法
thread.interrupt();      // 设置中断标志
thread.isInterrupted();  // 检查中断标志（不清除）
Thread.interrupted();    // 检查并清除中断标志（静态方法）
```

```java
// 正确响应中断
public void run() {
    while (!Thread.currentThread().isInterrupted()) {
        try {
            // 阻塞方法会抛出InterruptedException并清除中断标志
            Thread.sleep(1000);
        } catch (InterruptedException e) {
            // 重新设置中断标志，或直接退出
            Thread.currentThread().interrupt();
            break;
        }
    }
}
```

```
┌─────────────────────────────────────────────────────────┐
│                   中断机制要点                           │
├─────────────────────────────────────────────────────────┤
│  • interrupt() 只是设置标志，不会强制停止线程            │
│  • sleep/wait/join 遇到中断会抛异常并清除标志           │
│  • 线程需主动检查中断标志来决定是否退出                  │
│  • 不要用 stop()（已废弃），会导致数据不一致             │
└─────────────────────────────────────────────────────────┘
```

---

### 37. 守护线程是什么？有什么用？

```java
Thread daemon = new Thread(() -> {
    while (true) {
        // 后台任务：GC、监控等
    }
});
daemon.setDaemon(true);  // 必须在start()前设置
daemon.start();
```

```
┌─────────────────────────────────────────────────────────┐
│                    守护线程特点                          │
├─────────────────────────────────────────────────────────┤
│                                                         │
│   用户线程                守护线程                       │
│   ┌──────┐               ┌──────┐                       │
│   │ Main │               │  GC  │                       │
│   │ 业务 │               │ 监控 │                       │
│   └──┬───┘               └──────┘                       │
│      │                      ↑                           │
│      │                      │                           │
│      ▼                      │                           │
│   全部结束  ────────────▶  自动终止                     │
│                                                         │
├─────────────────────────────────────────────────────────┤
│  使用场景：GC线程、心跳检测、日志服务、缓存清理          │
│  注意：守护线程中不要进行IO或资源操作（可能随时终止）    │
└─────────────────────────────────────────────────────────┘
```

---

### 38. 线程间通信的方式有哪些？

```
┌─────────────────────────────────────────────────────────────────┐
│                      线程通信方式                                │
├──────────────────┬──────────────────────────────────────────────┤
│   共享内存       │  volatile、synchronized、AtomicXXX           │
├──────────────────┼──────────────────────────────────────────────┤
│   等待/通知      │  wait/notify、Condition、LockSupport         │
├──────────────────┼──────────────────────────────────────────────┤
│   管道通信       │  PipedInputStream/PipedOutputStream          │
├──────────────────┼──────────────────────────────────────────────┤
│   阻塞队列       │  BlockingQueue（生产者-消费者）               │
├──────────────────┼──────────────────────────────────────────────┤
│   同步工具       │  CountDownLatch、CyclicBarrier、Semaphore    │
└──────────────────┴──────────────────────────────────────────────┘
```

```java
// 最常用：BlockingQueue
BlockingQueue<String> queue = new LinkedBlockingQueue<>(10);

// 生产者
queue.put("data");  // 满则阻塞

// 消费者
String data = queue.take();  // 空则阻塞
```

---

## 2.2 锁机制（10题）

### 39. synchronized的实现原理？

```
┌─────────────────────────────────────────────────────────────────┐
│                  synchronized 实现原理                           │
├─────────────────────────────────────────────────────────────────┤
│                                                                 │
│   ┌─────────────────────────────────────────────────────────┐   │
│   │                    对象头 (Object Header)                │   │
│   ├───────────────────────┬─────────────────────────────────┤   │
│   │     Mark Word (64bit) │     Klass Pointer               │   │
│   │  ┌─────────────────┐  │                                 │   │
│   │  │ 锁状态 + 其他信息│  │                                 │   │
│   │  └─────────────────┘  │                                 │   │
│   └───────────────────────┴─────────────────────────────────┘   │
│                                                                 │
│   同步代码块：monitorenter / monitorexit 指令                    │
│   同步方法：ACC_SYNCHRONIZED 标志                                │
│                                                                 │
│   ┌─────────────────────────────────────────────────────────┐   │
│   │                     Monitor 结构                         │   │
│   │  ┌─────────────┐  ┌─────────────┐  ┌─────────────────┐  │   │
│   │  │   Owner     │  │ EntryList   │  │    WaitSet      │  │   │
│   │  │  持有锁线程  │  │  阻塞队列   │  │    等待队列     │  │   │
│   │  └─────────────┘  └─────────────┘  └─────────────────┘  │   │
│   └─────────────────────────────────────────────────────────┘   │
└─────────────────────────────────────────────────────────────────┘
```

---

### 40. 锁升级过程是怎样的？

```
┌─────────────────────────────────────────────────────────────────┐
│                       锁升级过程（不可逆）                        │
├─────────────────────────────────────────────────────────────────┤
│                                                                 │
│  ┌──────────┐    ┌──────────┐    ┌──────────┐    ┌──────────┐  │
│  │  无锁    │───▶│  偏向锁  │───▶│  轻量级锁│───▶│  重量级锁│  │
│  │          │    │          │    │          │    │          │  │
│  └──────────┘    └──────────┘    └──────────┘    └──────────┘  │
│       │              │               │               │          │
│       ▼              ▼               ▼               ▼          │
│    无竞争        单线程访问       CAS自旋         阻塞等待       │
│                 记录ThreadID    多线程轻度竞争   多线程重度竞争   │
│                                                                 │
├─────────────────────────────────────────────────────────────────┤
│  Mark Word 变化：                                               │
│  无锁：     [hashcode | age | 0 | 01]                           │
│  偏向锁：   [threadId | epoch | age | 1 | 01]                   │
│  轻量级锁： [指向栈中锁记录的指针 | 00]                          │
│  重量级锁： [指向Monitor的指针 | 10]                             │
└─────────────────────────────────────────────────────────────────┘
```

---

### 41. ReentrantLock和synchronized的区别？

```
┌─────────────────┬────────────────────┬────────────────────┐
│      特性       │   synchronized     │   ReentrantLock    │
├─────────────────┼────────────────────┼────────────────────┤
│    实现层面     │     JVM内置        │      JDK API       │
├─────────────────┼────────────────────┼────────────────────┤
│    锁获取方式   │     自动获取释放    │     手动lock/unlock│
├─────────────────┼────────────────────┼────────────────────┤
│    可中断       │        ❌          │    ✅ lockInterr.  │
├─────────────────┼────────────────────┼────────────────────┤
│    超时获取     │        ❌          │    ✅ tryLock      │
├─────────────────┼────────────────────┼────────────────────┤
│    公平锁       │        ❌          │    ✅ 可选         │
├─────────────────┼────────────────────┼────────────────────┤
│    多条件变量   │     单一wait       │    多个Condition   │
├─────────────────┼────────────────────┼────────────────────┤
│    锁绑定对象   │    this/Class      │      Lock对象      │
└─────────────────┴────────────────────┴────────────────────┘
```

```java
ReentrantLock lock = new ReentrantLock();
try {
    if (lock.tryLock(1, TimeUnit.SECONDS)) {
        try {
            // 业务逻辑
        } finally {
            lock.unlock();  // 必须在finally中释放
        }
    }
} catch (InterruptedException e) { }
```

---

### 42. 公平锁和非公平锁的区别？

```
┌─────────────────────────────────────────────────────────────────┐
│                    公平锁 vs 非公平锁                            │
├─────────────────────────────────────────────────────────────────┤
│                                                                 │
│   公平锁：排队获取，先来先得                                     │
│   ┌─────┐   ┌─────┐   ┌─────┐   ┌─────┐                        │
│   │ T4  │──▶│ T3  │──▶│ T2  │──▶│ T1  │──▶ 获取锁              │
│   └─────┘   └─────┘   └─────┘   └─────┘                        │
│                                                                 │
│   非公平锁：新线程可插队                                         │
│   ┌─────┐   ┌─────┐   ┌─────┐                                  │
│   │ T4  │──▶│ T3  │──▶│ T2  │                                  │
│   └─────┘   └─────┘   └─────┘                                  │
│                  ↑                                              │
│              ┌─────┐                                            │
│              │T-New│ 直接抢锁！                                  │
│              └─────┘                                            │
├─────────────────────────────────────────────────────────────────┤
│  公平锁：   吞吐量低，无饥饿                                      │
│  非公平锁： 吞吐量高（减少上下文切换），可能饥饿                   │
└─────────────────────────────────────────────────────────────────┘
```

```java
new ReentrantLock(true);   // 公平锁
new ReentrantLock(false);  // 非公平锁（默认）
```

---

### 43. 读写锁的实现原理？

```
┌─────────────────────────────────────────────────────────────────┐
│                   ReentrantReadWriteLock                        │
├─────────────────────────────────────────────────────────────────┤
│                                                                 │
│   ┌─────────────────────────────────────────────────────────┐   │
│   │                 state (32位int)                          │   │
│   │  ┌───────────────────┬───────────────────┐              │   │
│   │  │    高16位：读锁    │    低16位：写锁    │              │   │
│   │  │    持有次数       │    重入次数        │              │   │
│   │  └───────────────────┴───────────────────┘              │   │
│   └─────────────────────────────────────────────────────────┘   │
│                                                                 │
│   读读共享  │  读写互斥  │  写写互斥                            │
│      ✅     │     ❌     │     ❌                               │
│                                                                 │
├─────────────────────────────────────────────────────────────────┤
│   适用场景：读多写少（如缓存）                                   │
└─────────────────────────────────────────────────────────────────┘
```

```java
ReentrantReadWriteLock rwLock = new ReentrantReadWriteLock();
rwLock.readLock().lock();    // 读锁
rwLock.writeLock().lock();   // 写锁
```

---

### 44. StampedLock是什么？有什么优势？

```java
StampedLock sl = new StampedLock();

// 1. 乐观读（无锁）- 性能最高
long stamp = sl.tryOptimisticRead();
// 读取数据
if (!sl.validate(stamp)) {
    // 乐观读失败，升级为悲观读
    stamp = sl.readLock();
    try { /* 重新读取 */ }
    finally { sl.unlockRead(stamp); }
}

// 2. 悲观读锁
long stamp = sl.readLock();

// 3. 写锁
long stamp = sl.writeLock();
```

```
┌─────────────────────────────────────────────────────────────────┐
│                 StampedLock vs ReadWriteLock                    │
├─────────────────────────────────────────────────────────────────┤
│  优势：                                                         │
│  • 乐观读不阻塞写操作，提升并发度                                │
│  • 读多写少场景性能更好                                          │
│                                                                 │
│  缺点：                                                         │
│  • 不可重入                                                     │
│  • 不支持Condition                                              │
│  • 使用复杂，需要配合validate                                   │
└─────────────────────────────────────────────────────────────────┘
```

---

### 45. 什么是死锁？如何避免？

```
┌─────────────────────────────────────────────────────────────────┐
│                         死锁示意                                 │
├─────────────────────────────────────────────────────────────────┤
│                                                                 │
│      Thread-A                    Thread-B                       │
│         │                           │                           │
│         │ 持有锁A                    │ 持有锁B                   │
│         │      ╲                ╱    │                          │
│         │       ╲    请求     ╱     │                           │
│         │        ╲          ╱      │                            │
│         │         ╲        ╱       │                            │
│         │          ╲      ╱        │                            │
│         │           ╲    ╱         │                            │
│         │            ╲  ╱          │                            │
│         │             ╳ 死锁!      │                            │
│         │            ╱  ╲          │                            │
│         │ 请求锁B   ╱    ╲  请求锁A │                            │
│         ▼         ╱      ╲         ▼                            │
│                                                                 │
└─────────────────────────────────────────────────────────────────┘
```

**死锁四个必要条件**：
1. **互斥**：资源只能被一个线程占用
2. **持有并等待**：持有资源同时等待其他资源
3. **不可剥夺**：资源只能主动释放
4. **循环等待**：形成等待环路

**避免方法**：
```java
// 1. 固定加锁顺序（打破循环等待）
synchronized(lockA) {
    synchronized(lockB) { }
}

// 2. 超时机制（打破不可剥夺）
if (lock.tryLock(1, TimeUnit.SECONDS)) { }

// 3. 一次性获取所有锁（打破持有并等待）
```

---

### 46. 什么是活锁和饥饿？

```
┌─────────────────────────────────────────────────────────────────┐
│                      活锁 (LiveLock)                            │
├─────────────────────────────────────────────────────────────────┤
│                                                                 │
│   线程A        线程B          ← 两人相遇 →                      │
│     │            │                                              │
│   让路 ──────▶ 让路      同时让路                               │
│     │            │                                              │
│   过去 ◀────── 过去      又同时过去                              │
│     │            │                                              │
│   让路 ──────▶ 让路      无限循环...                            │
│                                                                 │
│   解决：引入随机退避时间                                         │
└─────────────────────────────────────────────────────────────────┘

┌─────────────────────────────────────────────────────────────────┐
│                      饥饿 (Starvation)                          │
├─────────────────────────────────────────────────────────────────┤
│                                                                 │
│   高优先级线程：不断获取锁 ─────────────▶                       │
│   低优先级线程：一直等待...永远得不到锁   ×                      │
│                                                                 │
│   解决：使用公平锁                                               │
└─────────────────────────────────────────────────────────────────┘
```

---

### 47. 乐观锁和悲观锁的区别和适用场景？

```
┌─────────────────┬──────────────────────┬──────────────────────┐
│                 │       悲观锁         │        乐观锁        │
├─────────────────┼──────────────────────┼──────────────────────┤
│     思想        │  假设会冲突，先加锁   │ 假设不冲突，提交验证 │
├─────────────────┼──────────────────────┼──────────────────────┤
│     实现        │  synchronized/Lock   │   CAS/版本号         │
├─────────────────┼──────────────────────┼──────────────────────┤
│     适用场景    │  写多、竞争激烈       │  读多写少、竞争少    │
├─────────────────┼──────────────────────┼──────────────────────┤
│     问题        │  阻塞、死锁风险       │  ABA问题、自旋开销   │
└─────────────────┴──────────────────────┴──────────────────────┘
```

```java
// 悲观锁
synchronized(obj) { count++; }

// 乐观锁 - CAS
AtomicInteger count = new AtomicInteger();
count.incrementAndGet();  // CAS自旋

// 乐观锁 - 版本号（数据库）
UPDATE t SET val=newVal, version=version+1
WHERE id=? AND version=oldVersion
```

---

### 48. 分段锁的原理是什么？

```
┌─────────────────────────────────────────────────────────────────┐
│                     分段锁原理 (ConcurrentHashMap 1.7)          │
├─────────────────────────────────────────────────────────────────┤
│                                                                 │
│   ┌────────────────────────────────────────────────────────┐   │
│   │                    Segment数组                          │   │
│   │  ┌──────┐ ┌──────┐ ┌──────┐ ┌──────┐ ... ┌──────┐     │   │
│   │  │Seg-0 │ │Seg-1 │ │Seg-2 │ │Seg-3 │     │Seg-15│     │   │
│   │  │ Lock │ │ Lock │ │ Lock │ │ Lock │     │ Lock │     │   │
│   │  └──┬───┘ └──┬───┘ └──┬───┘ └──┬───┘     └──┬───┘     │   │
│   │     │        │        │        │            │          │   │
│   │     ▼        ▼        ▼        ▼            ▼          │   │
│   │  ┌─────┐  ┌─────┐  ┌─────┐  ┌─────┐     ┌─────┐       │   │
│   │  │Entry│  │Entry│  │Entry│  │Entry│     │Entry│       │   │
│   │  │数组 │  │数组 │  │数组 │  │数组 │     │数组 │       │   │
│   │  └─────┘  └─────┘  └─────┘  └─────┘     └─────┘       │   │
│   └────────────────────────────────────────────────────────┘   │
│                                                                 │
│   不同段可并发操作，理论并发度 = Segment数量（默认16）           │
│                                                                 │
│   JDK1.8改进：取消Segment，使用 synchronized + CAS              │
│              锁粒度细化到每个桶（Node）                          │
└─────────────────────────────────────────────────────────────────┘
```

---

## 2.3 JUC工具类（9题）

### 49. AQS的原理是什么？

```
┌─────────────────────────────────────────────────────────────────┐
│           AQS (AbstractQueuedSynchronizer) 原理                 │
├─────────────────────────────────────────────────────────────────┤
│                                                                 │
│   核心结构：                                                     │
│   ┌─────────────────────────────────────────────────────────┐   │
│   │  state (volatile int)    ← 同步状态                      │   │
│   │  0: 未锁定  /  >0: 已锁定（重入次数）                     │   │
│   └─────────────────────────────────────────────────────────┘   │
│                                                                 │
│   ┌─────────────────────────────────────────────────────────┐   │
│   │             CLH队列（双向链表）                           │   │
│   │                                                          │   │
│   │  ┌──────┐    ┌──────┐    ┌──────┐    ┌──────┐           │   │
│   │  │ head │◀──▶│Node-1│◀──▶│Node-2│◀──▶│ tail │           │   │
│   │  │(哨兵)│    │等待中│    │等待中│    │      │           │   │
│   │  └──────┘    └──────┘    └──────┘    └──────┘           │   │
│   └─────────────────────────────────────────────────────────┘   │
│                                                                 │
│   模板方法：tryAcquire/tryRelease（独占）                       │
│            tryAcquireShared/tryReleaseShared（共享）            │
│                                                                 │
│   基于AQS实现：ReentrantLock、Semaphore、CountDownLatch等       │
└─────────────────────────────────────────────────────────────────┘
```

---

### 50. CountDownLatch和CyclicBarrier的区别？

```
┌─────────────────────────────────────────────────────────────────┐
│                    CountDownLatch（倒计数）                      │
├─────────────────────────────────────────────────────────────────┤
│   主线程等待多个子线程完成                                       │
│                                                                 │
│   ┌──────┐  ┌──────┐  ┌──────┐                                 │
│   │子线程1│  │子线程2│  │子线程3│                                │
│   └───┬───┘  └───┬───┘  └───┬───┘                               │
│       │          │          │                                   │
│   countDown  countDown  countDown                               │
│       │          │          │                                   │
│       └──────────┴──────────┘                                   │
│                  │                                              │
│                  ▼  count=0                                     │
│            ┌──────────┐                                         │
│            │ 主线程    │  await()返回                           │
│            │ 继续执行  │                                         │
│            └──────────┘                                         │
└─────────────────────────────────────────────────────────────────┘

┌─────────────────────────────────────────────────────────────────┐
│                    CyclicBarrier（循环栅栏）                     │
├─────────────────────────────────────────────────────────────────┤
│   多个线程互相等待，到齐后一起通过                               │
│                                                                 │
│   ┌──────┐  ┌──────┐  ┌──────┐                                 │
│   │线程1 │  │线程2 │  │线程3 │                                  │
│   └───┬───┘  └───┬───┘  └───┬───┘                               │
│       │          │          │                                   │
│    await()    await()    await()                                │
│       │          │          │                                   │
│   ════╪══════════╪══════════╪════  屏障点（可重复使用）          │
│       │          │          │                                   │
│       ▼          ▼          ▼                                   │
│     继续        继续        继续                                 │
└─────────────────────────────────────────────────────────────────┘
```

| 对比 | CountDownLatch | CyclicBarrier |
|------|----------------|---------------|
| 复用 | 一次性 | 可循环使用 |
| 等待 | 一个等多个 | 多个互相等 |
| 回调 | 无 | 可指定barrierAction |

---

### 51. Semaphore的使用场景？

```java
// 限流：控制并发数量
Semaphore semaphore = new Semaphore(3);  // 最多3个并发

// 获取许可
semaphore.acquire();  // 阻塞获取
semaphore.tryAcquire(1, TimeUnit.SECONDS);  // 超时获取

// 释放许可
semaphore.release();
```

```
┌─────────────────────────────────────────────────────────────────┐
│                     Semaphore 使用场景                          │
├─────────────────────────────────────────────────────────────────┤
│                                                                 │
│   许可数 = 3                                                    │
│   ┌─────────────────────────────────────┐                      │
│   │  ○ ○ ○  │  等待队列: T4 T5 T6 ...   │                      │
│   │  T1 T2 T3                           │                      │
│   └─────────────────────────────────────┘                      │
│            ↑                                                    │
│            │ release() 后 T4 可进入                             │
│                                                                 │
├─────────────────────────────────────────────────────────────────┤
│   应用场景：                                                     │
│   • 数据库连接池                                                 │
│   • 接口限流（同时最多N个请求）                                  │
│   • 停车场车位管理                                               │
└─────────────────────────────────────────────────────────────────┘
```

---

### 52. Exchanger的作用？

```java
Exchanger<String> exchanger = new Exchanger<>();

// 线程A
String dataA = exchanger.exchange("来自A的数据");  // 返回B的数据

// 线程B
String dataB = exchanger.exchange("来自B的数据");  // 返回A的数据
```

```
┌─────────────────────────────────────────────────────────────────┐
│                    Exchanger 数据交换                           │
├─────────────────────────────────────────────────────────────────┤
│                                                                 │
│       Thread-A                    Thread-B                      │
│          │                           │                          │
│      "数据A"                      "数据B"                       │
│          │                           │                          │
│          │    exchange()交换点       │                          │
│          │◀═══════════════════════▶  │                          │
│          │                           │                          │
│      "数据B"                      "数据A"                       │
│          │                           │                          │
│          ▼                           ▼                          │
│                                                                 │
│   应用：双缓冲、遗传算法配对                                     │
└─────────────────────────────────────────────────────────────────┘
```

---

### 53. Phaser是什么？

```java
Phaser phaser = new Phaser(3);  // 3个参与者

// 动态注册/注销
phaser.register();      // 增加参与者
phaser.arriveAndDeregister();  // 到达并注销

// 等待
phaser.arriveAndAwaitAdvance();  // 到达并等待其他人
```

```
┌─────────────────────────────────────────────────────────────────┐
│        Phaser = CountDownLatch + CyclicBarrier 增强版           │
├─────────────────────────────────────────────────────────────────┤
│                                                                 │
│   阶段0        阶段1        阶段2        阶段3                   │
│   ──────────▶──────────▶──────────▶──────────▶                  │
│      │           │           │           │                      │
│   ┌──┴──┐     ┌──┴──┐     ┌──┴──┐     ┌──┴──┐                  │
│   │T1T2T3│    │T1T2T3│    │T1T2 │     │T1T2 │   T3动态退出     │
│   └─────┘     └─────┘     └─────┘     └─────┘                  │
│                              ↑                                  │
│                         可动态增减参与者                         │
│                                                                 │
│   优势：支持多阶段同步、动态参与者、层级结构                     │
└─────────────────────────────────────────────────────────────────┘
```

---

### 54. LockSupport的原理？

```java
// 阻塞当前线程
LockSupport.park();
LockSupport.parkNanos(1000_000_000L);  // 带超时

// 唤醒指定线程
LockSupport.unpark(thread);
```

```
┌─────────────────────────────────────────────────────────────────┐
│                    LockSupport 原理                             │
├─────────────────────────────────────────────────────────────────┤
│                                                                 │
│   每个线程有一个 permit（许可证，0或1）                          │
│                                                                 │
│   park()：消耗permit                                            │
│   - permit=1 → permit=0，直接返回                               │
│   - permit=0 → 阻塞等待                                         │
│                                                                 │
│   unpark()：发放permit                                          │
│   - permit=0 → permit=1                                         │
│   - 若线程阻塞中，唤醒它                                         │
│                                                                 │
├─────────────────────────────────────────────────────────────────┤
│   vs wait/notify:                                               │
│   • 无需synchronized                                            │
│   • unpark可在park之前调用（先发permit）                        │
│   • 可精确唤醒指定线程                                          │
└─────────────────────────────────────────────────────────────────┘
```

---

### 55. Condition的使用方式？

```java
ReentrantLock lock = new ReentrantLock();
Condition notFull = lock.newCondition();
Condition notEmpty = lock.newCondition();

// 生产者
lock.lock();
try {
    while (isFull()) notFull.await();  // 等待不满
    produce();
    notEmpty.signal();  // 通知消费者
} finally {
    lock.unlock();
}

// 消费者
lock.lock();
try {
    while (isEmpty()) notEmpty.await();  // 等待不空
    consume();
    notFull.signal();  // 通知生产者
} finally {
    lock.unlock();
}
```

```
┌─────────────────────────────────────────────────────────────────┐
│            Condition vs Object.wait/notify                      │
├─────────────────────────────────────────────────────────────────┤
│  • 一个Lock可创建多个Condition（多条件队列）                    │
│  • synchronized只有一个等待队列                                 │
│  • Condition可精确唤醒特定条件的线程                            │
└─────────────────────────────────────────────────────────────────┘
```

---

### 56. 原子类的实现原理？

```
┌─────────────────────────────────────────────────────────────────┐
│                    CAS (Compare And Swap)                       │
├─────────────────────────────────────────────────────────────────┤
│                                                                 │
│   CAS(内存位置V, 期望值A, 新值B)                                 │
│                                                                 │
│   if (V == A) {                                                 │
│       V = B;                                                    │
│       return true;                                              │
│   } else {                                                      │
│       return false;  // 重试                                    │
│   }                                                             │
│                                                                 │
│   底层：CPU原子指令 cmpxchg                                     │
│   Java：Unsafe.compareAndSwapInt()                              │
└─────────────────────────────────────────────────────────────────┘
```

```java
// 自旋CAS实现
public final int incrementAndGet() {
    for (;;) {
        int current = get();
        int next = current + 1;
        if (compareAndSet(current, next))
            return next;
    }
}
```

**ABA问题解决**：`AtomicStampedReference`（版本号）

---

### 57. LongAdder为什么比AtomicLong性能好？

```
┌─────────────────────────────────────────────────────────────────┐
│               AtomicLong vs LongAdder                           │
├─────────────────────────────────────────────────────────────────┤
│                                                                 │
│   AtomicLong：所有线程竞争同一个value                           │
│   ┌───────────────────────────────────────┐                    │
│   │              value                     │                    │
│   │   T1 T2 T3 T4 ... 全部CAS竞争         │                    │
│   └───────────────────────────────────────┘                    │
│   高并发时：大量CAS失败重试                                      │
│                                                                 │
│   LongAdder：分散竞争到多个Cell                                 │
│   ┌──────┐ ┌──────┐ ┌──────┐ ┌──────┐                         │
│   │Cell-0│ │Cell-1│ │Cell-2│ │Cell-3│  + base                  │
│   │  T1  │ │  T2  │ │  T3  │ │  T4  │                          │
│   └──────┘ └──────┘ └──────┘ └──────┘                          │
│                      │                                          │
│                      ▼                                          │
│              sum() = base + ΣCells                              │
│                                                                 │
├─────────────────────────────────────────────────────────────────┤
│   LongAdder缺点：sum()非精确（统计过程中可能有并发修改）        │
│   适用场景：统计计数（最终一致性即可）                          │
└─────────────────────────────────────────────────────────────────┘
```

---

## 2.4 线程池（8题）

### 58. 线程池的核心参数有哪些？

```java
new ThreadPoolExecutor(
    corePoolSize,      // 核心线程数（常驻）
    maximumPoolSize,   // 最大线程数
    keepAliveTime,     // 非核心线程空闲存活时间
    TimeUnit.SECONDS,  // 时间单位
    workQueue,         // 任务队列
    threadFactory,     // 线程工厂
    handler            // 拒绝策略
);
```

```
┌─────────────────────────────────────────────────────────────────┐
│                      线程池参数图解                              │
├─────────────────────────────────────────────────────────────────┤
│                                                                 │
│   ┌─────────────────────────────────────────────────────────┐   │
│   │              maximumPoolSize = 10                        │   │
│   │  ┌───────────────────────────────────────────────────┐  │   │
│   │  │           corePoolSize = 5                         │  │   │
│   │  │  ┌─────┐┌─────┐┌─────┐┌─────┐┌─────┐              │  │   │
│   │  │  │核心1││核心2││核心3││核心4││核心5│              │  │   │
│   │  │  └─────┘└─────┘└─────┘└─────┘└─────┘              │  │   │
│   │  └───────────────────────────────────────────────────┘  │   │
│   │     ┌─────┐┌─────┐┌─────┐┌─────┐┌─────┐                 │   │
│   │     │临时1││临时2││临时3││临时4││临时5│ ← keepAliveTime │   │
│   │     └─────┘└─────┘└─────┘└─────┘└─────┘   后销毁        │   │
│   └─────────────────────────────────────────────────────────┘   │
│                                                                 │
│   ┌─────────────────────────────────────────────────────────┐   │
│   │  workQueue: [任务1][任务2][任务3]...                     │   │
│   └─────────────────────────────────────────────────────────┘   │
└─────────────────────────────────────────────────────────────────┘
```

---

### 59. 线程池的执行流程是怎样的？

```
┌─────────────────────────────────────────────────────────────────┐
│                     线程池执行流程                               │
├─────────────────────────────────────────────────────────────────┤
│                                                                 │
│                    提交任务                                      │
│                       │                                         │
│                       ▼                                         │
│          ┌────────────────────────┐                            │
│          │ 线程数 < corePoolSize? │                            │
│          └───────────┬────────────┘                            │
│                 Yes  │  No                                      │
│                 ↓    ↓                                          │
│    ┌──────────────┐  │                                         │
│    │创建核心线程   │  │                                         │
│    │执行任务      │  │                                         │
│    └──────────────┘  │                                         │
│                      ▼                                         │
│          ┌────────────────────────┐                            │
│          │   工作队列未满？        │                            │
│          └───────────┬────────────┘                            │
│                 Yes  │  No                                      │
│                 ↓    ↓                                          │
│    ┌──────────────┐  │                                         │
│    │任务加入队列   │  │                                         │
│    └──────────────┘  │                                         │
│                      ▼                                         │
│          ┌─────────────────────────────┐                       │
│          │ 线程数 < maximumPoolSize？   │                       │
│          └───────────┬─────────────────┘                       │
│                 Yes  │  No                                      │
│                 ↓    ↓                                          │
│    ┌──────────────┐  ┌──────────────┐                          │
│    │创建非核心线程│  │ 执行拒绝策略 │                          │
│    │执行任务      │  └──────────────┘                          │
│    └──────────────┘                                            │
│                                                                 │
└─────────────────────────────────────────────────────────────────┘
```

---

### 60. 四种拒绝策略是什么？

```
┌──────────────────────┬───────────────────────────────────────────┐
│        策略          │                  行为                      │
├──────────────────────┼───────────────────────────────────────────┤
│   AbortPolicy        │  抛出RejectedExecutionException（默认）   │
├──────────────────────┼───────────────────────────────────────────┤
│   CallerRunsPolicy   │  调用者线程执行任务（降级）               │
├──────────────────────┼───────────────────────────────────────────┤
│   DiscardPolicy      │  静默丢弃任务                             │
├──────────────────────┼───────────────────────────────────────────┤
│   DiscardOldestPolicy│  丢弃队列最旧任务，重新提交当前任务       │
└──────────────────────┴───────────────────────────────────────────┘
```

```java
// 自定义拒绝策略
new RejectedExecutionHandler() {
    public void rejectedExecution(Runnable r, ThreadPoolExecutor e) {
        // 记录日志、持久化、重试等
        log.warn("任务被拒绝: {}", r);
        // 可选：放入MQ等待后续处理
    }
}
```

---

### 61. 如何合理设置线程池大小？

```
┌─────────────────────────────────────────────────────────────────┐
│                   线程池大小设置公式                             │
├─────────────────────────────────────────────────────────────────┤
│                                                                 │
│   CPU密集型：线程数 = CPU核心数 + 1                              │
│   （计算为主，减少上下文切换）                                    │
│                                                                 │
│   IO密集型：线程数 = CPU核心数 × 2                               │
│   或：线程数 = CPU核心数 × (1 + IO等待时间/CPU计算时间)          │
│   （IO等待时可切换其他线程）                                      │
│                                                                 │
├─────────────────────────────────────────────────────────────────┤
│   实际建议：                                                     │
│   1. 压测确定（模拟真实场景）                                    │
│   2. 监控调整（观察CPU利用率、队列大小）                         │
│   3. 考虑下游依赖（数据库连接池大小等）                          │
│                                                                 │
│   参考值：                                                       │
│   • Web服务器：200~500                                          │
│   • 批处理：CPU核心数 × 2                                        │
└─────────────────────────────────────────────────────────────────┘
```

---

### 62. Executors创建线程池有什么问题？

```
┌──────────────────────────┬───────────────────────────────────────┐
│     Executors方法        │              风险                      │
├──────────────────────────┼───────────────────────────────────────┤
│  newFixedThreadPool      │  队列：LinkedBlockingQueue(无界)      │
│  newSingleThreadExecutor │  → 任务堆积导致OOM                    │
├──────────────────────────┼───────────────────────────────────────┤
│  newCachedThreadPool     │  最大线程数：Integer.MAX_VALUE        │
│                          │  → 创建过多线程导致OOM                │
├──────────────────────────┼───────────────────────────────────────┤
│  newScheduledThreadPool  │  队列：DelayedWorkQueue(无界)         │
│                          │  → 任务堆积导致OOM                    │
└──────────────────────────┴───────────────────────────────────────┘
```

```java
// ✅ 推荐：手动创建，明确参数
ThreadPoolExecutor pool = new ThreadPoolExecutor(
    5, 10, 60, TimeUnit.SECONDS,
    new ArrayBlockingQueue<>(100),  // 有界队列
    new ThreadPoolExecutor.CallerRunsPolicy()
);
```

---

### 63. 线程池如何实现动态调整？

```java
ThreadPoolExecutor pool = new ThreadPoolExecutor(...);

// 动态调整参数（运行时生效）
pool.setCorePoolSize(newCoreSize);
pool.setMaximumPoolSize(newMaxSize);
pool.setKeepAliveTime(60, TimeUnit.SECONDS);

// 监控指标
pool.getActiveCount();     // 活跃线程数
pool.getPoolSize();        // 当前线程数
pool.getQueue().size();    // 队列任务数
pool.getCompletedTaskCount();  // 已完成任务数
```

```
┌─────────────────────────────────────────────────────────────────┐
│                   动态线程池实现思路                             │
├─────────────────────────────────────────────────────────────────┤
│                                                                 │
│   ┌──────────────┐         ┌──────────────┐                    │
│   │  配置中心    │ ──────▶ │  线程池      │                    │
│   │  Nacos/Apollo│  推送   │  参数调整    │                    │
│   └──────────────┘         └──────────────┘                    │
│          │                        │                             │
│          ▼                        ▼                             │
│   ┌──────────────┐         ┌──────────────┐                    │
│   │  监控系统    │ ◀────── │  指标上报    │                    │
│   │  Prometheus  │         │              │                    │
│   └──────────────┘         └──────────────┘                    │
│                                                                 │
│   开源方案：Hippo4j、dynamic-tp                                 │
└─────────────────────────────────────────────────────────────────┘
```

---

### 64. ForkJoinPool的原理和使用场景？

```
┌─────────────────────────────────────────────────────────────────┐
│                    ForkJoinPool 原理                            │
├─────────────────────────────────────────────────────────────────┤
│                                                                 │
│   分治思想 + 工作窃取（Work-Stealing）                          │
│                                                                 │
│          ┌──────────────────┐                                  │
│          │   大任务          │                                  │
│          └────────┬─────────┘                                  │
│              fork │                                             │
│         ┌─────────┴─────────┐                                  │
│         ▼                   ▼                                   │
│   ┌──────────┐       ┌──────────┐                              │
│   │  子任务1  │       │  子任务2  │                              │
│   └─────┬────┘       └────┬─────┘                              │
│         │     join        │                                     │
│         └────────┬────────┘                                     │
│                  ▼                                              │
│            合并结果                                              │
│                                                                 │
│   工作窃取：空闲线程从其他线程队列尾部窃取任务                   │
└─────────────────────────────────────────────────────────────────┘
```

```java
// 示例：并行求和
class SumTask extends RecursiveTask<Long> {
    protected Long compute() {
        if (数据量小) return 直接计算;
        // 拆分
        SumTask left = new SumTask(左半部分);
        SumTask right = new SumTask(右半部分);
        left.fork();
        Long rightResult = right.compute();
        Long leftResult = left.join();
        return leftResult + rightResult;
    }
}

// 使用
ForkJoinPool pool = ForkJoinPool.commonPool();
Long result = pool.invoke(new SumTask(data));
```

**适用场景**：大数据量计算、递归任务、Stream并行流

---

### 65. CompletableFuture的使用方式？

```java
// 1. 异步执行
CompletableFuture.supplyAsync(() -> fetchData())
    .thenApply(data -> process(data))      // 转换
    .thenAccept(result -> save(result))    // 消费
    .exceptionally(e -> handleError(e));   // 异常处理

// 2. 组合多个任务
CompletableFuture<String> f1 = CompletableFuture.supplyAsync(() -> "Hello");
CompletableFuture<String> f2 = CompletableFuture.supplyAsync(() -> "World");

// 都完成后合并
f1.thenCombine(f2, (s1, s2) -> s1 + " " + s2);

// 任一完成即返回
CompletableFuture.anyOf(f1, f2);

// 全部完成
CompletableFuture.allOf(f1, f2).join();

// 3. 超时控制（Java9+）
future.orTimeout(3, TimeUnit.SECONDS);
```

```
┌─────────────────────────────────────────────────────────────────┐
│                CompletableFuture 常用方法                       │
├───────────────────┬─────────────────────────────────────────────┤
│   创建            │  supplyAsync / runAsync                     │
├───────────────────┼─────────────────────────────────────────────┤
│   转换            │  thenApply / thenCompose                    │
├───────────────────┼─────────────────────────────────────────────┤
│   消费            │  thenAccept / thenRun                       │
├───────────────────┼─────────────────────────────────────────────┤
│   组合            │  thenCombine / allOf / anyOf                │
├───────────────────┼─────────────────────────────────────────────┤
│   异常            │  exceptionally / handle / whenComplete      │
└───────────────────┴─────────────────────────────────────────────┘
```

---

**并发编程总结思维导图**：

```
                        并发与多线程
                             │
        ┌────────────────────┼────────────────────┐
        │                    │                    │
    线程基础              锁机制               线程池
        │                    │                    │
   ┌────┴────┐         ┌────┴────┐          ┌────┴────┐
   │         │         │         │          │         │
  状态    通信方式    synchronized  JUC锁    参数配置   执行流程
  生命周期 wait/notify  锁升级    AQS原理   拒绝策略   动态调整
  中断机制 阻塞队列    死锁避免  原子类    大小设置   ForkJoin
```
