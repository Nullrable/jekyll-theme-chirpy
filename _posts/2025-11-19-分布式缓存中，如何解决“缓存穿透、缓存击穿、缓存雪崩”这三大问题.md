---
title: 分布式缓存中，如何解决“缓存穿透、缓存击穿、缓存雪崩”这三大问题
author: nhsoft.lsd
date: 2025-11-19
categories: [Java]
pin: false
---

# 缓存穿透（查询不存在的数据，缓存和DB都不命中，导致DB压力过大）：
- 解决方案：
  - 空值缓存：查询到空结果时，缓存空值（如“null”），设置较短过期时间（如5分钟）；
  - 布隆过滤器：将所有存在的key存入布隆过滤器，查询前先校验key是否存在，不存在直接返回；
- 案例：电商项目中，有黑客恶意查询不存在的商品ID（如1000000），未处理前DB每秒接收1万次查询，引入布隆过滤器后，无效查询被拦截在缓存层，DB压力降低90%；

# 缓存击穿（热点key过期瞬间，大量请求直达DB）：

- 解决方案：
  - 互斥锁：多个请求同时查询过期key时，只有一个请求能获取锁去查DB，其他请求等待；
  - 热点key永不过期：核心热点key（如秒杀商品ID）不设置过期时间，通过后台定时任务更新缓存；
- 案例：秒杀活动中，商品ID为123的商品是热点key，设置永不过期，每10秒通过定时任务从DB同步库存到缓存，避免了过期瞬间的DB冲击；

# 缓存雪崩（大量key同时过期，或Redis集群故障，导致请求全量直达DB）：
- 解决方案：
  - 过期时间随机化：给key设置过期时间时加随机值（如基础过期时间30分钟+5-10分钟随机值），避免同时过期；
  - Redis集群容错：部署主从+哨兵架构，主节点故障时自动切换到从节点；
  - 服务降级：Redis故障时，通过Hystrix降级，返回缓存的旧数据或默认值；
- 案例：物流系统中，因运维操作失误导致Redis主节点故障，未处理前DB瞬间压力飙升至平时的10倍，引入哨兵切换和服务降级后，故障期间系统仍能正常响应，仅部分非核心接口返回旧数据；
