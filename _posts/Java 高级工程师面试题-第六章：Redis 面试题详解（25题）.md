# 第六章：Redis 面试题详解（25题）

## 6.1 数据结构（6题）

### 156. Redis的数据类型和应用场景？

```
┌─────────────────────────────────────────────────────────────────────┐
│                    Redis 五大基本数据类型                             │
├──────────┬──────────────────┬────────────────────────────────────────┤
│  类型    │     特点          │              应用场景                   │
├──────────┼──────────────────┼────────────────────────────────────────┤
│ String   │ 二进制安全        │ 缓存、计数器、分布式锁、Session         │
│          │ 最大512MB        │                                        │
├──────────┼──────────────────┼────────────────────────────────────────┤
│ Hash     │ 键值对集合        │ 用户信息、商品详情、购物车              │
│          │ 适合存储对象      │                                        │
├──────────┼──────────────────┼────────────────────────────────────────┤
│ List     │ 双向链表          │ 消息队列、文章列表、排行榜              │
│          │ 有序可重复        │                                        │
├──────────┼──────────────────┼────────────────────────────────────────┤
│ Set      │ 无序集合          │ 标签、共同好友、抽奖、去重              │
│          │ 自动去重          │                                        │
├──────────┼──────────────────┼────────────────────────────────────────┤
│ ZSet     │ 有序集合          │ 排行榜、延迟队列、滑动窗口              │
│          │ 按分数排序        │                                        │
└──────────┴──────────────────┴────────────────────────────────────────┘

┌─────────────────────────────────────────────────────────────────────┐
│                    Redis 特殊数据类型                                │
├──────────┬──────────────────┬────────────────────────────────────────┤
│ Bitmap   │ 位图操作          │ 签到统计、在线状态、布隆过滤器          │
├──────────┼──────────────────┼────────────────────────────────────────┤
│HyperLogLog│ 基数统计         │ UV统计、独立IP数                        │
├──────────┼──────────────────┼────────────────────────────────────────┤
│ GEO      │ 地理位置          │ 附近的人、距离计算                      │
├──────────┼──────────────────┼────────────────────────────────────────┤
│ Stream   │ 消息流            │ 消息队列（支持消费者组）                │
└──────────┴──────────────────┴────────────────────────────────────────┘
```

---

### 157. Redis的底层数据结构有哪些？

```
┌─────────────────────────────────────────────────────────────────────┐
│                  Redis 底层数据结构（7种）                           │
├─────────────────────────────────────────────────────────────────────┤
│                                                                     │
│  ┌─────────────┐  ┌─────────────┐  ┌─────────────┐                 │
│  │    SDS      │  │   IntSet    │  │  ZipList    │                 │
│  │ 简单动态字符串│  │   整数集合   │  │   压缩列表   │                 │
│  └─────────────┘  └─────────────┘  └─────────────┘                 │
│                                                                     │
│  ┌─────────────┐  ┌─────────────┐  ┌─────────────┐                 │
│  │  LinkedList │  │   HashTable │  │  SkipList   │                 │
│  │   双向链表   │  │    哈希表    │  │    跳表     │                 │
│  └─────────────┘  └─────────────┘  └─────────────┘                 │
│                                                                     │
│  ┌─────────────┐  ┌─────────────┐                                  │
│  │  QuickList  │  │  ListPack   │  (Redis 7.0新增)                 │
│  │   快速列表   │  │   紧凑列表   │                                  │
│  └─────────────┘  └─────────────┘                                  │
└─────────────────────────────────────────────────────────────────────┘

┌─────────────────────────────────────────────────────────────────────┐
│                 数据类型 与 底层结构 对应关系                         │
├──────────┬──────────────────────────────────────────────────────────┤
│  String  │  SDS                                                     │
├──────────┼──────────────────────────────────────────────────────────┤
│  List    │  QuickList（ZipList + LinkedList）                       │
├──────────┼──────────────────────────────────────────────────────────┤
│  Hash    │  ZipList（小） / HashTable（大）                          │
├──────────┼──────────────────────────────────────────────────────────┤
│  Set     │  IntSet（整数且少） / HashTable                          │
├──────────┼──────────────────────────────────────────────────────────┤
│  ZSet    │  ZipList（小） / SkipList + HashTable（大）               │
└──────────┴──────────────────────────────────────────────────────────┘
```

---

### 158. String的底层实现是什么？

```
┌─────────────────────────────────────────────────────────────────────┐
│                      SDS（Simple Dynamic String）                    │
├─────────────────────────────────────────────────────────────────────┤
│                                                                     │
│   C语言字符串:  ['R']['e']['d']['i']['s']['\0']                      │
│                                                                     │
│   SDS结构:                                                          │
│   ┌────────┬────────┬────────┬─────────────────────────┐           │
│   │  len   │ alloc  │ flags  │        buf[]            │           │
│   │   5    │   10   │  类型   │ R | e | d | i | s | \0 │           │
│   └────────┴────────┴────────┴─────────────────────────┘           │
│   │已使用   │已分配   │SDS类型  │       实际数据           │           │
│                                                                     │
└─────────────────────────────────────────────────────────────────────┘
```

**SDS相比C字符串的优势：**

| 特性 | C字符串 | SDS |
|------|---------|-----|
| 获取长度 | O(n)遍历 | O(1)直接读len |
| 缓冲区溢出 | 可能溢出 | 自动扩容检查 |
| 内存分配 | 每次修改都分配 | 预分配+惰性释放 |
| 二进制安全 | 不安全(\0截断) | 安全（按len读取）|
| 兼容C函数 | 是 | 是（buf以\0结尾）|

**SDS空间预分配策略：**
```
修改后长度 < 1MB：分配 2 × len + 1 字节
修改后长度 ≥ 1MB：分配 len + 1MB + 1 字节
```

---

### 159. ZSet的底层实现？跳表原理？

```
┌─────────────────────────────────────────────────────────────────────┐
│                     ZSet 底层实现                                    │
├─────────────────────────────────────────────────────────────────────┤
│                                                                     │
│  元素数量 < 128 且 每个元素 < 64字节                                  │
│           │                                                         │
│           ▼                                                         │
│      ┌─────────┐                                                    │
│      │ ZipList │  紧凑存储，省内存                                   │
│      └─────────┘                                                    │
│                                                                     │
│  否则                                                                │
│           │                                                         │
│           ▼                                                         │
│  ┌──────────────────────────────────────────┐                       │
│  │     SkipList + HashTable                  │                      │
│  │                                           │                      │
│  │  SkipList：按分数排序，支持范围查询         │                      │
│  │  HashTable：O(1)查找元素分数               │                      │
│  └──────────────────────────────────────────┘                       │
└─────────────────────────────────────────────────────────────────────┘
```

**跳表结构示意：**
```
Level 4:  head ────────────────────────────────────────> 90 ───> NULL

Level 3:  head ──────────────> 30 ─────────────────────> 90 ───> NULL

Level 2:  head ────> 10 ─────> 30 ──────────> 60 ─────> 90 ───> NULL

Level 1:  head ────> 10 ─> 20 > 30 ─> 40 ─> 50 > 60 ─> 70 > 90 ───> NULL

查找 60 的过程:
1. Level 4: head → 90 (90>60，下降)
2. Level 3: head → 30 → 90 (90>60，下降)
3. Level 2: head → 30 → 60 ✓ 找到!

时间复杂度: O(log n)
```

**跳表核心特点：**
```
┌─────────────────────────────────────────────────────────────────────┐
│                        跳表 vs 平衡树                                │
├──────────────────┬─────────────────┬────────────────────────────────┤
│      特性        │     跳表         │          平衡树                │
├──────────────────┼─────────────────┼────────────────────────────────┤
│  实现复杂度       │     简单         │          复杂                  │
│  范围查询        │  天然支持         │     需要中序遍历               │
│  插入删除        │  局部调整         │   可能需要旋转                 │
│  内存占用        │  略多（指针）      │         较少                  │
│  并发友好        │     更好          │        较差                   │
└──────────────────┴─────────────────┴────────────────────────────────┘

Redis选择跳表的原因：
1. 实现简单，容易调试
2. 范围查询效率高（ZRANGE等命令）
3. 调整难度小，插入只需局部修改
```

---

### 160. Hash的渐进式rehash？

```
┌─────────────────────────────────────────────────────────────────────┐
│                      Hash 字典结构                                   │
├─────────────────────────────────────────────────────────────────────┤
│                                                                     │
│  typedef struct dict {                                              │
│      dictht ht[2];      // 两个哈希表，用于渐进式rehash              │
│      long rehashidx;    // rehash进度，-1表示没有进行                 │
│      ...                                                            │
│  }                                                                  │
│                                                                     │
│  ┌──────────────────────────────────────────────────────────────┐  │
│  │                     渐进式 Rehash 过程                         │  │
│  └──────────────────────────────────────────────────────────────┘  │
│                                                                     │
│  初始状态:                                                          │
│  ┌─────────┐                    ┌─────────┐                        │
│  │  ht[0]  │  有数据             │  ht[1]  │  空                    │
│  │ size=4  │                    │ size=0  │                        │
│  └─────────┘                    └─────────┘                        │
│                                                                     │
│  开始rehash (rehashidx=0):                                          │
│  ┌─────────┐                    ┌─────────┐                        │
│  │  ht[0]  │ ──────迁移──────>  │  ht[1]  │                        │
│  │ size=4  │   每次操作迁移1个   │ size=8  │  扩容2倍               │
│  └─────────┘                    └─────────┘                        │
│                                                                     │
│  完成后:                                                            │
│  ┌─────────┐                    ┌─────────┐                        │
│  │  ht[0]  │  ← 指向原ht[1]     │  ht[1]  │  空                    │
│  │ size=8  │                    │ size=0  │                        │
│  └─────────┘                    └─────────┘                        │
│                                                                     │
└─────────────────────────────────────────────────────────────────────┘
```

**渐进式Rehash核心要点：**

| 操作 | Rehash期间行为 |
|------|---------------|
| 查找 | 先查ht[0]，没有再查ht[1] |
| 插入 | 直接插入ht[1] |
| 删除 | 两个表都要找 |
| 迁移 | 每次CRUD操作顺带迁移1个桶 |

**触发条件：**
- **扩容**：负载因子 ≥ 1（无BGSAVE）或 ≥ 5（有BGSAVE）
- **缩容**：负载因子 < 0.1

---

### 161. Bitmap和HyperLogLog的使用场景？

```
┌─────────────────────────────────────────────────────────────────────┐
│                         Bitmap（位图）                               │
├─────────────────────────────────────────────────────────────────────┤
│                                                                     │
│  底层: String类型，按位操作                                          │
│                                                                     │
│  ┌─────────────────────────────────────────────────────────────┐   │
│  │ 0 │ 1 │ 1 │ 0 │ 1 │ 0 │ 0 │ 1 │ 1 │ 0 │ 1 │ ...           │   │
│  └─────────────────────────────────────────────────────────────┘   │
│    0   1   2   3   4   5   6   7   8   9  10                        │
│                                                                     │
│  应用场景:                                                          │
│  ├── 用户签到: SETBIT sign:202401:uid 15 1  (16号签到)             │
│  ├── 在线状态: SETBIT online uid 1                                 │
│  ├── 统计活跃: BITCOUNT sign:202401:uid                            │
│  └── 布隆过滤器: 多个hash函数映射到位图                              │
│                                                                     │
│  优势: 1亿用户只需 12MB 内存                                         │
└─────────────────────────────────────────────────────────────────────┘

┌─────────────────────────────────────────────────────────────────────┐
│                      HyperLogLog（基数统计）                         │
├─────────────────────────────────────────────────────────────────────┤
│                                                                     │
│  特点:                                                              │
│  ├── 固定占用 12KB 内存                                             │
│  ├── 标准误差 0.81%                                                 │
│  └── 只能统计数量，不能获取具体元素                                   │
│                                                                     │
│  应用场景:                                                          │
│  ├── UV统计: PFADD page:uv:20240115 user1 user2                    │
│  ├── 独立IP数: PFCOUNT page:uv:20240115                            │
│  └── 合并统计: PFMERGE total day1 day2 day3                         │
│                                                                     │
│  对比:                                                              │
│  ┌─────────────┬──────────────┬──────────────┐                     │
│  │    方案     │   1亿UV内存   │    精确度    │                     │
│  ├─────────────┼──────────────┼──────────────┤                     │
│  │    Set      │    几个GB     │    100%     │                     │
│  │ HyperLogLog │     12KB     │   99.19%    │                     │
│  └─────────────┴──────────────┴──────────────┘                     │
└─────────────────────────────────────────────────────────────────────┘
```

---

## 6.2 持久化（5题）

### 162. RDB和AOF的区别？

```
┌─────────────────────────────────────────────────────────────────────┐
│                     RDB vs AOF 对比                                  │
├─────────────────────────────────────────────────────────────────────┤
│                                                                     │
│  RDB (Redis Database):                                              │
│  ┌─────────────────────────────────────────────────────────────┐   │
│  │                                                              │   │
│  │   Redis数据  ──BGSAVE──>  内存快照  ──>  dump.rdb文件        │   │
│  │                  │                                           │   │
│  │                fork子进程，不阻塞主进程                        │   │
│  └─────────────────────────────────────────────────────────────┘   │
│                                                                     │
│  AOF (Append Only File):                                            │
│  ┌─────────────────────────────────────────────────────────────┐   │
│  │                                                              │   │
│  │   写命令 ──> AOF缓冲区 ──> fsync策略 ──> appendonly.aof      │   │
│  │                                                              │   │
│  │   SET key value  →  *3\r\n$3\r\nSET\r\n$3\r\nkey...         │   │
│  └─────────────────────────────────────────────────────────────┘   │
│                                                                     │
└─────────────────────────────────────────────────────────────────────┘
```

| 特性 | RDB | AOF |
|------|-----|-----|
| **持久化方式** | 定时快照 | 记录每条写命令 |
| **文件大小** | 压缩二进制，较小 | 文本格式，较大 |
| **恢复速度** | 快（直接加载） | 慢（重放命令） |
| **数据安全** | 可能丢失分钟级数据 | 最多丢失1秒数据 |
| **fork影响** | 快照时fork | 重写时fork |
| **适用场景** | 备份、灾难恢复 | 数据安全性要求高 |

**AOF刷盘策略：**
```
appendfsync always    - 每条命令都刷盘，最安全，性能最差
appendfsync everysec  - 每秒刷盘，推荐，最多丢1秒数据
appendfsync no        - 由OS决定，性能最好，数据安全性最差
```

---

### 163. AOF重写的原理？

```
┌─────────────────────────────────────────────────────────────────────┐
│                      AOF 重写流程                                    │
├─────────────────────────────────────────────────────────────────────┤
│                                                                     │
│  问题：AOF文件会越来越大                                             │
│  例如: INCR counter 执行100次 → 100条命令 → 重写后: SET counter 100  │
│                                                                     │
│  ┌─────────────────────────────────────────────────────────────┐   │
│  │                      重写过程                                │   │
│  │                                                              │   │
│  │  主进程                            子进程                     │   │
│  │    │                                 │                       │   │
│  │    │──── fork ──────────────────────>│                       │   │
│  │    │                                 │                       │   │
│  │    │  继续处理写命令                   │  遍历内存生成新AOF     │   │
│  │    │     │                           │         │             │   │
│  │    │     ▼                           │         ▼             │   │
│  │    │ ┌────────────┐                  │   ┌────────────┐      │   │
│  │    │ │ AOF重写缓冲 │                  │   │ 新AOF文件   │      │   │
│  │    │ └────────────┘                  │   └────────────┘      │   │
│  │    │                                 │         │             │   │
│  │    │                                 │<──完成信号──┘          │   │
│  │    │                                 │                       │   │
│  │    │  将重写缓冲追加到新AOF ─────────────────────>│            │   │
│  │    │                                              │            │   │
│  │    │  原子替换旧AOF文件 <─────────────────────────┘            │   │
│  │                                                              │   │
│  └─────────────────────────────────────────────────────────────┘   │
│                                                                     │
└─────────────────────────────────────────────────────────────────────┘
```

**重写触发条件：**
```
auto-aof-rewrite-percentage 100   # 比上次重写后增长100%
auto-aof-rewrite-min-size 64mb    # 文件最小64MB才触发
```

---

### 164. 混合持久化是什么？

```
┌─────────────────────────────────────────────────────────────────────┐
│                      混合持久化（Redis 4.0+）                         │
├─────────────────────────────────────────────────────────────────────┤
│                                                                     │
│  配置: aof-use-rdb-preamble yes                                     │
│                                                                     │
│  ┌───────────────────────────────────────────────────────────────┐ │
│  │                    混合 AOF 文件结构                            │ │
│  │                                                                │ │
│  │  ┌─────────────────────────────────────────────────────────┐  │ │
│  │  │              RDB 格式（二进制快照）                        │  │ │
│  │  │           重写时刻的全量数据                               │  │ │
│  │  ├─────────────────────────────────────────────────────────┤  │ │
│  │  │              AOF 格式（增量命令）                          │  │ │
│  │  │         重写后的增量写命令                                 │  │ │
│  │  └─────────────────────────────────────────────────────────┘  │ │
│  │                                                                │ │
│  └───────────────────────────────────────────────────────────────┘ │
│                                                                     │
│  优势:                                                              │
│  ├── 快速恢复: RDB部分直接加载                                      │
│  ├── 数据安全: AOF部分保证增量不丢失                                 │
│  └── 文件较小: RDB二进制压缩 + 少量增量命令                          │
│                                                                     │
└─────────────────────────────────────────────────────────────────────┘
```

---

### 165. 如何选择持久化方式？

```
┌─────────────────────────────────────────────────────────────────────┐
│                      持久化选择决策树                                 │
├─────────────────────────────────────────────────────────────────────┤
│                                                                     │
│                    数据重要吗？                                      │
│                        │                                            │
│              ┌─────────┴─────────┐                                  │
│              ▼                   ▼                                  │
│            不重要              重要                                  │
│              │                   │                                  │
│              ▼                   ▼                                  │
│         纯缓存场景        是否允许丢数据？                            │
│              │                   │                                  │
│              ▼         ┌────────┴────────┐                         │
│      关闭持久化         ▼                 ▼                         │
│      或只开RDB      允许丢分钟级      不允许丢失                      │
│                         │                 │                         │
│                         ▼                 ▼                         │
│                      只开RDB        AOF everysec                    │
│                                     或混合持久化                     │
│                                                                     │
└─────────────────────────────────────────────────────────────────────┘

┌─────────────────────────────────────────────────────────────────────┐
│                      实际生产建议                                    │
├─────────────────────────────────────────────────────────────────────┤
│                                                                     │
│  推荐：混合持久化（Redis 4.0+）                                      │
│                                                                     │
│  配置示例:                                                          │
│  ┌──────────────────────────────────────────────────────────────┐  │
│  │ appendonly yes                    # 开启AOF                   │  │
│  │ appendfsync everysec              # 每秒刷盘                   │  │
│  │ aof-use-rdb-preamble yes          # 开启混合持久化             │  │
│  │ save 900 1                        # 同时开启RDB用于备份        │  │
│  │ save 300 10                                                   │  │
│  │ save 60 10000                                                 │  │
│  └──────────────────────────────────────────────────────────────┘  │
│                                                                     │
└─────────────────────────────────────────────────────────────────────┘
```

---

### 166. Redis数据恢复流程？

```
┌─────────────────────────────────────────────────────────────────────┐
│                      Redis 启动数据恢复流程                          │
├─────────────────────────────────────────────────────────────────────┤
│                                                                     │
│                        Redis启动                                    │
│                            │                                        │
│                            ▼                                        │
│                   是否开启了AOF？                                    │
│                            │                                        │
│              ┌─────────────┴─────────────┐                         │
│              ▼                           ▼                         │
│             是                          否                          │
│              │                           │                          │
│              ▼                           ▼                          │
│     检查AOF文件是否存在            检查RDB文件是否存在                │
│              │                           │                          │
│       ┌──────┴──────┐             ┌──────┴──────┐                  │
│       ▼             ▼             ▼             ▼                  │
│     存在          不存在         存在          不存在                │
│       │             │             │             │                  │
│       ▼             ▼             ▼             ▼                  │
│  加载AOF文件   空数据启动    加载RDB文件    空数据启动               │
│                                                                     │
│  ※ AOF优先级高于RDB（数据更完整）                                    │
│                                                                     │
└─────────────────────────────────────────────────────────────────────┘

┌─────────────────────────────────────────────────────────────────────┐
│                    AOF文件损坏修复                                   │
├─────────────────────────────────────────────────────────────────────┤
│                                                                     │
│  # 检查AOF文件                                                      │
│  redis-check-aof --fix appendonly.aof                              │
│                                                                     │
│  # 检查RDB文件                                                      │
│  redis-check-rdb dump.rdb                                          │
│                                                                     │
└─────────────────────────────────────────────────────────────────────┘
```

---

## 6.3 高可用（6题）

### 167. Redis主从复制原理？

```
┌─────────────────────────────────────────────────────────────────────┐
│                      主从复制架构                                    │
├─────────────────────────────────────────────────────────────────────┤
│                                                                     │
│                    ┌─────────────┐                                  │
│                    │   Master    │                                  │
│                    │  (读写)     │                                  │
│                    └──────┬──────┘                                  │
│                           │                                         │
│              ┌────────────┼────────────┐                           │
│              ▼            ▼            ▼                           │
│       ┌──────────┐ ┌──────────┐ ┌──────────┐                       │
│       │  Slave1  │ │  Slave2  │ │  Slave3  │                       │
│       │  (只读)  │ │  (只读)  │ │  (只读)  │                       │
│       └──────────┘ └──────────┘ └──────────┘                       │
│                                                                     │
└─────────────────────────────────────────────────────────────────────┘

┌─────────────────────────────────────────────────────────────────────┐
│                    全量复制过程（首次/断线过久）                       │
├─────────────────────────────────────────────────────────────────────┤
│                                                                     │
│  Slave                                      Master                  │
│    │                                           │                    │
│    │───── PSYNC ? -1 (首次) ─────────────────>│                    │
│    │                                           │                    │
│    │<───── +FULLRESYNC runid offset ──────────│                    │
│    │                                           │                    │
│    │                        ┌─────────────────>│ 执行BGSAVE         │
│    │                        │                  │ 生成RDB            │
│    │                        │                  │                    │
│    │<───── 发送RDB文件 ──────┘                 │                    │
│    │                                           │                    │
│    │  加载RDB                                  │ 缓冲区记录新命令    │
│    │                                           │                    │
│    │<───── 发送缓冲区命令 ────────────────────│                    │
│    │                                           │                    │
│    │  执行增量命令                              │                    │
│                                                                     │
└─────────────────────────────────────────────────────────────────────┘

┌─────────────────────────────────────────────────────────────────────┐
│                    增量复制（断线重连）                               │
├─────────────────────────────────────────────────────────────────────┤
│                                                                     │
│  Slave                                      Master                  │
│    │                                           │                    │
│    │───── PSYNC runid offset ───────────────>│                     │
│    │                                           │                    │
│    │                               检查offset是否在                 │
│    │                               repl_backlog中                   │
│    │                                           │                    │
│    │<───── +CONTINUE ──────────────────────────│                    │
│    │                                           │                    │
│    │<───── 发送缺失的命令 ─────────────────────│                    │
│    │                                           │                    │
│                                                                     │
│  repl_backlog_size: 默认1MB，建议调大                                │
│                                                                     │
└─────────────────────────────────────────────────────────────────────┘
```

---

### 168. 哨兵模式的原理？

```
┌─────────────────────────────────────────────────────────────────────┐
│                      Sentinel 哨兵架构                               │
├─────────────────────────────────────────────────────────────────────┤
│                                                                     │
│     ┌───────────┐     ┌───────────┐     ┌───────────┐              │
│     │ Sentinel1 │     │ Sentinel2 │     │ Sentinel3 │              │
│     └─────┬─────┘     └─────┬─────┘     └─────┬─────┘              │
│           │                 │                 │                     │
│           │    互相通信（发布订阅）            │                     │
│           └─────────────────┼─────────────────┘                     │
│                             │                                       │
│                             ▼                                       │
│         ┌───────────────────┴───────────────────┐                  │
│         │                                        │                  │
│         ▼                                        ▼                  │
│  ┌─────────────┐                         ┌──────────────┐          │
│  │   Master    │ ◄────── 复制 ──────────│    Slave     │          │
│  └─────────────┘                         └──────────────┘          │
│                                                                     │
└─────────────────────────────────────────────────────────────────────┘

┌─────────────────────────────────────────────────────────────────────┐
│                      故障检测与转移流程                               │
├─────────────────────────────────────────────────────────────────────┤
│                                                                     │
│  1. 主观下线 (SDOWN)                                                │
│     ├── 哨兵每秒PING主节点                                          │
│     └── 超过down-after-milliseconds无响应，标记SDOWN                │
│                                                                     │
│  2. 客观下线 (ODOWN)                                                │
│     ├── 询问其他哨兵: SENTINEL is-master-down-by-addr                │
│     └── 超过quorum个哨兵认为SDOWN，标记ODOWN                         │
│                                                                     │
│  3. 选举Leader哨兵                                                  │
│     └── Raft算法选举，获得多数票的成为Leader                         │
│                                                                     │
│  4. 故障转移                                                        │
│     ├── 从Slave中选新Master（优先级>复制偏移量>runid）               │
│     ├── 向新Master发送 SLAVEOF NO ONE                               │
│     ├── 向其他Slave发送 SLAVEOF 新Master                            │
│     └── 更新原Master为Slave（恢复后）                                │
│                                                                     │
└─────────────────────────────────────────────────────────────────────┘
```

---

### 169. Redis Cluster的原理？

```
┌─────────────────────────────────────────────────────────────────────┐
│                   Redis Cluster 架构                                 │
├─────────────────────────────────────────────────────────────────────┤
│                                                                     │
│  ┌────────────────────────────────────────────────────────────────┐│
│  │                    16384 个槽位 (0-16383)                       ││
│  │  ┌─────────────┬─────────────┬─────────────┬────────────────┐  ││
│  │  │  0 - 5460   │ 5461-10922  │ 10923-16383 │                │  ││
│  │  │   Node A    │   Node B    │   Node C    │                │  ││
│  │  └─────────────┴─────────────┴─────────────┴────────────────┘  ││
│  └────────────────────────────────────────────────────────────────┘│
│                                                                     │
│                          Gossip协议                                 │
│                              │                                      │
│      ┌───────────────────────┼───────────────────────┐             │
│      ▼                       ▼                       ▼             │
│  ┌────────┐             ┌────────┐             ┌────────┐         │
│  │ Node A │◄───────────►│ Node B │◄───────────►│ Node C │         │
│  │ Master │             │ Master │             │ Master │         │
│  └───┬────┘             └───┬────┘             └───┬────┘         │
│      │                      │                      │               │
│      ▼                      ▼                      ▼               │
│  ┌────────┐             ┌────────┐             ┌────────┐         │
│  │Slave A │             │Slave B │             │Slave C │         │
│  └────────┘             └────────┘             └────────┘         │
│                                                                     │
└─────────────────────────────────────────────────────────────────────┘

┌─────────────────────────────────────────────────────────────────────┐
│                     请求路由过程                                     │
├─────────────────────────────────────────────────────────────────────┤
│                                                                     │
│  Client                     Node A                    Node C        │
│    │                          │                          │          │
│    │── GET user:1000 ────────>│                          │          │
│    │                          │                          │          │
│    │   计算槽位: CRC16(user:1000) % 16384 = 12539        │          │
│    │                          │                          │          │
│    │   12539 不在 Node A (0-5460)                        │          │
│    │                          │                          │          │
│    │<── MOVED 12539 Node C IP:PORT ──│                   │          │
│    │                                                     │          │
│    │───────────── GET user:1000 ─────────────────────────>│         │
│    │                                                     │          │
│    │<─────────────── "value" ─────────────────────────────│         │
│                                                                     │
└─────────────────────────────────────────────────────────────────────┘
```

**Cluster核心特点：**
- **去中心化**：无代理，节点间Gossip通信
- **数据分片**：16384个槽位，CRC16哈希
- **高可用**：每个Master配Slave，自动故障转移
- **线性扩展**：增加节点即可扩容

---

### 170. 槽位和节点的关系？

```
┌─────────────────────────────────────────────────────────────────────┐
│                     槽位（Slot）与节点映射                            │
├─────────────────────────────────────────────────────────────────────┤
│                                                                     │
│  为什么是 16384 个槽？                                               │
│  ├── 心跳包大小: 16384/8 = 2KB (bitmap)                             │
│  ├── 1000个节点以内够用                                             │
│  └── 65536个槽需要8KB，太大                                         │
│                                                                     │
│  ┌─────────────────────────────────────────────────────────────┐   │
│  │                    槽位计算                                  │   │
│  │                                                              │   │
│  │    slot = CRC16(key) % 16384                                 │   │
│  │                                                              │   │
│  │    例: key = "user:1000"                                     │   │
│  │        CRC16("user:1000") = 48283                            │   │
│  │        slot = 48283 % 16384 = 15515                          │   │
│  │        → 路由到负责 15515 槽的节点                            │   │
│  │                                                              │   │
│  └─────────────────────────────────────────────────────────────┘   │
│                                                                     │
│  Hash Tag（强制同槽）:                                              │
│  ├── {user}:1000:profile                                          │
│  ├── {user}:1000:orders                                           │
│  └── 只对{}内的内容计算hash，保证在同一槽                            │
│                                                                     │
└─────────────────────────────────────────────────────────────────────┘

┌─────────────────────────────────────────────────────────────────────┐
│                    节点槽位分配示例                                   │
├─────────────────────────────────────────────────────────────────────┤
│                                                                     │
│  CLUSTER SLOTS 命令返回:                                            │
│                                                                     │
│  1) 0-5460     → 192.168.1.1:6379 (Master)                         │
│                  192.168.1.4:6379 (Slave)                          │
│                                                                     │
│  2) 5461-10922 → 192.168.1.2:6379 (Master)                         │
│                  192.168.1.5:6379 (Slave)                          │
│                                                                     │
│  3) 10923-16383 → 192.168.1.3:6379 (Master)                        │
│                   192.168.1.6:6379 (Slave)                         │
│                                                                     │
└─────────────────────────────────────────────────────────────────────┘
```

---

### 171. 集群如何故障转移？

```
┌─────────────────────────────────────────────────────────────────────┐
│                  Cluster 故障转移流程                                │
├─────────────────────────────────────────────────────────────────────┤
│                                                                     │
│  1. 故障发现                                                        │
│  ┌─────────────────────────────────────────────────────────────┐   │
│  │                                                              │   │
│  │   Node A ──PING──> Node B (无响应)                           │   │
│  │      │                                                       │   │
│  │      └─ 超过cluster-node-timeout，标记PFAIL (疑似下线)        │   │
│  │                                                              │   │
│  │   Node A 通过Gossip告知其他节点                               │   │
│  │      │                                                       │   │
│  │      └─ 超过半数Master标记PFAIL → 标记FAIL (确认下线)         │   │
│  │                                                              │   │
│  └─────────────────────────────────────────────────────────────┘   │
│                                                                     │
│  2. 从节点选举                                                      │
│  ┌─────────────────────────────────────────────────────────────┐   │
│  │                                                              │   │
│  │   Slave检测到Master FAIL                                     │   │
│  │      │                                                       │   │
│  │      ├─ 延迟时间 = 500ms + random(0,500) + rank*1000ms       │   │
│  │      │           (rank按复制偏移量排序，偏移量大的rank小)      │   │
│  │      │                                                       │   │
│  │      └─ 广播FAILOVER_AUTH_REQUEST请求投票                     │   │
│  │                                                              │   │
│  │   其他Master投票                                              │   │
│  │      │                                                       │   │
│  │      └─ 获得超过半数票 → 成为新Master                         │   │
│  │                                                              │   │
│  └─────────────────────────────────────────────────────────────┘   │
│                                                                     │
│  3. 故障转移执行                                                    │
│  ┌─────────────────────────────────────────────────────────────┐   │
│  │                                                              │   │
│  │   新Master                                                   │   │
│  │      │                                                       │   │
│  │      ├─ 执行 SLAVEOF NO ONE                                  │   │
│  │      ├─ 接管原Master的槽位                                    │   │
│  │      ├─ 广播PONG通知所有节点配置变更                          │   │
│  │      └─ 其他Slave指向新Master                                 │   │
│  │                                                              │   │
│  └─────────────────────────────────────────────────────────────┘   │
│                                                                     │
└─────────────────────────────────────────────────────────────────────┘
```

---

### 172. Redis Cluster的扩缩容？

```
┌─────────────────────────────────────────────────────────────────────┐
│                        扩容流程                                      │
├─────────────────────────────────────────────────────────────────────┤
│                                                                     │
│  当前: 3主3从, 每个Master ~5461个槽                                  │
│  目标: 4主4从                                                       │
│                                                                     │
│  步骤1: 添加新节点                                                  │
│  ┌──────────────────────────────────────────────────────────────┐  │
│  │ redis-cli --cluster add-node 新IP:6379 集群IP:6379           │  │
│  │ redis-cli --cluster add-node 新SlaveIP:6379 新MasterIP:6379  │  │
│  │                              --cluster-slave                  │  │
│  └──────────────────────────────────────────────────────────────┘  │
│                                                                     │
│  步骤2: 迁移槽位（reshard）                                         │
│  ┌──────────────────────────────────────────────────────────────┐  │
│  │ redis-cli --cluster reshard 集群IP:6379                      │  │
│  │                                                               │  │
│  │ 迁移过程:                                                     │  │
│  │ ┌─────────┐           ┌─────────┐                            │  │
│  │ │ Node A  │   slot    │ Node D  │                            │  │
│  │ │ 0-5460  │──迁移───> │  (新)   │                            │  │
│  │ └─────────┘           └─────────┘                            │  │
│  │                                                               │  │
│  │ 1. 目标节点: CLUSTER SETSLOT <slot> IMPORTING <source-id>    │  │
│  │ 2. 源节点:   CLUSTER SETSLOT <slot> MIGRATING <target-id>    │  │
│  │ 3. 迁移key: MIGRATE 目标IP 目标端口 key 0 timeout            │  │
│  │ 4. 通知所有: CLUSTER SETSLOT <slot> NODE <target-id>         │  │
│  │                                                               │  │
│  └──────────────────────────────────────────────────────────────┘  │
│                                                                     │
└─────────────────────────────────────────────────────────────────────┘

┌─────────────────────────────────────────────────────────────────────┐
│                        缩容流程                                      │
├─────────────────────────────────────────────────────────────────────┤
│                                                                     │
│  步骤1: 迁移待删除节点的槽位到其他节点                                │
│                                                                     │
│  步骤2: 删除Slave节点                                               │
│  ┌──────────────────────────────────────────────────────────────┐  │
│  │ redis-cli --cluster del-node 集群IP:6379 Slave节点ID         │  │
│  └──────────────────────────────────────────────────────────────┘  │
│                                                                     │
│  步骤3: 删除Master节点（槽位已迁空）                                 │
│  ┌──────────────────────────────────────────────────────────────┐  │
│  │ redis-cli --cluster del-node 集群IP:6379 Master节点ID        │  │
│  └──────────────────────────────────────────────────────────────┘  │
│                                                                     │
└─────────────────────────────────────────────────────────────────────┘
```

---

## 6.4 实战问题（8题）

### 173. 缓存穿透如何解决？

```
┌─────────────────────────────────────────────────────────────────────┐
│                      缓存穿透问题                                    │
├─────────────────────────────────────────────────────────────────────┤
│                                                                     │
│  定义: 查询不存在的数据，缓存无法命中，请求直达数据库                  │
│                                                                     │
│  ┌─────────────────────────────────────────────────────────────┐   │
│  │                                                              │   │
│  │   请求 id=-1 ──> Redis(无) ──> MySQL(无) ──> 返回空          │   │
│  │                                                              │   │
│  │   恶意攻击大量不存在的id，数据库压力暴增                       │   │
│  │                                                              │   │
│  └─────────────────────────────────────────────────────────────┘   │
│                                                                     │
└─────────────────────────────────────────────────────────────────────┘

┌─────────────────────────────────────────────────────────────────────┐
│                        解决方案                                      │
├─────────────────────────────────────────────────────────────────────┤
│                                                                     │
│  方案1: 缓存空值                                                    │
│  ┌──────────────────────────────────────────────────────────────┐  │
│  │                                                               │  │
│  │  DB查询为空 → SET key "" EX 60  (设置短过期时间)              │  │
│  │                                                               │  │
│  │  优点: 简单                                                   │  │
│  │  缺点: 占用内存，可能大量空值缓存                              │  │
│  │                                                               │  │
│  └──────────────────────────────────────────────────────────────┘  │
│                                                                     │
│  方案2: 布隆过滤器（推荐）                                          │
│  ┌──────────────────────────────────────────────────────────────┐  │
│  │                                                               │  │
│  │   请求 ──> 布隆过滤器 ──> 不存在? 直接返回                     │  │
│  │               │                                               │  │
│  │               └─ 可能存在 ──> Redis ──> DB                    │  │
│  │                                                               │  │
│  │   特点: 存在误判（说存在可能不存在），无漏判（说不存在肯定没有）  │  │
│  │                                                               │  │
│  └──────────────────────────────────────────────────────────────┘  │
│                                                                     │
│  方案3: 参数校验                                                    │
│  ┌──────────────────────────────────────────────────────────────┐  │
│  │                                                               │  │
│  │  前置校验: id <= 0 直接拒绝                                   │  │
│  │  格式校验: 邮箱、手机号等格式验证                              │  │
│  │                                                               │  │
│  └──────────────────────────────────────────────────────────────┘  │
│                                                                     │
└─────────────────────────────────────────────────────────────────────┘
```

---

### 174. 缓存击穿如何解决？

```
┌─────────────────────────────────────────────────────────────────────┐
│                      缓存击穿问题                                    │
├─────────────────────────────────────────────────────────────────────┤
│                                                                     │
│  定义: 热点Key过期瞬间，大量并发请求直接打到数据库                    │
│                                                                     │
│  ┌─────────────────────────────────────────────────────────────┐   │
│  │                                                              │   │
│  │   热点Key "hot_product"                                      │   │
│  │        │                                                     │   │
│  │        ▼                                                     │   │
│  │     过期删除                                                  │   │
│  │        │                                                     │   │
│  │        ▼                                                     │   │
│  │   10000 QPS ──> Redis(Miss) ──> MySQL(压垮)                  │   │
│  │                                                              │   │
│  └─────────────────────────────────────────────────────────────┘   │
│                                                                     │
└─────────────────────────────────────────────────────────────────────┘

┌─────────────────────────────────────────────────────────────────────┐
│                        解决方案                                      │
├─────────────────────────────────────────────────────────────────────┤
│                                                                     │
│  方案1: 互斥锁                                                      │
│  ┌──────────────────────────────────────────────────────────────┐  │
│  │                                                               │  │
│  │   请求1: 获取锁 ──> 查DB ──> 写缓存 ──> 释放锁                 │  │
│  │   请求2: 获取锁失败 ──> 等待/重试 ──> 读缓存                   │  │
│  │   请求3: 获取锁失败 ──> 等待/重试 ──> 读缓存                   │  │
│  │                                                               │  │
│  │   // SETNX实现                                                │  │
│  │   SET lock_key 1 NX EX 10                                     │  │
│  │                                                               │  │
│  └──────────────────────────────────────────────────────────────┘  │
│                                                                     │
│  方案2: 逻辑过期（推荐热点数据）                                     │
│  ┌──────────────────────────────────────────────────────────────┐  │
│  │                                                               │  │
│  │   缓存结构: { "data": "xxx", "expireTime": 1705315200 }      │  │
│  │                                                               │  │
│  │   Redis Key 设置永不过期                                      │  │
│  │                                                               │  │
│  │   请求时检查 expireTime:                                      │  │
│  │   ├── 未过期 → 直接返回data                                   │  │
│  │   └── 已过期 → 返回旧data + 异步更新缓存                       │  │
│  │                                                               │  │
│  └──────────────────────────────────────────────────────────────┘  │
│                                                                     │
│  方案3: 热点数据永不过期                                            │
│  ┌──────────────────────────────────────────────────────────────┐  │
│  │                                                               │  │
│  │   针对热点数据不设TTL，由后台定时任务更新                       │  │
│  │                                                               │  │
│  └──────────────────────────────────────────────────────────────┘  │
│                                                                     │
└─────────────────────────────────────────────────────────────────────┘
```

---

### 175. 缓存雪崩如何解决？

```
┌─────────────────────────────────────────────────────────────────────┐
│                      缓存雪崩问题                                    │
├─────────────────────────────────────────────────────────────────────┤
│                                                                     │
│  定义: 大量缓存同时过期 或 Redis宕机，请求全部打到数据库              │
│                                                                     │
│  场景1: 大量Key同时过期                                             │
│  ┌─────────────────────────────────────────────────────────────┐   │
│  │   00:00:00 批量设置缓存，TTL=24h                              │   │
│  │       ▼                                                      │   │
│  │   次日00:00:00 全部过期 → 数据库雪崩                          │   │
│  └─────────────────────────────────────────────────────────────┘   │
│                                                                     │
│  场景2: Redis服务宕机                                               │
│  ┌─────────────────────────────────────────────────────────────┐   │
│  │   Redis挂了 → 所有请求打DB → DB挂了 → 整个系统雪崩            │   │
│  └─────────────────────────────────────────────────────────────┘   │
│                                                                     │
└─────────────────────────────────────────────────────────────────────┘

┌─────────────────────────────────────────────────────────────────────┐
│                        解决方案                                      │
├─────────────────────────────────────────────────────────────────────┤
│                                                                     │
│  针对大量Key同时过期:                                               │
│  ┌──────────────────────────────────────────────────────────────┐  │
│  │                                                               │  │
│  │  1. 随机过期时间                                              │  │
│  │     TTL = baseTime + random(0, 300)  // 加随机值打散          │  │
│  │                                                               │  │
│  │  2. 分批预热                                                  │  │
│  │     凌晨分批加载缓存，避免同时过期                              │  │
│  │                                                               │  │
│  └──────────────────────────────────────────────────────────────┘  │
│                                                                     │
│  针对Redis宕机:                                                     │
│  ┌──────────────────────────────────────────────────────────────┐  │
│  │                                                               │  │
│  │  1. 高可用架构                                                │  │
│  │     Redis Sentinel 或 Redis Cluster                          │  │
│  │                                                               │  │
│  │  2. 多级缓存                                                  │  │
│  │     本地缓存(Caffeine) → Redis → DB                          │  │
│  │                                                               │  │
│  │  3. 熔断降级                                                  │  │
│  │     Sentinel/Hystrix 限流熔断                                 │  │
│  │                                                               │  │
│  │  4. 限流                                                      │  │
│  │     控制DB访问速率，保护数据库                                 │  │
│  │                                                               │  │
│  └──────────────────────────────────────────────────────────────┘  │
│                                                                     │
└─────────────────────────────────────────────────────────────────────┘
```

**三种问题对比：**

| 问题 | 原因 | 影响范围 | 核心解决 |
|------|------|---------|---------|
| 穿透 | 查询不存在数据 | 单个Key | 布隆过滤器 |
| 击穿 | 热点Key过期 | 单个热点Key | 互斥锁/逻辑过期 |
| 雪崩 | 大量Key同时过期/宕机 | 大批Key | 随机TTL/高可用 |

---

### 176. 热Key问题如何解决？

```
┌─────────────────────────────────────────────────────────────────────┐
│                      热Key问题                                       │
├─────────────────────────────────────────────────────────────────────┤
│                                                                     │
│  定义: 某个Key访问频率远超其他Key，导致单节点压力过大                  │
│                                                                     │
│  场景: 明星官宣、秒杀商品、热点新闻                                   │
│                                                                     │
│  影响:                                                              │
│  ├── 单节点CPU/网络带宽打满                                         │
│  ├── 集群中数据倾斜                                                 │
│  └── 可能导致节点宕机                                               │
│                                                                     │
└─────────────────────────────────────────────────────────────────────┘

┌─────────────────────────────────────────────────────────────────────┐
│                        解决方案                                      │
├─────────────────────────────────────────────────────────────────────┤
│                                                                     │
│  1. 本地缓存                                                        │
│  ┌──────────────────────────────────────────────────────────────┐  │
│  │                                                               │  │
│  │   App Server                                                  │  │
│  │   ┌─────────────┐                                            │  │
│  │   │ Caffeine    │  命中 → 直接返回                            │  │
│  │   │ 本地缓存    │  未中 → 访问Redis                           │  │
│  │   └─────────────┘                                            │  │
│  │                                                               │  │
│  │   注意: 设置短TTL或订阅更新，避免一致性问题                     │  │
│  │                                                               │  │
│  └──────────────────────────────────────────────────────────────┘  │
│                                                                     │
│  2. Key分片（读写分离）                                             │
│  ┌──────────────────────────────────────────────────────────────┐  │
│  │                                                               │  │
│  │   原Key: hot_product                                          │  │
│  │                                                               │  │
│  │   拆分: hot_product_0, hot_product_1, ..., hot_product_N     │  │
│  │                                                               │  │
│  │   读取: hot_product_ + hash(请求特征) % N                     │  │
│  │                                                               │  │
│  │   更新: 同时更新所有分片                                       │  │
│  │                                                               │  │
│  └──────────────────────────────────────────────────────────────┘  │
│                                                                     │
│  3. 读写分离 + 多从节点                                             │
│  ┌──────────────────────────────────────────────────────────────┐  │
│  │                                                               │  │
│  │                ┌─────────┐                                   │  │
│  │      写 ─────> │ Master  │                                   │  │
│  │                └────┬────┘                                   │  │
│  │                     │                                        │  │
│  │           ┌─────────┼─────────┐                              │  │
│  │           ▼         ▼         ▼                              │  │
│  │       ┌───────┐ ┌───────┐ ┌───────┐                         │  │
│  │  读 ──│Slave1 │ │Slave2 │ │Slave3 │                         │  │
│  │       └───────┘ └───────┘ └───────┘                         │  │
│  │                                                               │  │
│  └──────────────────────────────────────────────────────────────┘  │
│                                                                     │
└─────────────────────────────────────────────────────────────────────┘
```

---

### 177. 大Key问题如何解决？

```
┌─────────────────────────────────────────────────────────────────────┐
│                       大Key问题                                      │
├─────────────────────────────────────────────────────────────────────┤
│                                                                     │
│  定义:                                                              │
│  ├── String类型 > 10KB                                             │
│  ├── Hash/List/Set/ZSet 元素数 > 5000                              │
│                                                                     │
│  危害:                                                              │
│  ├── 内存不均: 导致集群内存倾斜                                      │
│  ├── 阻塞: 大Key操作可能阻塞Redis                                   │
│  ├── 网络: 传输大Key占用带宽                                        │
│  └── 删除: DEL大Key会阻塞主线程                                     │
│                                                                     │
└─────────────────────────────────────────────────────────────────────┘

┌─────────────────────────────────────────────────────────────────────┐
│                        发现大Key                                     │
├─────────────────────────────────────────────────────────────────────┤
│                                                                     │
│  # 方法1: redis-cli扫描                                             │
│  redis-cli --bigkeys                                                │
│                                                                     │
│  # 方法2: MEMORY USAGE                                              │
│  MEMORY USAGE key                                                   │
│                                                                     │
│  # 方法3: RDB分析工具                                               │
│  redis-rdb-tools                                                    │
│                                                                     │
└─────────────────────────────────────────────────────────────────────┘

┌─────────────────────────────────────────────────────────────────────┐
│                        解决方案                                      │
├─────────────────────────────────────────────────────────────────────┤
│                                                                     │
│  1. 拆分大Key                                                       │
│  ┌──────────────────────────────────────────────────────────────┐  │
│  │                                                               │  │
│  │  原: user:1:friends = {10000个好友}                           │  │
│  │                                                               │  │
│  │  拆: user:1:friends:0 = {好友1-1000}                          │  │
│  │      user:1:friends:1 = {好友1001-2000}                       │  │
│  │      ...                                                      │  │
│  │                                                               │  │
│  └──────────────────────────────────────────────────────────────┘  │
│                                                                     │
│  2. 压缩数据                                                        │
│  ┌──────────────────────────────────────────────────────────────┐  │
│  │                                                               │  │
│  │  JSON数据 → 压缩存储（gzip/snappy）                            │  │
│  │  精简字段名: userName → un                                     │  │
│  │                                                               │  │
│  └──────────────────────────────────────────────────────────────┘  │
│                                                                     │
│  3. 异步删除                                                        │
│  ┌──────────────────────────────────────────────────────────────┐  │
│  │                                                               │  │
│  │  # 方法1: UNLINK (Redis 4.0+)                                 │  │
│  │  UNLINK bigkey    # 后台异步删除                               │  │
│  │                                                               │  │
│  │  # 方法2: 分批删除                                             │  │
│  │  HSCAN bigkey 0 COUNT 100                                     │  │
│  │  HDEL bigkey field1 field2 ...                                │  │
│  │  ... 循环直到删完                                              │  │
│  │                                                               │  │
│  │  # 配置: 开启lazy-free                                        │  │
│  │  lazyfree-lazy-eviction yes                                   │  │
│  │  lazyfree-lazy-expire yes                                     │  │
│  │  lazyfree-lazy-server-del yes                                 │  │
│  │                                                               │  │
│  └──────────────────────────────────────────────────────────────┘  │
│                                                                     │
└─────────────────────────────────────────────────────────────────────┘
```

---

### 178. 缓存和数据库一致性如何保证？

```
┌─────────────────────────────────────────────────────────────────────┐
│                   常见更新策略对比                                    │
├─────────────────────────────────────────────────────────────────────┤
│                                                                     │
│  策略1: 先更新DB，再删除缓存 ✅ 推荐                                 │
│  ┌──────────────────────────────────────────────────────────────┐  │
│  │                                                               │  │
│  │   1. UPDATE db SET value='new' WHERE id=1                    │  │
│  │   2. DEL cache:1                                             │  │
│  │                                                               │  │
│  │   问题: 删缓存失败怎么办？                                     │  │
│  │   解决: 消息队列重试删除                                       │  │
│  │                                                               │  │
│  └──────────────────────────────────────────────────────────────┘  │
│                                                                     │
│  策略2: 先删除缓存，再更新DB ❌ 不推荐                               │
│  ┌──────────────────────────────────────────────────────────────┐  │
│  │                                                               │  │
│  │   时间线:                                                     │  │
│  │   T1: 线程A删除缓存                                           │  │
│  │   T2: 线程B读缓存Miss，读DB旧值，写入缓存                       │  │
│  │   T3: 线程A更新DB                                             │  │
│  │   结果: 缓存是旧值，DB是新值 → 不一致！                         │  │
│  │                                                               │  │
│  └──────────────────────────────────────────────────────────────┘  │
│                                                                     │
└─────────────────────────────────────────────────────────────────────┘

┌─────────────────────────────────────────────────────────────────────┐
│                  延迟双删策略                                        │
├─────────────────────────────────────────────────────────────────────┤
│                                                                     │
│  ┌──────────────────────────────────────────────────────────────┐  │
│  │                                                               │  │
│  │   1. DEL cache:1              # 第一次删除                    │  │
│  │   2. UPDATE db ...            # 更新数据库                    │  │
│  │   3. sleep(500ms)             # 等待（读请求回填缓存）         │  │
│  │   4. DEL cache:1              # 第二次删除                    │  │
│  │                                                               │  │
│  │   优化: 第二次删除用消息队列异步执行                            │  │
│  │                                                               │  │
│  └──────────────────────────────────────────────────────────────┘  │
│                                                                     │
└─────────────────────────────────────────────────────────────────────┘

┌─────────────────────────────────────────────────────────────────────┐
│                  最终方案: Canal + 消息队列                          │
├─────────────────────────────────────────────────────────────────────┤
│                                                                     │
│  ┌──────────────────────────────────────────────────────────────┐  │
│  │                                                               │  │
│  │   App ───更新───> MySQL ───Binlog───> Canal                  │  │
│  │                                           │                   │  │
│  │                                           ▼                   │  │
│  │                                      消息队列(MQ)              │  │
│  │                                           │                   │  │
│  │                                           ▼                   │  │
│  │                                     消费者删除缓存             │  │
│  │                                           │                   │  │
│  │                                           ▼                   │  │
│  │                                        Redis                  │  │
│  │                                                               │  │
│  │   优势: 业务代码无侵入，保证最终一致性                          │  │
│  │                                                               │  │
│  └──────────────────────────────────────────────────────────────┘  │
│                                                                     │
└─────────────────────────────────────────────────────────────────────┘
```

---

### 179. Redis内存淘汰策略有哪些？

```
┌─────────────────────────────────────────────────────────────────────┐
│                    Redis 8种内存淘汰策略                              │
├─────────────────────────────────────────────────────────────────────┤
│                                                                     │
│  ┌─────────────────────────────────────────────────────────────┐   │
│  │              不淘汰                                          │   │
│  ├─────────────────────────────────────────────────────────────┤   │
│  │  noeviction    │ 内存满后写入报错，默认策略                   │   │
│  └─────────────────────────────────────────────────────────────┘   │
│                                                                     │
│  ┌─────────────────────────────────────────────────────────────┐   │
│  │              从设置了TTL的Key中淘汰                           │   │
│  ├─────────────────────────────────────────────────────────────┤   │
│  │  volatile-lru  │ LRU算法淘汰，最近最少使用                    │   │
│  │  volatile-lfu  │ LFU算法淘汰，使用频率最低（Redis 4.0+）      │   │
│  │  volatile-ttl  │ 淘汰TTL最短的                               │   │
│  │  volatile-random│ 随机淘汰                                   │   │
│  └─────────────────────────────────────────────────────────────┘   │
│                                                                     │
│  ┌─────────────────────────────────────────────────────────────┐   │
│  │              从所有Key中淘汰                                  │   │
│  ├─────────────────────────────────────────────────────────────┤   │
│  │  allkeys-lru   │ 所有Key中LRU淘汰 ⭐推荐                      │   │
│  │  allkeys-lfu   │ 所有Key中LFU淘汰（Redis 4.0+）              │   │
│  │  allkeys-random│ 所有Key随机淘汰                             │   │
│  └─────────────────────────────────────────────────────────────┘   │
│                                                                     │
└─────────────────────────────────────────────────────────────────────┘

┌─────────────────────────────────────────────────────────────────────┐
│                    LRU vs LFU                                       │
├─────────────────────────────────────────────────────────────────────┤
│                                                                     │
│  LRU (Least Recently Used): 最近最少使用                            │
│  ┌──────────────────────────────────────────────────────────────┐  │
│  │  淘汰最久没被访问的Key                                         │  │
│  │  问题: 偶发的大量访问会污染缓存                                 │  │
│  │        如: 某冷数据被扫描一次，就不会被淘汰                     │  │
│  └──────────────────────────────────────────────────────────────┘  │
│                                                                     │
│  LFU (Least Frequently Used): 最不经常使用                          │
│  ┌──────────────────────────────────────────────────────────────┐  │
│  │  淘汰访问次数最少的Key                                         │  │
│  │  更准确反映数据热度，推荐用于热点数据场景                        │  │
│  └──────────────────────────────────────────────────────────────┘  │
│                                                                     │
│  配置:                                                              │
│  maxmemory 4gb                                                     │
│  maxmemory-policy allkeys-lru                                      │
│                                                                     │
└─────────────────────────────────────────────────────────────────────┘
```

---

### 180. Redis为什么这么快？

```
┌─────────────────────────────────────────────────────────────────────┐
│                   Redis 高性能原因                                   │
├─────────────────────────────────────────────────────────────────────┤
│                                                                     │
│  1. 基于内存操作                                                    │
│  ┌──────────────────────────────────────────────────────────────┐  │
│  │                                                               │  │
│  │   内存访问: ~100ns                                            │  │
│  │   磁盘访问: ~10ms (10万倍差距)                                │  │
│  │                                                               │  │
│  │   所有数据存内存，无磁盘I/O瓶颈                                │  │
│  │                                                               │  │
│  └──────────────────────────────────────────────────────────────┘  │
│                                                                     │
│  2. 单线程模型（避免上下文切换和锁竞争）                             │
│  ┌──────────────────────────────────────────────────────────────┐  │
│  │                                                               │  │
│  │   单线程处理命令，无锁竞争开销                                  │  │
│  │                                                               │  │
│  │   注: Redis 6.0+ 网络I/O多线程，命令执行仍单线程               │  │
│  │                                                               │  │
│  └──────────────────────────────────────────────────────────────┘  │
│                                                                     │
│  3. I/O多路复用                                                     │
│  ┌──────────────────────────────────────────────────────────────┐  │
│  │                                                               │  │
│  │      Client1 ─┐                                               │  │
│  │      Client2 ─┼──> epoll ──> 单线程处理                       │  │
│  │      Client3 ─┘    监听多个连接                                │  │
│  │                                                               │  │
│  │   单线程也能处理高并发连接                                      │  │
│  │                                                               │  │
│  └──────────────────────────────────────────────────────────────┘  │
│                                                                     │
│  4. 高效数据结构                                                    │
│  ┌──────────────────────────────────────────────────────────────┐  │
│  │                                                               │  │
│  │   ├── SDS: 预分配、O(1)获取长度                               │  │
│  │   ├── ZipList: 紧凑存储，连续内存                             │  │
│  │   ├── SkipList: 简单高效的有序结构                            │  │
│  │   └── IntSet: 整数集合优化                                    │  │
│  │                                                               │  │
│  └──────────────────────────────────────────────────────────────┘  │
│                                                                     │
│  5. 简单协议 (RESP)                                                 │
│  ┌──────────────────────────────────────────────────────────────┐  │
│  │                                                               │  │
│  │   *3\r\n$3\r\nSET\r\n$4\r\nname\r\n$3\r\ntom\r\n             │  │
│  │                                                               │  │
│  │   文本协议，解析简单快速                                       │  │
│  │                                                               │  │
│  └──────────────────────────────────────────────────────────────┘  │
│                                                                     │
└─────────────────────────────────────────────────────────────────────┘
```

**性能数据参考：**
```
┌────────────────────────────────────────────────────────────────┐
│                   Redis 性能基准                                │
├────────────────────────────────────────────────────────────────┤
│  单实例 QPS: 10万+ (简单命令)                                   │
│  Pipeline: 可达100万+ QPS                                      │
│  延迟: 通常 < 1ms                                              │
│  内存效率: 1GB内存可存约2500万个64字节String                    │
└────────────────────────────────────────────────────────────────┘
```

---

## 📊 Redis 知识总结脑图

```
                              Redis
                                │
        ┌───────────┬───────────┼───────────┬───────────┐
        ▼           ▼           ▼           ▼           ▼
     数据结构      持久化       高可用      缓存问题    性能优化
        │           │           │           │           │
    ┌───┴───┐   ┌───┴───┐   ┌───┴───┐   ┌───┴───┐   ┌───┴───┐
    │       │   │       │   │       │   │       │   │       │
  基本类型  底层  RDB   AOF  主从   哨兵  穿透  击穿  热Key  大Key
    │       │   │       │   │       │   │       │   │       │
  String   SDS  快照  日志  复制  监控  布隆  互斥锁 本地   拆分
  Hash    跳表  fork  重写  全量  选举  过滤  逻辑   缓存   异步
  List   ZipList     混合  增量  Cluster 器   过期   分片   删除
  Set    HashTable
  ZSet
```
